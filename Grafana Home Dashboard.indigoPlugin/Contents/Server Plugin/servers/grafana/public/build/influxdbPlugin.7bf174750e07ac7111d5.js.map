{"version":3,"sources":["webpack:///./public/app/plugins/datasource/influxdb/influx_series.ts","webpack:///./public/app/plugins/datasource/influxdb/query_part.ts","webpack:///./public/app/plugins/datasource/influxdb/influx_query_model.ts","webpack:///./public/app/plugins/datasource/influxdb/response_parser.ts","webpack:///./public/app/plugins/datasource/influxdb/query_builder.ts","webpack:///./public/app/plugins/datasource/influxdb/types.ts","webpack:///./public/app/plugins/datasource/influxdb/datasource.ts","webpack:///./public/app/plugins/datasource/influxdb/query_ctrl.ts","webpack:///./public/app/plugins/datasource/influxdb/components/InfluxCheatSheet.tsx","webpack:///./public/app/plugins/datasource/influxdb/components/InfluxStartPage.tsx","webpack:///./public/app/plugins/datasource/influxdb/components/ConfigEditor.tsx","webpack:///./public/app/plugins/datasource/influxdb/components/FluxQueryEditor.tsx","webpack:///./public/app/plugins/datasource/influxdb/module.ts"],"names":["InfluxSeries","options","this","series","alias","annotation","meta","refId","i","j","output","length","_","each","columns","tags","map","value","key","seriesName","name","columnName","_getSeriesName","join","datapoints","values","push","target","index","segments","split","replace","match","g1","g2","group","segIndex","parseInt","isNaN","indexOf","tag","list","titleCol","timeCol","tagsCol","textCol","column","titleColumn","includes","tagsColumn","textColumn","data","time","Date","title","flatten","filter","t","text","table","TableModel","seriesIndex","type","FieldType","keys","reordered","hasOwnProperty","rows","categories","Aggregations","Selectors","Transformations","Predictors","Math","Aliasing","Fields","createPart","part","def","message","QueryPart","register","QueryPartDef","category","groupByTimeFunctions","fieldRenderer","innerExpr","params","replaceAggregationAddStrategy","selectParts","partModel","morePartsAvailable","splice","addTransformationStrategy","addStrategy","query","parts","clone","selectModels","dynamicLookup","defaultParams","renderer","functionRenderer","partCount","suffixRenderer","quote","renderMode","create","getCategories","replaceAggregationAdd","InfluxQueryModel","templateSrv","scopedVars","policy","resultFormat","orderByTime","groupBy","select","updateProjection","queryPart","groupByParts","find","g","stringParts","typePart","arg","s","modelsIndex","partIndex","updatePersistedParts","interpolate","str","operator","condition","test","measurement","variable","defaultFormatFn","multi","includeAll","kbn","regexEscape","rawQuery","interpolateQueryStr","y","selectText","render","getMeasurementAndPolicy","conditions","renderTagCondition","groupBySection","fill","limit","slimit","tz","filters","ResponseParser","results","influxResults","normalizedQuery","toLowerCase","isValueFirst","res","serie","isArray","addUnique","undefined","toString","arr","InfluxVersion","InfluxQueryBuilder","database","withKey","withMeasurementFilter","whereConditions","reduce","memo","InfluxDatasource","instanceSettings","urls","url","trim","username","password","basicAuth","withCredentials","settingsData","jsonData","interval","timeInterval","httpMode","responseParser","is2x","version","Flux","request","from","classicQuery","getTemplateSrv","timeFilter","getTimeFilter","targets","cloneDeep","queryTargets","allQueries","hide","__interval","queryModel","acc","current","Promise","resolve","adhocFilters","getAdhocFilters","renderAdhocFilters","_seriesQuery","then","seriesList","result","executedQueryString","influxSeries","preferredVisualisationType","getTable","timeSeries","getTimeSeries","reject","rangeRaw","timezone","getAnnotations","param","variableExists","queries","expandedQueries","expandedQuery","datasource","expandedTags","interpolated","resp","parse","queryBuilder","buildExploreQuery","metricFindQuery","range","_influxRequest","q","epoch","encodeURIComponent","requestId","id","now","dashboardId","panelId","intervalMs","maxDataPoints","dateTime","to","toPromise","state","LoadingState","Done","console","log","status","first","catch","err","error","get","method","currentUrl","shift","u","p","db","has","extend","omit","serializeParams","pick","req","precision","inspect","paramSerializer","headers","Authorization","getBackendSrv","datasourceRequest","errors","elem","Number","isInteger","config","statusText","getInfluxTime","until","fromIsAbsolute","date","roundUp","isString","exec","dateMath","valueOf","DataSourceWithBackend","InfluxQueryCtrl","$scope","$injector","uiSegmentSrv","onChange","onRunQuery","panelCtrl","refresh","panel","groupBySegment","newPlusButton","resultFormats","policySegment","newSegment","measurementSegment","newSelectMeasurement","tagSegments","newCondition","newKey","newOperator","newKeyValue","fixTagSegments","buildSelectMenu","removeTagFilterSegment","fake","selectMenu","cat","menu","submenu","item","hasFill","hasGroupByTime","handleQueryError","bind","addGroupBy","plusButton","html","subitem","addSelectPart","evt","fieldsQuery","transformToSegments","removeSelectPart","tagsQuery","removeGroupByPart","count","lastSegment","max","policiesQuery","measurementFilter","addTemplateVars","segment","expandable","getVariables","unshift","nextValue","newOperators","angular","copy","newFake","cssClass","rebuildTargetTagConditions","tagIndex","tagOperator","segment2","getTagValueOperator","tagValue","QueryCtrl","templateUrl","CHEAT_SHEET_ITEMS","label","props","className","InfluxStartPage","InfluxCheatSheet","onClickExample","PureComponent","Select","LegacyForms","Input","SecretFormField","httpModes","versions","InfluxQL","description","ConfigEditor","onResetPassword","updateDatasourcePluginResetOption","onResetToken","onVersionChanged","selected","onOptionsChange","access","user","onUpdateInflux2xURL","e","currentTarget","secureJsonFields","secureJsonData","href","tooltip","placeholder","organization","onUpdateDatasourceJsonDataOption","isConfigured","token","labelWidth","inputWidth","onReset","onUpdateDatasourceSecureJsonDataOption","defaultBucket","showAccessOptions","dataSourceConfig","defaultUrl","onUpdateDatasourceOption","defaultValue","onUpdateDatasourceJsonDataOptionSelect","renderInflux2x","renderInflux1x","samples","FluxQueryEditor","onFluxQueryChange","change","onSampleChange","val","forceUpdate","getSuggestions","sugs","kind","CodeEditorSuggestionItemKind","Property","detail","forEach","Text","editorDidMountCallbackHack","editor","setTimeout","layout","helpTooltip","height","language","onBlur","onSave","showMiniMap","showLineNumbers","onEditorDidMount","cx","css","icon","variant","width","coreModule","directive","reactDirective","InfluxAnnotationsQueryCtrl","plugin","DataSourcePlugin","setConfigEditor","setQueryCtrl","setAnnotationQueryCtrl","setExploreStartPage"],"mappings":"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","file":"influxdbPlugin.7bf174750e07ac7111d5.js","sourcesContent":["import _ from 'lodash';\nimport TableModel from 'app/core/table_model';\nimport { FieldType, QueryResultMeta, TimeSeries, TableData } from '@grafana/data';\n\nexport default class InfluxSeries {\n  refId: string;\n  series: any;\n  alias: any;\n  annotation: any;\n  meta?: QueryResultMeta;\n\n  constructor(options: { series: any; alias?: any; annotation?: any; meta?: QueryResultMeta; refId?: string }) {\n    this.series = options.series;\n    this.alias = options.alias;\n    this.annotation = options.annotation;\n    this.meta = options.meta;\n    this.refId = options.refId;\n  }\n\n  getTimeSeries(): TimeSeries[] {\n    const output: TimeSeries[] = [];\n    let i, j;\n\n    if (this.series.length === 0) {\n      return output;\n    }\n\n    _.each(this.series, series => {\n      const columns = series.columns.length;\n      const tags = _.map(series.tags, (value, key) => {\n        return key + ': ' + value;\n      });\n\n      for (j = 1; j < columns; j++) {\n        let seriesName = series.name;\n        const columnName = series.columns[j];\n        if (columnName !== 'value') {\n          seriesName = seriesName + '.' + columnName;\n        }\n\n        if (this.alias) {\n          seriesName = this._getSeriesName(series, j);\n        } else if (series.tags) {\n          seriesName = seriesName + ' {' + tags.join(', ') + '}';\n        }\n\n        const datapoints = [];\n        if (series.values) {\n          for (i = 0; i < series.values.length; i++) {\n            datapoints[i] = [series.values[i][j], series.values[i][0]];\n          }\n        }\n\n        output.push({ target: seriesName, datapoints: datapoints, meta: this.meta, refId: this.refId });\n      }\n    });\n\n    return output;\n  }\n\n  _getSeriesName(series: any, index: number) {\n    const regex = /\\$(\\w+)|\\[\\[([\\s\\S]+?)\\]\\]/g;\n    const segments = series.name.split('.');\n\n    return this.alias.replace(regex, (match: any, g1: any, g2: any) => {\n      const group = g1 || g2;\n      const segIndex = parseInt(group, 10);\n\n      if (group === 'm' || group === 'measurement') {\n        return series.name;\n      }\n      if (group === 'col') {\n        return series.columns[index];\n      }\n      if (!isNaN(segIndex)) {\n        return segments[segIndex];\n      }\n      if (group.indexOf('tag_') !== 0) {\n        return match;\n      }\n\n      const tag = group.replace('tag_', '');\n      if (!series.tags) {\n        return match;\n      }\n      return series.tags[tag];\n    });\n  }\n\n  getAnnotations() {\n    const list: any[] = [];\n\n    _.each(this.series, series => {\n      let titleCol: any = null;\n      let timeCol: any = null;\n      const tagsCol: any = [];\n      let textCol: any = null;\n\n      _.each(series.columns, (column, index) => {\n        if (column === 'time') {\n          timeCol = index;\n          return;\n        }\n        if (column === 'sequence_number') {\n          return;\n        }\n        if (column === this.annotation.titleColumn) {\n          titleCol = index;\n          return;\n        }\n        if (_.includes((this.annotation.tagsColumn || '').replace(' ', '').split(','), column)) {\n          tagsCol.push(index);\n          return;\n        }\n        if (column === this.annotation.textColumn) {\n          textCol = index;\n          return;\n        }\n        // legacy case\n        if (!titleCol && textCol !== index) {\n          titleCol = index;\n        }\n      });\n\n      _.each(series.values, value => {\n        const data = {\n          annotation: this.annotation,\n          time: +new Date(value[timeCol]),\n          title: value[titleCol],\n          // Remove empty values, then split in different tags for comma separated values\n          tags: _.flatten(\n            tagsCol\n              .filter((t: any) => {\n                return value[t];\n              })\n              .map((t: any) => {\n                return value[t].split(',');\n              })\n          ),\n          text: value[textCol],\n        };\n\n        list.push(data);\n      });\n    });\n\n    return list;\n  }\n\n  getTable(): TableData {\n    const table = new TableModel();\n    let i, j;\n\n    table.refId = this.refId;\n    table.meta = this.meta;\n\n    if (this.series.length === 0) {\n      return table;\n    }\n\n    _.each(this.series, (series: any, seriesIndex: number) => {\n      if (seriesIndex === 0) {\n        j = 0;\n        // Check that the first column is indeed 'time'\n        if (series.columns[0] === 'time') {\n          // Push this now before the tags and with the right type\n          table.columns.push({ text: 'Time', type: FieldType.time });\n          j++;\n        }\n        _.each(_.keys(series.tags), key => {\n          table.columns.push({ text: key });\n        });\n        for (; j < series.columns.length; j++) {\n          table.columns.push({ text: series.columns[j] });\n        }\n      }\n\n      if (series.values) {\n        for (i = 0; i < series.values.length; i++) {\n          const values = series.values[i];\n          const reordered = [values[0]];\n          if (series.tags) {\n            for (const key in series.tags) {\n              if (series.tags.hasOwnProperty(key)) {\n                reordered.push(series.tags[key]);\n              }\n            }\n          }\n          for (j = 1; j < values.length; j++) {\n            reordered.push(values[j]);\n          }\n          table.rows.push(reordered);\n        }\n      }\n    });\n\n    return table;\n  }\n}\n","import _ from 'lodash';\nimport { QueryPartDef, QueryPart, functionRenderer, suffixRenderer } from 'app/core/components/query_part/query_part';\n\nconst index: any[] = [];\nconst categories: any = {\n  Aggregations: [],\n  Selectors: [],\n  Transformations: [],\n  Predictors: [],\n  Math: [],\n  Aliasing: [],\n  Fields: [],\n};\n\nfunction createPart(part: any): any {\n  const def = index[part.type];\n  if (!def) {\n    throw { message: 'Could not find query part ' + part.type };\n  }\n\n  return new QueryPart(part, def);\n}\n\nfunction register(options: any) {\n  index[options.type] = new QueryPartDef(options);\n  options.category.push(index[options.type]);\n}\n\nconst groupByTimeFunctions: any[] = [];\n\nfunction aliasRenderer(part: { params: string[] }, innerExpr: string) {\n  return innerExpr + ' AS ' + '\"' + part.params[0] + '\"';\n}\n\nfunction fieldRenderer(part: { params: string[] }, innerExpr: any) {\n  if (part.params[0] === '*') {\n    return '*';\n  }\n  return '\"' + part.params[0] + '\"';\n}\n\nfunction replaceAggregationAddStrategy(selectParts: any[], partModel: { def: { type: string } }) {\n  // look for existing aggregation\n  for (let i = 0; i < selectParts.length; i++) {\n    const part = selectParts[i];\n    if (part.def.category === categories.Aggregations) {\n      if (part.def.type === partModel.def.type) {\n        return;\n      }\n      // count distinct is allowed\n      if (part.def.type === 'count' && partModel.def.type === 'distinct') {\n        break;\n      }\n      // remove next aggregation if distinct was replaced\n      if (part.def.type === 'distinct') {\n        const morePartsAvailable = selectParts.length >= i + 2;\n        if (partModel.def.type !== 'count' && morePartsAvailable) {\n          const nextPart = selectParts[i + 1];\n          if (nextPart.def.category === categories.Aggregations) {\n            selectParts.splice(i + 1, 1);\n          }\n        } else if (partModel.def.type === 'count') {\n          if (!morePartsAvailable || selectParts[i + 1].def.type !== 'count') {\n            selectParts.splice(i + 1, 0, partModel);\n          }\n          return;\n        }\n      }\n      selectParts[i] = partModel;\n      return;\n    }\n    if (part.def.category === categories.Selectors) {\n      selectParts[i] = partModel;\n      return;\n    }\n  }\n\n  selectParts.splice(1, 0, partModel);\n}\n\nfunction addTransformationStrategy(selectParts: any[], partModel: any) {\n  let i;\n  // look for index to add transformation\n  for (i = 0; i < selectParts.length; i++) {\n    const part = selectParts[i];\n    if (part.def.category === categories.Math || part.def.category === categories.Aliasing) {\n      break;\n    }\n  }\n\n  selectParts.splice(i, 0, partModel);\n}\n\nfunction addMathStrategy(selectParts: any[], partModel: any) {\n  const partCount = selectParts.length;\n  if (partCount > 0) {\n    // if last is math, replace it\n    if (selectParts[partCount - 1].def.type === 'math') {\n      selectParts[partCount - 1] = partModel;\n      return;\n    }\n    // if next to last is math, replace it\n    if (partCount > 1 && selectParts[partCount - 2].def.type === 'math') {\n      selectParts[partCount - 2] = partModel;\n      return;\n    } else if (selectParts[partCount - 1].def.type === 'alias') {\n      // if last is alias add it before\n      selectParts.splice(partCount - 1, 0, partModel);\n      return;\n    }\n  }\n  selectParts.push(partModel);\n}\n\nfunction addAliasStrategy(selectParts: any[], partModel: any) {\n  const partCount = selectParts.length;\n  if (partCount > 0) {\n    // if last is alias, replace it\n    if (selectParts[partCount - 1].def.type === 'alias') {\n      selectParts[partCount - 1] = partModel;\n      return;\n    }\n  }\n  selectParts.push(partModel);\n}\n\nfunction addFieldStrategy(selectParts: any, partModel: any, query: { selectModels: any[][] }) {\n  // copy all parts\n  const parts = _.map(selectParts, (part: any) => {\n    return createPart({ type: part.def.type, params: _.clone(part.params) });\n  });\n\n  query.selectModels.push(parts);\n}\n\nregister({\n  type: 'field',\n  addStrategy: addFieldStrategy,\n  category: categories.Fields,\n  params: [{ type: 'field', dynamicLookup: true }],\n  defaultParams: ['value'],\n  renderer: fieldRenderer,\n});\n\n// Aggregations\nregister({\n  type: 'count',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'distinct',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'integral',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'mean',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'median',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'mode',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'sum',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\n// transformations\n\nregister({\n  type: 'derivative',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [\n    {\n      name: 'duration',\n      type: 'interval',\n      options: ['1s', '10s', '1m', '5m', '10m', '15m', '1h'],\n    },\n  ],\n  defaultParams: ['10s'],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'spread',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'non_negative_derivative',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [\n    {\n      name: 'duration',\n      type: 'interval',\n      options: ['1s', '10s', '1m', '5m', '10m', '15m', '1h'],\n    },\n  ],\n  defaultParams: ['10s'],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'difference',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'non_negative_difference',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'moving_average',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [{ name: 'window', type: 'int', options: [5, 10, 20, 30, 40] }],\n  defaultParams: [10],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'cumulative_sum',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'stddev',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'time',\n  category: groupByTimeFunctions,\n  params: [\n    {\n      name: 'interval',\n      type: 'time',\n      options: ['$__interval', '1s', '10s', '1m', '5m', '10m', '15m', '1h'],\n    },\n  ],\n  defaultParams: ['$__interval'],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'fill',\n  category: groupByTimeFunctions,\n  params: [\n    {\n      name: 'fill',\n      type: 'string',\n      options: ['none', 'null', '0', 'previous', 'linear'],\n    },\n  ],\n  defaultParams: ['null'],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'elapsed',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [\n    {\n      name: 'duration',\n      type: 'interval',\n      options: ['1s', '10s', '1m', '5m', '10m', '15m', '1h'],\n    },\n  ],\n  defaultParams: ['10s'],\n  renderer: functionRenderer,\n});\n\n// predictions\nregister({\n  type: 'holt_winters',\n  addStrategy: addTransformationStrategy,\n  category: categories.Predictors,\n  params: [\n    { name: 'number', type: 'int', options: [5, 10, 20, 30, 40] },\n    { name: 'season', type: 'int', options: [0, 1, 2, 5, 10] },\n  ],\n  defaultParams: [10, 2],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'holt_winters_with_fit',\n  addStrategy: addTransformationStrategy,\n  category: categories.Predictors,\n  params: [\n    { name: 'number', type: 'int', options: [5, 10, 20, 30, 40] },\n    { name: 'season', type: 'int', options: [0, 1, 2, 5, 10] },\n  ],\n  defaultParams: [10, 2],\n  renderer: functionRenderer,\n});\n\n// Selectors\nregister({\n  type: 'bottom',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [{ name: 'count', type: 'int' }],\n  defaultParams: [3],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'first',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'last',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'max',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'min',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'percentile',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [{ name: 'nth', type: 'int' }],\n  defaultParams: [95],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'top',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [{ name: 'count', type: 'int' }],\n  defaultParams: [3],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'tag',\n  category: groupByTimeFunctions,\n  params: [{ name: 'tag', type: 'string', dynamicLookup: true }],\n  defaultParams: ['tag'],\n  renderer: fieldRenderer,\n});\n\nregister({\n  type: 'math',\n  addStrategy: addMathStrategy,\n  category: categories.Math,\n  params: [{ name: 'expr', type: 'string' }],\n  defaultParams: [' / 100'],\n  renderer: suffixRenderer,\n});\n\nregister({\n  type: 'alias',\n  addStrategy: addAliasStrategy,\n  category: categories.Aliasing,\n  params: [{ name: 'name', type: 'string', quote: 'double' }],\n  defaultParams: ['alias'],\n  renderMode: 'suffix',\n  renderer: aliasRenderer,\n});\n\nexport default {\n  create: createPart,\n  getCategories: () => {\n    return categories;\n  },\n  replaceAggregationAdd: replaceAggregationAddStrategy,\n};\n","import _ from 'lodash';\nimport queryPart from './query_part';\nimport kbn from 'app/core/utils/kbn';\nimport { InfluxQuery, InfluxQueryTag } from './types';\nimport { ScopedVars } from '@grafana/data';\nimport { TemplateSrv } from '@grafana/runtime';\n\nexport default class InfluxQueryModel {\n  target: InfluxQuery;\n  selectModels: any[];\n  queryBuilder: any;\n  groupByParts: any;\n  templateSrv: any;\n  scopedVars: any;\n  refId: string;\n\n  /** @ngInject */\n  constructor(target: InfluxQuery, templateSrv?: TemplateSrv, scopedVars?: ScopedVars) {\n    this.target = target;\n    this.templateSrv = templateSrv;\n    this.scopedVars = scopedVars;\n\n    target.policy = target.policy || 'default';\n    target.resultFormat = target.resultFormat || 'time_series';\n    target.orderByTime = target.orderByTime || 'ASC';\n    target.tags = target.tags || [];\n    target.groupBy = target.groupBy || [\n      { type: 'time', params: ['$__interval'] },\n      { type: 'fill', params: ['null'] },\n    ];\n    target.select = target.select || [\n      [\n        { type: 'field', params: ['value'] },\n        { type: 'mean', params: [] },\n      ],\n    ];\n\n    this.updateProjection();\n  }\n\n  updateProjection() {\n    this.selectModels = _.map(this.target.select, (parts: any) => {\n      return _.map(parts, queryPart.create);\n    });\n    this.groupByParts = _.map(this.target.groupBy, queryPart.create);\n  }\n\n  updatePersistedParts() {\n    this.target.select = _.map(this.selectModels, selectParts => {\n      return _.map(selectParts, (part: any) => {\n        return { type: part.def.type, params: part.params };\n      });\n    });\n  }\n\n  hasGroupByTime() {\n    return _.find(this.target.groupBy, (g: any) => g.type === 'time');\n  }\n\n  hasFill() {\n    return _.find(this.target.groupBy, (g: any) => g.type === 'fill');\n  }\n\n  addGroupBy(value: string) {\n    let stringParts = value.match(/^(\\w+)\\((.*)\\)$/);\n\n    if (!stringParts || !this.target.groupBy) {\n      return;\n    }\n\n    const typePart = stringParts[1];\n    const arg = stringParts[2];\n    const partModel = queryPart.create({ type: typePart, params: [arg] });\n    const partCount = this.target.groupBy.length;\n\n    if (partCount === 0) {\n      this.target.groupBy.push(partModel.part);\n    } else if (typePart === 'time') {\n      this.target.groupBy.splice(0, 0, partModel.part);\n    } else if (typePart === 'tag') {\n      if (this.target.groupBy[partCount - 1].type === 'fill') {\n        this.target.groupBy.splice(partCount - 1, 0, partModel.part);\n      } else {\n        this.target.groupBy.push(partModel.part);\n      }\n    } else {\n      this.target.groupBy.push(partModel.part);\n    }\n\n    this.updateProjection();\n  }\n\n  removeGroupByPart(part: { def: { type: string } }, index: number) {\n    const categories = queryPart.getCategories();\n\n    if (part.def.type === 'time') {\n      // remove fill\n      this.target.groupBy = _.filter(this.target.groupBy, (g: any) => g.type !== 'fill');\n      // remove aggregations\n      this.target.select = _.map(this.target.select, (s: any) => {\n        return _.filter(s, (part: any) => {\n          const partModel = queryPart.create(part);\n          if (partModel.def.category === categories.Aggregations) {\n            return false;\n          }\n          if (partModel.def.category === categories.Selectors) {\n            return false;\n          }\n          return true;\n        });\n      });\n    }\n\n    this.target.groupBy.splice(index, 1);\n    this.updateProjection();\n  }\n\n  removeSelect(index: number) {\n    this.target.select.splice(index, 1);\n    this.updateProjection();\n  }\n\n  removeSelectPart(selectParts: any[], part: any) {\n    // if we remove the field remove the whole statement\n    if (part.def.type === 'field') {\n      if (this.selectModels.length > 1) {\n        const modelsIndex = _.indexOf(this.selectModels, selectParts);\n        this.selectModels.splice(modelsIndex, 1);\n      }\n    } else {\n      const partIndex = _.indexOf(selectParts, part);\n      selectParts.splice(partIndex, 1);\n    }\n\n    this.updatePersistedParts();\n  }\n\n  addSelectPart(selectParts: any[], type: string) {\n    const partModel = queryPart.create({ type: type });\n    partModel.def.addStrategy(selectParts, partModel, this);\n    this.updatePersistedParts();\n  }\n\n  private renderTagCondition(tag: InfluxQueryTag, index: number, interpolate: boolean) {\n    let str = '';\n    let operator = tag.operator;\n    let value = tag.value;\n    if (index > 0) {\n      str = (tag.condition || 'AND') + ' ';\n    }\n\n    if (!operator) {\n      if (/^\\/.*\\/$/.test(value)) {\n        operator = '=~';\n      } else {\n        operator = '=';\n      }\n    }\n\n    // quote value unless regex\n    if (operator !== '=~' && operator !== '!~') {\n      if (interpolate) {\n        value = this.templateSrv.replace(value, this.scopedVars);\n      }\n      if (operator !== '>' && operator !== '<') {\n        value = \"'\" + value.replace(/\\\\/g, '\\\\\\\\').replace(/\\'/g, \"\\\\'\") + \"'\";\n      }\n    } else if (interpolate) {\n      value = this.templateSrv.replace(value, this.scopedVars, 'regex');\n    }\n\n    return str + '\"' + tag.key + '\" ' + operator + ' ' + value;\n  }\n\n  getMeasurementAndPolicy(interpolate: any) {\n    let policy = this.target.policy;\n    let measurement = this.target.measurement || 'measurement';\n\n    if (!measurement.match('^/.*/$')) {\n      measurement = '\"' + measurement + '\"';\n    } else if (interpolate) {\n      measurement = this.templateSrv.replace(measurement, this.scopedVars, 'regex');\n    }\n\n    if (policy !== 'default') {\n      policy = '\"' + this.target.policy + '\".';\n    } else {\n      policy = '';\n    }\n\n    return policy + measurement;\n  }\n\n  interpolateQueryStr(value: any[], variable: { multi: any; includeAll: any }, defaultFormatFn: any) {\n    // if no multi or include all do not regexEscape\n    if (!variable.multi && !variable.includeAll) {\n      return value;\n    }\n\n    if (typeof value === 'string') {\n      return kbn.regexEscape(value);\n    }\n\n    const escapedValues = _.map(value, kbn.regexEscape);\n    return '(' + escapedValues.join('|') + ')';\n  }\n\n  render(interpolate?: boolean) {\n    const target = this.target;\n\n    if (target.rawQuery) {\n      if (interpolate) {\n        return this.templateSrv.replace(target.query, this.scopedVars, this.interpolateQueryStr);\n      } else {\n        return target.query;\n      }\n    }\n\n    let query = 'SELECT ';\n    let i, y;\n    for (i = 0; i < this.selectModels.length; i++) {\n      const parts = this.selectModels[i];\n      let selectText = '';\n      for (y = 0; y < parts.length; y++) {\n        const part = parts[y];\n        selectText = part.render(selectText);\n      }\n\n      if (i > 0) {\n        query += ', ';\n      }\n      query += selectText;\n    }\n\n    query += ' FROM ' + this.getMeasurementAndPolicy(interpolate) + ' WHERE ';\n    const conditions = _.map(target.tags, (tag, index) => {\n      return this.renderTagCondition(tag, index, interpolate);\n    });\n\n    if (conditions.length > 0) {\n      query += '(' + conditions.join(' ') + ') AND ';\n    }\n\n    query += '$timeFilter';\n\n    let groupBySection = '';\n    for (i = 0; i < this.groupByParts.length; i++) {\n      const part = this.groupByParts[i];\n      if (i > 0) {\n        // for some reason fill has no separator\n        groupBySection += part.def.type === 'fill' ? ' ' : ', ';\n      }\n      groupBySection += part.render('');\n    }\n\n    if (groupBySection.length) {\n      query += ' GROUP BY ' + groupBySection;\n    }\n\n    if (target.fill) {\n      query += ' fill(' + target.fill + ')';\n    }\n\n    if (target.orderByTime === 'DESC') {\n      query += ' ORDER BY time DESC';\n    }\n\n    if (target.limit) {\n      query += ' LIMIT ' + target.limit;\n    }\n\n    if (target.slimit) {\n      query += ' SLIMIT ' + target.slimit;\n    }\n\n    if (target.tz) {\n      query += \" tz('\" + target.tz + \"')\";\n    }\n\n    return query;\n  }\n\n  renderAdhocFilters(filters: any[]) {\n    const conditions = _.map(filters, (tag, index) => {\n      return this.renderTagCondition(tag, index, true);\n    });\n    return conditions.join(' ');\n  }\n}\n","import _ from 'lodash';\n\nexport default class ResponseParser {\n  parse(query: string, results: { results: any }) {\n    if (!results || results.results.length === 0) {\n      return [];\n    }\n\n    const influxResults = results.results[0];\n    if (!influxResults.series) {\n      return [];\n    }\n\n    const normalizedQuery = query.toLowerCase();\n    const isValueFirst =\n      normalizedQuery.indexOf('show field keys') >= 0 || normalizedQuery.indexOf('show retention policies') >= 0;\n\n    const res = {};\n    _.each(influxResults.series, serie => {\n      _.each(serie.values, value => {\n        if (_.isArray(value)) {\n          // In general, there are 2 possible shapes for the returned value.\n          // The first one is a two-element array,\n          // where the first element is somewhat a metadata value:\n          // the tag name for SHOW TAG VALUES queries,\n          // the time field for SELECT queries, etc.\n          // The second shape is an one-element array,\n          // that is containing an immediate value.\n          // For example, SHOW FIELD KEYS queries return such shape.\n          // Note, pre-0.11 versions return\n          // the second shape for SHOW TAG VALUES queries\n          // (while the newer versions—first).\n\n          if (isValueFirst) {\n            addUnique(res, value[0]);\n          } else if (value[1] !== undefined) {\n            addUnique(res, value[1]);\n          } else {\n            addUnique(res, value[0]);\n          }\n        } else {\n          addUnique(res, value);\n        }\n      });\n    });\n\n    // @ts-ignore problems with typings for this _.map only accepts [] but this needs to be object\n    return _.map(res, value => {\n      // @ts-ignore\n      return { text: value.toString() };\n    });\n  }\n}\n\nfunction addUnique(arr: { [x: string]: any }, value: string | number) {\n  arr[value] = value;\n}\n","import _ from 'lodash';\nimport kbn from 'app/core/utils/kbn';\n\nfunction renderTagCondition(tag: { operator: any; value: string; condition: any; key: string }, index: number) {\n  let str = '';\n  let operator = tag.operator;\n  let value = tag.value;\n  if (index > 0) {\n    str = (tag.condition || 'AND') + ' ';\n  }\n\n  if (!operator) {\n    if (/^\\/.*\\/$/.test(tag.value)) {\n      operator = '=~';\n    } else {\n      operator = '=';\n    }\n  }\n\n  // quote value unless regex or number\n  if (operator !== '=~' && operator !== '!~' && isNaN(+value)) {\n    value = \"'\" + value + \"'\";\n  }\n\n  return str + '\"' + tag.key + '\" ' + operator + ' ' + value;\n}\n\nexport class InfluxQueryBuilder {\n  constructor(private target: { measurement: any; tags: any; policy?: any }, private database?: string) {}\n\n  buildExploreQuery(type: string, withKey?: string, withMeasurementFilter?: string) {\n    let query;\n    let measurement;\n    let policy;\n\n    if (type === 'TAG_KEYS') {\n      query = 'SHOW TAG KEYS';\n      measurement = this.target.measurement;\n      policy = this.target.policy;\n    } else if (type === 'TAG_VALUES') {\n      query = 'SHOW TAG VALUES';\n      measurement = this.target.measurement;\n      policy = this.target.policy;\n    } else if (type === 'MEASUREMENTS') {\n      query = 'SHOW MEASUREMENTS';\n      if (withMeasurementFilter) {\n        query += ' WITH MEASUREMENT =~ /' + kbn.regexEscape(withMeasurementFilter) + '/';\n      }\n    } else if (type === 'FIELDS') {\n      measurement = this.target.measurement;\n      policy = this.target.policy;\n\n      if (!measurement.match('^/.*/')) {\n        measurement = '\"' + measurement + '\"';\n\n        if (policy && policy !== 'default') {\n          policy = '\"' + policy + '\"';\n          measurement = policy + '.' + measurement;\n        }\n      }\n\n      return 'SHOW FIELD KEYS FROM ' + measurement;\n    } else if (type === 'RETENTION POLICIES') {\n      query = 'SHOW RETENTION POLICIES on \"' + this.database + '\"';\n      return query;\n    }\n\n    if (measurement) {\n      if (!measurement.match('^/.*/') && !measurement.match(/^merge\\(.*\\)/)) {\n        measurement = '\"' + measurement + '\"';\n      }\n\n      if (policy && policy !== 'default') {\n        policy = '\"' + policy + '\"';\n        measurement = policy + '.' + measurement;\n      }\n\n      query += ' FROM ' + measurement;\n    }\n\n    if (withKey) {\n      query += ' WITH KEY = \"' + withKey + '\"';\n    }\n\n    if (this.target.tags && this.target.tags.length > 0) {\n      const whereConditions = _.reduce(\n        this.target.tags,\n        (memo, tag) => {\n          // do not add a condition for the key we want to explore for\n          if (tag.key === withKey) {\n            return memo;\n          }\n\n          // value operators not supported in these types of queries\n          if (tag.operator === '>' || tag.operator === '<') {\n            return memo;\n          }\n\n          memo.push(renderTagCondition(tag, memo.length));\n          return memo;\n        },\n        []\n      );\n\n      if (whereConditions.length > 0) {\n        query += ' WHERE ' + whereConditions.join(' ');\n      }\n    }\n    if (type === 'MEASUREMENTS') {\n      query += ' LIMIT 100';\n      //Solve issue #2524 by limiting the number of measurements returned\n      //LIMIT must be after WITH MEASUREMENT and WHERE clauses\n      //This also could be used for TAG KEYS and TAG VALUES, if desired\n    }\n    return query;\n  }\n}\n","import { DataQuery, DataSourceJsonData } from '@grafana/data';\n\nexport enum InfluxVersion {\n  InfluxQL = 'InfluxQL',\n  Flux = 'Flux',\n}\n\nexport interface InfluxOptions extends DataSourceJsonData {\n  version?: InfluxVersion;\n\n  timeInterval: string;\n  httpMode: string;\n\n  // With Flux\n  organization?: string;\n  defaultBucket?: string;\n  maxSeries?: number;\n}\n\nexport interface InfluxSecureJsonData {\n  // For Flux\n  token?: string;\n\n  // In 1x a different password can be sent than then HTTP auth\n  password?: string;\n}\n\nexport interface InfluxQueryPart {\n  type: string;\n  params?: string[];\n  interval?: string;\n}\n\nexport interface InfluxQueryTag {\n  key: string;\n  operator?: string;\n  condition?: string;\n  value: string;\n}\n\nexport interface InfluxQuery extends DataQuery {\n  policy?: string;\n  measurement?: string;\n  resultFormat?: 'time_series' | 'table';\n  orderByTime?: string;\n  tags?: InfluxQueryTag[];\n  groupBy?: InfluxQueryPart[];\n  select?: InfluxQueryPart[][];\n  limit?: string;\n  slimit?: string;\n  tz?: string;\n  fill?: string;\n  rawQuery?: boolean;\n  query?: string;\n}\n","import _ from 'lodash';\n\nimport {\n  dateMath,\n  DataSourceInstanceSettings,\n  ScopedVars,\n  DataQueryRequest,\n  DataQueryResponse,\n  dateTime,\n  LoadingState,\n  QueryResultMeta,\n} from '@grafana/data';\nimport InfluxSeries from './influx_series';\nimport InfluxQueryModel from './influx_query_model';\nimport ResponseParser from './response_parser';\nimport { InfluxQueryBuilder } from './query_builder';\nimport { InfluxQuery, InfluxOptions, InfluxVersion } from './types';\nimport { getBackendSrv, getTemplateSrv, DataSourceWithBackend } from '@grafana/runtime';\nimport { Observable, from } from 'rxjs';\n\nexport default class InfluxDatasource extends DataSourceWithBackend<InfluxQuery, InfluxOptions> {\n  type: string;\n  urls: string[];\n  username: string;\n  password: string;\n  name: string;\n  database: any;\n  basicAuth: any;\n  withCredentials: any;\n  interval: any;\n  responseParser: any;\n  httpMode: string;\n  is2x: boolean;\n\n  constructor(instanceSettings: DataSourceInstanceSettings<InfluxOptions>) {\n    super(instanceSettings);\n    this.type = 'influxdb';\n    this.urls = _.map(instanceSettings.url.split(','), url => {\n      return url.trim();\n    });\n\n    this.username = instanceSettings.username ?? '';\n    this.password = instanceSettings.password ?? '';\n    this.name = instanceSettings.name;\n    this.database = instanceSettings.database;\n    this.basicAuth = instanceSettings.basicAuth;\n    this.withCredentials = instanceSettings.withCredentials;\n    const settingsData = instanceSettings.jsonData || ({} as InfluxOptions);\n    this.interval = settingsData.timeInterval;\n    this.httpMode = settingsData.httpMode || 'GET';\n    this.responseParser = new ResponseParser();\n    this.is2x = settingsData.version === InfluxVersion.Flux;\n  }\n\n  query(request: DataQueryRequest<InfluxQuery>): Observable<DataQueryResponse> {\n    if (this.is2x) {\n      return super.query(request);\n    }\n\n    // Fallback to classic query support\n    return from(this.classicQuery(request));\n  }\n\n  getQueryDisplayText(query: InfluxQuery) {\n    if (this.is2x) {\n      return query.query;\n    }\n    return new InfluxQueryModel(query).render(false);\n  }\n\n  /**\n   * Only applied on flux queries\n   */\n  applyTemplateVariables(query: InfluxQuery, scopedVars: ScopedVars): Record<string, any> {\n    return {\n      ...query,\n      query: getTemplateSrv().replace(query.query, scopedVars), // The raw query text\n    };\n  }\n\n  /**\n   * The unchanged pre 7.1 query implementation\n   */\n  async classicQuery(options: any): Promise<DataQueryResponse> {\n    let timeFilter = this.getTimeFilter(options);\n    const scopedVars = options.scopedVars;\n    const targets = _.cloneDeep(options.targets);\n    const queryTargets: any[] = [];\n    let queryModel: InfluxQueryModel;\n    let i, y;\n    const templateSrv = getTemplateSrv();\n\n    let allQueries = _.map(targets, target => {\n      if (target.hide) {\n        return '';\n      }\n\n      queryTargets.push(target);\n\n      // backward compatibility\n      scopedVars.interval = scopedVars.__interval;\n\n      queryModel = new InfluxQueryModel(target, templateSrv, scopedVars);\n      return queryModel.render(true);\n    }).reduce((acc, current) => {\n      if (current !== '') {\n        acc += ';' + current;\n      }\n      return acc;\n    });\n\n    if (allQueries === '') {\n      return Promise.resolve({ data: [] });\n    }\n\n    // add global adhoc filters to timeFilter\n    const adhocFilters = (templateSrv as any).getAdhocFilters(this.name);\n    if (adhocFilters.length > 0) {\n      timeFilter += ' AND ' + queryModel.renderAdhocFilters(adhocFilters);\n    }\n\n    // replace grafana variables\n    scopedVars.timeFilter = { value: timeFilter };\n\n    // replace templated variables\n    allQueries = templateSrv.replace(allQueries, scopedVars);\n\n    return this._seriesQuery(allQueries, options).then((data: any): any => {\n      if (!data || !data.results) {\n        return [];\n      }\n\n      const seriesList = [];\n      for (i = 0; i < data.results.length; i++) {\n        const result = data.results[i];\n        if (!result || !result.series) {\n          continue;\n        }\n\n        const target = queryTargets[i];\n        let alias = target.alias;\n        if (alias) {\n          alias = templateSrv.replace(target.alias, options.scopedVars);\n        }\n\n        const meta: QueryResultMeta = {\n          executedQueryString: data.executedQueryString,\n        };\n\n        const influxSeries = new InfluxSeries({\n          refId: target.refId,\n          series: data.results[i].series,\n          alias: alias,\n          meta,\n        });\n\n        switch (target.resultFormat) {\n          case 'logs':\n            meta.preferredVisualisationType = 'logs';\n          case 'table': {\n            seriesList.push(influxSeries.getTable());\n            break;\n          }\n          default: {\n            const timeSeries = influxSeries.getTimeSeries();\n            for (y = 0; y < timeSeries.length; y++) {\n              seriesList.push(timeSeries[y]);\n            }\n            break;\n          }\n        }\n      }\n\n      return { data: seriesList };\n    });\n  }\n\n  annotationQuery(options: any) {\n    if (!options.annotation.query) {\n      return Promise.reject({\n        message: 'Query missing in annotation definition',\n      });\n    }\n\n    const timeFilter = this.getTimeFilter({ rangeRaw: options.rangeRaw, timezone: options.timezone });\n    let query = options.annotation.query.replace('$timeFilter', timeFilter);\n    query = getTemplateSrv().replace(query, null, 'regex');\n\n    return this._seriesQuery(query, options).then((data: any) => {\n      if (!data || !data.results || !data.results[0]) {\n        throw { message: 'No results in response from InfluxDB' };\n      }\n      return new InfluxSeries({\n        series: data.results[0].series,\n        annotation: options.annotation,\n      }).getAnnotations();\n    });\n  }\n\n  targetContainsTemplate(target: any) {\n    const templateSrv = getTemplateSrv() as any; // :(\n\n    for (const group of target.groupBy) {\n      for (const param of group.params) {\n        if (templateSrv.variableExists(param)) {\n          return true;\n        }\n      }\n    }\n\n    for (const i in target.tags) {\n      if (templateSrv.variableExists(target.tags[i].value)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  interpolateVariablesInQueries(queries: InfluxQuery[], scopedVars: ScopedVars): InfluxQuery[] {\n    if (!queries || queries.length === 0) {\n      return [];\n    }\n\n    let expandedQueries = queries;\n    if (queries && queries.length > 0) {\n      const templateSrv = getTemplateSrv();\n\n      expandedQueries = queries.map(query => {\n        const expandedQuery = {\n          ...query,\n          datasource: this.name,\n          measurement: templateSrv.replace(query.measurement ?? '', scopedVars, 'regex'),\n          policy: templateSrv.replace(query.policy ?? '', scopedVars, 'regex'),\n        };\n\n        if (query.rawQuery) {\n          expandedQuery.query = templateSrv.replace(query.query ?? '', scopedVars, 'regex');\n        }\n\n        if (query.tags) {\n          const expandedTags = query.tags.map(tag => {\n            const expandedTag = {\n              ...tag,\n              value: templateSrv.replace(tag.value, null, 'regex'),\n            };\n            return expandedTag;\n          });\n          expandedQuery.tags = expandedTags;\n        }\n        return expandedQuery;\n      });\n    }\n    return expandedQueries;\n  }\n\n  metricFindQuery(query: string, options?: any) {\n    const interpolated = getTemplateSrv().replace(query, null, 'regex');\n\n    return this._seriesQuery(interpolated, options).then(resp => {\n      return this.responseParser.parse(query, resp);\n    });\n  }\n\n  getTagKeys(options: any = {}) {\n    const queryBuilder = new InfluxQueryBuilder({ measurement: options.measurement || '', tags: [] }, this.database);\n    const query = queryBuilder.buildExploreQuery('TAG_KEYS');\n    return this.metricFindQuery(query, options);\n  }\n\n  getTagValues(options: any = {}) {\n    const queryBuilder = new InfluxQueryBuilder({ measurement: options.measurement || '', tags: [] }, this.database);\n    const query = queryBuilder.buildExploreQuery('TAG_VALUES', options.key);\n    return this.metricFindQuery(query, options);\n  }\n\n  _seriesQuery(query: string, options?: any) {\n    if (!query) {\n      return Promise.resolve({ results: [] });\n    }\n\n    if (options && options.range) {\n      const timeFilter = this.getTimeFilter({ rangeRaw: options.range, timezone: options.timezone });\n      query = query.replace('$timeFilter', timeFilter);\n    }\n\n    return this._influxRequest(this.httpMode, '/query', { q: query, epoch: 'ms' }, options);\n  }\n\n  serializeParams(params: any) {\n    if (!params) {\n      return '';\n    }\n\n    return _.reduce(\n      params,\n      (memo, value, key) => {\n        if (value === null || value === undefined) {\n          return memo;\n        }\n        memo.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));\n        return memo;\n      },\n      []\n    ).join('&');\n  }\n\n  testDatasource() {\n    if (this.is2x) {\n      // TODO: eventually use the real /health endpoint\n      const request: DataQueryRequest<InfluxQuery> = {\n        targets: [{ refId: 'test', query: 'buckets()' }],\n        requestId: `${this.id}-health-${Date.now()}`,\n        dashboardId: 0,\n        panelId: 0,\n        interval: '1m',\n        intervalMs: 60000,\n        maxDataPoints: 423,\n        range: {\n          from: dateTime(1000),\n          to: dateTime(2000),\n        },\n      } as DataQueryRequest<InfluxQuery>;\n\n      return super\n        .query(request)\n        .toPromise()\n        .then((res: DataQueryResponse) => {\n          if (!res || !res.data || res.state !== LoadingState.Done) {\n            console.log('InfluxDB Error', res);\n            return { status: 'error', message: 'Error reading InfluxDB' };\n          }\n          const first = res.data[0];\n          if (first && first.length) {\n            return { status: 'success', message: `${first.length} buckets found` };\n          }\n          console.log('InfluxDB Error', res);\n          return { status: 'error', message: 'Error reading buckets' };\n        })\n        .catch((err: any) => {\n          console.log('InfluxDB Error', err);\n          return { status: 'error', message: err.message };\n        });\n    }\n\n    const queryBuilder = new InfluxQueryBuilder({ measurement: '', tags: [] }, this.database);\n    const query = queryBuilder.buildExploreQuery('RETENTION POLICIES');\n\n    return this._seriesQuery(query)\n      .then((res: any) => {\n        const error = _.get(res, 'results[0].error');\n        if (error) {\n          return { status: 'error', message: error };\n        }\n        return { status: 'success', message: 'Data source is working' };\n      })\n      .catch((err: any) => {\n        return { status: 'error', message: err.message };\n      });\n  }\n\n  _influxRequest(method: string, url: string, data: any, options?: any) {\n    const currentUrl = this.urls.shift();\n    this.urls.push(currentUrl);\n\n    const params: any = {};\n\n    if (this.username) {\n      params.u = this.username;\n      params.p = this.password;\n    }\n\n    if (options && options.database) {\n      params.db = options.database;\n    } else if (this.database) {\n      params.db = this.database;\n    }\n\n    const { q } = data;\n\n    if (method === 'POST' && _.has(data, 'q')) {\n      // verb is POST and 'q' param is defined\n      _.extend(params, _.omit(data, ['q']));\n      data = this.serializeParams(_.pick(data, ['q']));\n    } else if (method === 'GET' || method === 'POST') {\n      // verb is GET, or POST without 'q' param\n      _.extend(params, data);\n      data = null;\n    }\n\n    const req: any = {\n      method: method,\n      url: currentUrl + url,\n      params: params,\n      data: data,\n      precision: 'ms',\n      inspect: { type: 'influxdb' },\n      paramSerializer: this.serializeParams,\n    };\n\n    req.headers = req.headers || {};\n    if (this.basicAuth || this.withCredentials) {\n      req.withCredentials = true;\n    }\n    if (this.basicAuth) {\n      req.headers.Authorization = this.basicAuth;\n    }\n\n    if (method === 'POST') {\n      req.headers['Content-type'] = 'application/x-www-form-urlencoded';\n    }\n\n    return getBackendSrv()\n      .datasourceRequest(req)\n      .then(\n        (result: any) => {\n          const { data } = result;\n          if (data) {\n            data.executedQueryString = q;\n            if (data.results) {\n              const errors = result.data.results.filter((elem: any) => elem.error);\n              if (errors.length > 0) {\n                throw {\n                  message: 'InfluxDB Error: ' + errors[0].error,\n                  data,\n                };\n              }\n            }\n          }\n          return data;\n        },\n        (err: any) => {\n          if ((Number.isInteger(err.status) && err.status !== 0) || err.status >= 300) {\n            if (err.data && err.data.error) {\n              throw {\n                message: 'InfluxDB Error: ' + err.data.error,\n                data: err.data,\n                config: err.config,\n              };\n            } else {\n              throw {\n                message: 'Network Error: ' + err.statusText + '(' + err.status + ')',\n                data: err.data,\n                config: err.config,\n              };\n            }\n          } else {\n            throw err;\n          }\n        }\n      );\n  }\n\n  getTimeFilter(options: any) {\n    const from = this.getInfluxTime(options.rangeRaw.from, false, options.timezone);\n    const until = this.getInfluxTime(options.rangeRaw.to, true, options.timezone);\n    const fromIsAbsolute = from[from.length - 1] === 'ms';\n\n    if (until === 'now()' && !fromIsAbsolute) {\n      return 'time >= ' + from;\n    }\n\n    return 'time >= ' + from + ' and time <= ' + until;\n  }\n\n  getInfluxTime(date: any, roundUp: any, timezone: any) {\n    if (_.isString(date)) {\n      if (date === 'now') {\n        return 'now()';\n      }\n\n      const parts = /^now-(\\d+)([dhms])$/.exec(date);\n      if (parts) {\n        const amount = parseInt(parts[1], 10);\n        const unit = parts[2];\n        return 'now() - ' + amount + unit;\n      }\n      date = dateMath.parse(date, roundUp, timezone);\n    }\n\n    return date.valueOf() + 'ms';\n  }\n}\n","import angular, { auto } from 'angular';\nimport _ from 'lodash';\nimport { InfluxQueryBuilder } from './query_builder';\nimport InfluxQueryModel from './influx_query_model';\nimport queryPart from './query_part';\nimport { QueryCtrl } from 'app/plugins/sdk';\nimport { TemplateSrv } from 'app/features/templating/template_srv';\nimport { InfluxQuery } from './types';\nimport InfluxDatasource from './datasource';\n\nexport class InfluxQueryCtrl extends QueryCtrl {\n  static templateUrl = 'partials/query.editor.html';\n\n  datasource: InfluxDatasource;\n  queryModel: InfluxQueryModel;\n  queryBuilder: any;\n  groupBySegment: any;\n  resultFormats: any[];\n  orderByTime: any[];\n  policySegment: any;\n  tagSegments: any[];\n  selectMenu: any;\n  measurementSegment: any;\n  removeTagFilterSegment: any;\n\n  /** @ngInject */\n  constructor(\n    $scope: any,\n    $injector: auto.IInjectorService,\n    private templateSrv: TemplateSrv,\n    private uiSegmentSrv: any\n  ) {\n    super($scope, $injector);\n    this.target = this.target;\n    this.queryModel = new InfluxQueryModel(this.target, templateSrv, this.panel.scopedVars);\n    this.queryBuilder = new InfluxQueryBuilder(this.target, this.datasource.database);\n    this.groupBySegment = this.uiSegmentSrv.newPlusButton();\n    this.resultFormats = [\n      { text: 'Time series', value: 'time_series' },\n      { text: 'Table', value: 'table' },\n      { text: 'Logs', value: 'logs' },\n    ];\n\n    this.policySegment = uiSegmentSrv.newSegment(this.target.policy);\n\n    if (!this.target.measurement) {\n      this.measurementSegment = uiSegmentSrv.newSelectMeasurement();\n    } else {\n      this.measurementSegment = uiSegmentSrv.newSegment(this.target.measurement);\n    }\n\n    this.tagSegments = [];\n    for (const tag of this.target.tags) {\n      if (!tag.operator) {\n        if (/^\\/.*\\/$/.test(tag.value)) {\n          tag.operator = '=~';\n        } else {\n          tag.operator = '=';\n        }\n      }\n\n      if (tag.condition) {\n        this.tagSegments.push(uiSegmentSrv.newCondition(tag.condition));\n      }\n\n      this.tagSegments.push(uiSegmentSrv.newKey(tag.key));\n      this.tagSegments.push(uiSegmentSrv.newOperator(tag.operator));\n      this.tagSegments.push(uiSegmentSrv.newKeyValue(tag.value));\n    }\n\n    this.fixTagSegments();\n    this.buildSelectMenu();\n    this.removeTagFilterSegment = uiSegmentSrv.newSegment({\n      fake: true,\n      value: '-- remove tag filter --',\n    });\n  }\n\n  /**\n   * Only called for flux\n   */\n  onChange = (target: InfluxQuery) => {\n    this.target.query = target.query;\n  };\n\n  onRunQuery = () => {\n    this.panelCtrl.refresh();\n  };\n\n  removeOrderByTime() {\n    this.target.orderByTime = 'ASC';\n  }\n\n  buildSelectMenu() {\n    const categories = queryPart.getCategories();\n    this.selectMenu = _.reduce(\n      categories,\n      (memo, cat, key) => {\n        const menu = {\n          text: key,\n          submenu: cat.map((item: any) => {\n            return { text: item.type, value: item.type };\n          }),\n        };\n        memo.push(menu);\n        return memo;\n      },\n      []\n    );\n  }\n\n  getGroupByOptions() {\n    const query = this.queryBuilder.buildExploreQuery('TAG_KEYS');\n\n    return this.datasource\n      .metricFindQuery(query)\n      .then((tags: any) => {\n        const options = [];\n        if (!this.queryModel.hasFill()) {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'fill(null)' }));\n        }\n        if (!this.target.limit) {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'LIMIT' }));\n        }\n        if (!this.target.slimit) {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'SLIMIT' }));\n        }\n        if (!this.target.tz) {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'tz' }));\n        }\n        if (this.target.orderByTime === 'ASC') {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'ORDER BY time DESC' }));\n        }\n        if (!this.queryModel.hasGroupByTime()) {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'time($interval)' }));\n        }\n        for (const tag of tags) {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'tag(' + tag.text + ')' }));\n        }\n        return options;\n      })\n      .catch(this.handleQueryError.bind(this));\n  }\n\n  groupByAction() {\n    switch (this.groupBySegment.value) {\n      case 'LIMIT': {\n        this.target.limit = 10;\n        break;\n      }\n      case 'SLIMIT': {\n        this.target.slimit = 10;\n        break;\n      }\n      case 'tz': {\n        this.target.tz = 'UTC';\n        break;\n      }\n      case 'ORDER BY time DESC': {\n        this.target.orderByTime = 'DESC';\n        break;\n      }\n      default: {\n        this.queryModel.addGroupBy(this.groupBySegment.value);\n      }\n    }\n\n    const plusButton = this.uiSegmentSrv.newPlusButton();\n    this.groupBySegment.value = plusButton.value;\n    this.groupBySegment.html = plusButton.html;\n    this.groupBySegment.fake = true;\n    this.panelCtrl.refresh();\n  }\n\n  addSelectPart(selectParts: any, cat: any, subitem: { value: any }) {\n    this.queryModel.addSelectPart(selectParts, subitem.value);\n    this.panelCtrl.refresh();\n  }\n\n  handleSelectPartEvent(selectParts: any, part: any, evt: { name: any }) {\n    switch (evt.name) {\n      case 'get-param-options': {\n        const fieldsQuery = this.queryBuilder.buildExploreQuery('FIELDS');\n        return this.datasource\n          .metricFindQuery(fieldsQuery)\n          .then(this.transformToSegments(true))\n          .catch(this.handleQueryError.bind(this));\n      }\n      case 'part-param-changed': {\n        this.panelCtrl.refresh();\n        break;\n      }\n      case 'action': {\n        this.queryModel.removeSelectPart(selectParts, part);\n        this.panelCtrl.refresh();\n        break;\n      }\n      case 'get-part-actions': {\n        return Promise.resolve([{ text: 'Remove', value: 'remove-part' }]);\n      }\n    }\n    return Promise.resolve();\n  }\n\n  handleGroupByPartEvent(part: any, index: any, evt: { name: any }) {\n    switch (evt.name) {\n      case 'get-param-options': {\n        const tagsQuery = this.queryBuilder.buildExploreQuery('TAG_KEYS');\n        return this.datasource\n          .metricFindQuery(tagsQuery)\n          .then(this.transformToSegments(true))\n          .catch(this.handleQueryError.bind(this));\n      }\n      case 'part-param-changed': {\n        this.panelCtrl.refresh();\n        break;\n      }\n      case 'action': {\n        this.queryModel.removeGroupByPart(part, index);\n        this.panelCtrl.refresh();\n        break;\n      }\n      case 'get-part-actions': {\n        return Promise.resolve([{ text: 'Remove', value: 'remove-part' }]);\n      }\n    }\n    return Promise.resolve();\n  }\n\n  fixTagSegments() {\n    const count = this.tagSegments.length;\n    const lastSegment = this.tagSegments[Math.max(count - 1, 0)];\n\n    if (!lastSegment || lastSegment.type !== 'plus-button') {\n      this.tagSegments.push(this.uiSegmentSrv.newPlusButton());\n    }\n  }\n\n  measurementChanged() {\n    this.target.measurement = this.measurementSegment.value;\n    this.panelCtrl.refresh();\n  }\n\n  getPolicySegments() {\n    const policiesQuery = this.queryBuilder.buildExploreQuery('RETENTION POLICIES');\n    return this.datasource\n      .metricFindQuery(policiesQuery)\n      .then(this.transformToSegments(false))\n      .catch(this.handleQueryError.bind(this));\n  }\n\n  policyChanged() {\n    this.target.policy = this.policySegment.value;\n    this.panelCtrl.refresh();\n  }\n\n  // Only valid for InfluxQL queries\n  toggleEditorMode() {\n    if (this.datasource.is2x) {\n      return; // nothing\n    }\n\n    try {\n      this.target.query = this.queryModel.render(false);\n    } catch (err) {\n      console.log('query render error');\n    }\n    this.target.rawQuery = !this.target.rawQuery;\n  }\n\n  getMeasurements(measurementFilter: any) {\n    const query = this.queryBuilder.buildExploreQuery('MEASUREMENTS', undefined, measurementFilter);\n    return this.datasource\n      .metricFindQuery(query)\n      .then(this.transformToSegments(true))\n      .catch(this.handleQueryError.bind(this));\n  }\n\n  handleQueryError(err: any): any[] {\n    this.error = err.message || 'Failed to issue metric query';\n    return [];\n  }\n\n  transformToSegments(addTemplateVars: any) {\n    return (results: any) => {\n      const segments = _.map(results, segment => {\n        return this.uiSegmentSrv.newSegment({\n          value: segment.text,\n          expandable: segment.expandable,\n        });\n      });\n\n      if (addTemplateVars) {\n        for (const variable of this.templateSrv.getVariables()) {\n          segments.unshift(\n            this.uiSegmentSrv.newSegment({\n              type: 'value',\n              value: '/^$' + variable.name + '$/',\n              expandable: true,\n            })\n          );\n        }\n      }\n\n      return segments;\n    };\n  }\n\n  getTagsOrValues(segment: { type: string }, index: number) {\n    if (segment.type === 'condition') {\n      return Promise.resolve([this.uiSegmentSrv.newSegment('AND'), this.uiSegmentSrv.newSegment('OR')]);\n    }\n\n    if (segment.type === 'operator') {\n      const nextValue = this.tagSegments[index + 1].value;\n      if (/^\\/.*\\/$/.test(nextValue)) {\n        return Promise.resolve(this.uiSegmentSrv.newOperators(['=~', '!~']));\n      } else {\n        return Promise.resolve(this.uiSegmentSrv.newOperators(['=', '!=', '<>', '<', '>']));\n      }\n    }\n\n    let query, addTemplateVars;\n    if (segment.type === 'key' || segment.type === 'plus-button') {\n      query = this.queryBuilder.buildExploreQuery('TAG_KEYS');\n      addTemplateVars = false;\n    } else if (segment.type === 'value') {\n      query = this.queryBuilder.buildExploreQuery('TAG_VALUES', this.tagSegments[index - 2].value);\n      addTemplateVars = true;\n    }\n\n    return this.datasource\n      .metricFindQuery(query)\n      .then(this.transformToSegments(addTemplateVars))\n      .then((results: any) => {\n        if (segment.type === 'key') {\n          results.splice(0, 0, angular.copy(this.removeTagFilterSegment));\n        }\n        return results;\n      })\n      .catch(this.handleQueryError.bind(this));\n  }\n\n  getFieldSegments() {\n    const fieldsQuery = this.queryBuilder.buildExploreQuery('FIELDS');\n    return this.datasource\n      .metricFindQuery(fieldsQuery)\n      .then(this.transformToSegments(false))\n      .catch(this.handleQueryError);\n  }\n\n  tagSegmentUpdated(segment: { value: any; type: string; cssClass: string }, index: number) {\n    this.tagSegments[index] = segment;\n\n    // handle remove tag condition\n    if (segment.value === this.removeTagFilterSegment.value) {\n      this.tagSegments.splice(index, 3);\n      if (this.tagSegments.length === 0) {\n        this.tagSegments.push(this.uiSegmentSrv.newPlusButton());\n      } else if (this.tagSegments.length > 2) {\n        this.tagSegments.splice(Math.max(index - 1, 0), 1);\n        if (this.tagSegments[this.tagSegments.length - 1].type !== 'plus-button') {\n          this.tagSegments.push(this.uiSegmentSrv.newPlusButton());\n        }\n      }\n    } else {\n      if (segment.type === 'plus-button') {\n        if (index > 2) {\n          this.tagSegments.splice(index, 0, this.uiSegmentSrv.newCondition('AND'));\n        }\n        this.tagSegments.push(this.uiSegmentSrv.newOperator('='));\n        this.tagSegments.push(this.uiSegmentSrv.newFake('select tag value', 'value', 'query-segment-value'));\n        segment.type = 'key';\n        segment.cssClass = 'query-segment-key';\n      }\n\n      if (index + 1 === this.tagSegments.length) {\n        this.tagSegments.push(this.uiSegmentSrv.newPlusButton());\n      }\n    }\n\n    this.rebuildTargetTagConditions();\n  }\n\n  rebuildTargetTagConditions() {\n    const tags: any[] = [];\n    let tagIndex = 0;\n    let tagOperator = '';\n\n    _.each(this.tagSegments, (segment2, index) => {\n      if (segment2.type === 'key') {\n        if (tags.length === 0) {\n          tags.push({});\n        }\n        tags[tagIndex].key = segment2.value;\n      } else if (segment2.type === 'value') {\n        tagOperator = this.getTagValueOperator(segment2.value, tags[tagIndex].operator);\n        if (tagOperator) {\n          this.tagSegments[index - 1] = this.uiSegmentSrv.newOperator(tagOperator);\n          tags[tagIndex].operator = tagOperator;\n        }\n        tags[tagIndex].value = segment2.value;\n      } else if (segment2.type === 'condition') {\n        tags.push({ condition: segment2.value });\n        tagIndex += 1;\n      } else if (segment2.type === 'operator') {\n        tags[tagIndex].operator = segment2.value;\n      }\n    });\n\n    this.target.tags = tags;\n    this.panelCtrl.refresh();\n  }\n\n  getTagValueOperator(tagValue: string, tagOperator: string): string {\n    if (tagOperator !== '=~' && tagOperator !== '!~' && /^\\/.*\\/$/.test(tagValue)) {\n      return '=~';\n    } else if ((tagOperator === '=~' || tagOperator === '!~') && /^(?!\\/.*\\/$)/.test(tagValue)) {\n      return '=';\n    }\n    return null;\n  }\n}\n","import React from 'react';\n\nconst CHEAT_SHEET_ITEMS = [\n  {\n    title: 'Getting started',\n    label:\n      'Start by selecting a measurement and field from the dropdown above. You can then use the tag selector to further narrow your search.',\n  },\n];\n\nexport default (props: any) => (\n  <div>\n    <h2>InfluxDB Cheat Sheet</h2>\n    {CHEAT_SHEET_ITEMS.map(item => (\n      <div className=\"cheat-sheet-item\" key={item.title}>\n        <div className=\"cheat-sheet-item__title\">{item.title}</div>\n        <div className=\"cheat-sheet-item__label\">{item.label}</div>\n      </div>\n    ))}\n  </div>\n);\n","import React, { PureComponent } from 'react';\nimport { ExploreStartPageProps } from '@grafana/data';\nimport InfluxCheatSheet from './InfluxCheatSheet';\n\nexport default class InfluxStartPage extends PureComponent<ExploreStartPageProps> {\n  render() {\n    return <InfluxCheatSheet onClickExample={this.props.onClickExample} />;\n  }\n}\n","import React, { PureComponent } from 'react';\nimport {\n  DataSourcePluginOptionsEditorProps,\n  SelectableValue,\n  onUpdateDatasourceOption,\n  updateDatasourcePluginResetOption,\n  onUpdateDatasourceJsonDataOption,\n  onUpdateDatasourceJsonDataOptionSelect,\n  onUpdateDatasourceSecureJsonDataOption,\n} from '@grafana/data';\nimport { DataSourceHttpSettings, InlineFormLabel, LegacyForms } from '@grafana/ui';\nconst { Select, Input, SecretFormField } = LegacyForms;\nimport { InfluxOptions, InfluxSecureJsonData, InfluxVersion } from '../types';\n\nconst httpModes = [\n  { label: 'GET', value: 'GET' },\n  { label: 'POST', value: 'POST' },\n] as SelectableValue[];\n\nconst versions = [\n  {\n    label: 'InfluxQL',\n    value: InfluxVersion.InfluxQL,\n    description: 'The InfluxDB SQL-like query language.  Supported in InfluxDB 1.x',\n  },\n  {\n    label: 'Flux',\n    value: InfluxVersion.Flux,\n    description: 'Advanced data scripting and query language.  Supported in InfluxDB 2.x and 1.8+ (beta)',\n  },\n] as Array<SelectableValue<InfluxVersion>>;\n\nexport type Props = DataSourcePluginOptionsEditorProps<InfluxOptions>;\n\nexport class ConfigEditor extends PureComponent<Props> {\n  // 1x\n  onResetPassword = () => {\n    updateDatasourcePluginResetOption(this.props, 'password');\n  };\n\n  // 2x\n  onResetToken = () => {\n    updateDatasourcePluginResetOption(this.props, 'token');\n  };\n\n  onVersionChanged = (selected: SelectableValue<InfluxVersion>) => {\n    const { options, onOptionsChange } = this.props;\n\n    const copy = {\n      ...options,\n      jsonData: {\n        ...options.jsonData,\n        version: selected.value,\n      },\n    };\n    if (selected.value === InfluxVersion.Flux) {\n      copy.access = 'proxy';\n      copy.basicAuth = true;\n      copy.jsonData.httpMode = 'POST';\n\n      // Remove old 1x configs\n      delete copy.user;\n      delete copy.database;\n    }\n    onOptionsChange(copy);\n  };\n\n  onUpdateInflux2xURL = (e: React.SyntheticEvent<HTMLInputElement>) => {\n    const { options, onOptionsChange } = this.props;\n    onOptionsChange({\n      ...options,\n      url: e.currentTarget.value,\n      access: 'proxy',\n      basicAuth: true,\n    });\n  };\n\n  renderInflux2x() {\n    const { options } = this.props;\n    const { secureJsonFields } = options;\n    const secureJsonData = (options.secureJsonData || {}) as InfluxSecureJsonData;\n\n    return (\n      <div>\n        <div className=\"gf-form-group\">\n          <div className=\"width-30 grafana-info-box\">\n            <h5>Support for flux in Grafana is currently in beta</h5>\n            <p>\n              Please report any issues to: <br />\n              <a href=\"https://github.com/grafana/grafana/issues/new/choose\">\n                https://github.com/grafana/grafana/issues\n              </a>\n            </p>\n          </div>\n        </div>\n        <br />\n\n        <h3 className=\"page-heading\">Connection</h3>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <InlineFormLabel\n              className=\"width-10\"\n              tooltip=\"This URL needs to be accessible from the grafana backend/server.\"\n            >\n              URL\n            </InlineFormLabel>\n            <div className=\"width-20\">\n              <Input\n                className=\"width-20\"\n                value={options.url || ''}\n                placeholder=\"http://localhost:9999/api/v2\"\n                onChange={this.onUpdateInflux2xURL}\n              />\n            </div>\n          </div>\n        </div>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <InlineFormLabel className=\"width-10\">Organization</InlineFormLabel>\n            <div className=\"width-10\">\n              <Input\n                className=\"width-20\"\n                value={options.jsonData.organization || ''}\n                onChange={onUpdateDatasourceJsonDataOption(this.props, 'organization')}\n              />\n            </div>\n          </div>\n        </div>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <SecretFormField\n              isConfigured={(secureJsonFields && secureJsonFields.token) as boolean}\n              value={secureJsonData.token || ''}\n              label=\"Token\"\n              labelWidth={10}\n              inputWidth={20}\n              onReset={this.onResetToken}\n              onChange={onUpdateDatasourceSecureJsonDataOption(this.props, 'token')}\n            />\n          </div>\n        </div>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <InlineFormLabel className=\"width-10\">Default Bucket</InlineFormLabel>\n            <div className=\"width-10\">\n              <Input\n                className=\"width-20\"\n                placeholder=\"default bucket\"\n                value={options.jsonData.defaultBucket || ''}\n                onChange={onUpdateDatasourceJsonDataOption(this.props, 'defaultBucket')}\n              />\n            </div>\n          </div>\n        </div>\n\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <InlineFormLabel\n              className=\"width-10\"\n              tooltip=\"A lower limit for the auto group by time interval. Recommended to be set to write frequency,\n\t\t\t\tfor example 1m if your data is written every minute.\"\n            >\n              Min time interval\n            </InlineFormLabel>\n            <div className=\"width-10\">\n              <Input\n                className=\"width-10\"\n                placeholder=\"10s\"\n                value={options.jsonData.timeInterval || ''}\n                onChange={onUpdateDatasourceJsonDataOption(this.props, 'timeInterval')}\n              />\n            </div>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  renderInflux1x() {\n    const { options, onOptionsChange } = this.props;\n    const { secureJsonFields } = options;\n    const secureJsonData = (options.secureJsonData || {}) as InfluxSecureJsonData;\n\n    return (\n      <div>\n        <DataSourceHttpSettings\n          showAccessOptions={true}\n          dataSourceConfig={options}\n          defaultUrl=\"http://localhost:8086\"\n          onChange={onOptionsChange}\n        />\n\n        <h3 className=\"page-heading\">InfluxDB Details</h3>\n        <div className=\"gf-form-group\">\n          <div className=\"gf-form-inline\">\n            <div className=\"gf-form\">\n              <InlineFormLabel className=\"width-10\">Database</InlineFormLabel>\n              <div className=\"width-20\">\n                <Input\n                  className=\"width-20\"\n                  value={options.database || ''}\n                  onChange={onUpdateDatasourceOption(this.props, 'database')}\n                />\n              </div>\n            </div>\n          </div>\n          <div className=\"gf-form-inline\">\n            <div className=\"gf-form\">\n              <InlineFormLabel className=\"width-10\">User</InlineFormLabel>\n              <div className=\"width-10\">\n                <Input\n                  className=\"width-20\"\n                  value={options.user || ''}\n                  onChange={onUpdateDatasourceOption(this.props, 'user')}\n                />\n              </div>\n            </div>\n          </div>\n          <div className=\"gf-form-inline\">\n            <div className=\"gf-form\">\n              <SecretFormField\n                isConfigured={(secureJsonFields && secureJsonFields.password) as boolean}\n                value={secureJsonData.password || ''}\n                label=\"Password\"\n                labelWidth={10}\n                inputWidth={20}\n                onReset={this.onResetPassword}\n                onChange={onUpdateDatasourceSecureJsonDataOption(this.props, 'password')}\n              />\n            </div>\n          </div>\n          <div className=\"gf-form-inline\">\n            <div className=\"gf-form\">\n              <InlineFormLabel\n                className=\"width-10\"\n                tooltip=\"You can use either GET or POST HTTP method to query your InfluxDB database. The POST\n          method allows you to perform heavy requests (with a lots of WHERE clause) while the GET method\n          will restrict you and return an error if the query is too large.\"\n              >\n                HTTP Method\n              </InlineFormLabel>\n              <Select\n                className=\"width-10\"\n                value={httpModes.find(httpMode => httpMode.value === options.jsonData.httpMode)}\n                options={httpModes}\n                defaultValue={options.jsonData.httpMode}\n                onChange={onUpdateDatasourceJsonDataOptionSelect(this.props, 'httpMode')}\n              />\n            </div>\n          </div>\n        </div>\n\n        <div className=\"gf-form-group\">\n          <div className=\"grafana-info-box\">\n            <h5>Database Access</h5>\n            <p>\n              Setting the database for this datasource does not deny access to other databases. The InfluxDB query\n              syntax allows switching the database in the query. For example:\n              <code>SHOW MEASUREMENTS ON _internal</code> or <code>SELECT * FROM \"_internal\"..\"database\" LIMIT 10</code>\n              <br />\n              <br />\n              To support data isolation and security, make sure appropriate permissions are configured in InfluxDB.\n            </p>\n          </div>\n        </div>\n        <div className=\"gf-form-group\">\n          <div className=\"gf-form-inline\">\n            <div className=\"gf-form\">\n              <InlineFormLabel\n                className=\"width-10\"\n                tooltip=\"A lower limit for the auto group by time interval. Recommended to be set to write frequency,\n\t\t\t\tfor example 1m if your data is written every minute.\"\n              >\n                Min time interval\n              </InlineFormLabel>\n              <div className=\"width-10\">\n                <Input\n                  className=\"width-10\"\n                  placeholder=\"10s\"\n                  value={options.jsonData.timeInterval || ''}\n                  onChange={onUpdateDatasourceJsonDataOption(this.props, 'timeInterval')}\n                />\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  render() {\n    const { options } = this.props;\n\n    return (\n      <>\n        <h3 className=\"page-heading\">Query Language</h3>\n        <div className=\"gf-form-group\">\n          <div className=\"gf-form-inline\">\n            <div className=\"gf-form\">\n              <Select\n                className=\"width-30\"\n                value={options.jsonData.version === InfluxVersion.Flux ? versions[1] : versions[0]}\n                options={versions}\n                defaultValue={versions[0]}\n                onChange={this.onVersionChanged}\n              />\n            </div>\n          </div>\n        </div>\n\n        {options.jsonData.version === InfluxVersion.Flux ? this.renderInflux2x() : this.renderInflux1x()}\n      </>\n    );\n  }\n}\n\nexport default ConfigEditor;\n","import React, { PureComponent } from 'react';\nimport coreModule from 'app/core/core_module';\nimport { InfluxQuery } from '../types';\nimport { SelectableValue } from '@grafana/data';\nimport { cx, css } from 'emotion';\nimport {\n  InlineFormLabel,\n  LinkButton,\n  Segment,\n  CodeEditor,\n  CodeEditorSuggestionItem,\n  CodeEditorSuggestionItemKind,\n} from '@grafana/ui';\nimport { getTemplateSrv } from '@grafana/runtime';\n\ninterface Props {\n  target: InfluxQuery;\n  change: (target: InfluxQuery) => void;\n  refresh: () => void;\n}\n\nconst samples: Array<SelectableValue<string>> = [\n  { label: 'Show buckets', description: 'List the avaliable buckets (table)', value: 'buckets()' },\n  {\n    label: 'Simple query',\n    description: 'filter by measurment and field',\n    value: `from(bucket: \"db/rp\")\n  |> range(start: v.timeRangeStart, stop:v.timeRangeStop)\n  |> filter(fn: (r) =>\n    r._measurement == \"example-measurement\" and\n    r._field == \"example-field\"\n  )`,\n  },\n  {\n    label: 'Grouped Query',\n    description: 'Group by (min/max/sum/median)',\n    value: `// v.windowPeriod is a variable referring to the current optimized window period (currently: $interval)\nfrom(bucket: v.bucket)\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"measurement1\" or r[\"_measurement\"] =~ /^.*?regex.*$/)\n  |> filter(fn: (r) => r[\"_field\"] == \"field2\" or r[\"_field\"] =~ /^.*?regex.*$/)\n  |> aggregateWindow(every: v.windowPeriod, fn: mean|median|max|count|derivative|sum)\n  |> yield(name: \"some-name\")`,\n  },\n  {\n    label: 'Filter by value',\n    description: 'Results between a min/max',\n    value: `// v.bucket, v.timeRangeStart, and v.timeRange stop are all variables supported by the flux plugin and influxdb\nfrom(bucket: v.bucket)\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_value\"] >= 10 and r[\"_value\"] <= 20)`,\n  },\n  {\n    label: 'Schema Exploration: (measurements)',\n    description: 'Get a list of measurement using flux',\n    value: `import \"influxdata/influxdb/v1\"\nv1.measurements(bucket: v.bucket)`,\n  },\n  {\n    label: 'Schema Exploration: (fields)',\n    description: 'Return every possible key in a single table',\n    value: `from(bucket: v.bucket)\n  |> range(start: v.timeRangeStart, stop:timeRangeStop)\n  |> keys()\n  |> keep(columns: [\"_value\"])\n  |> group()\n  |> distinct()`,\n  },\n  {\n    label: 'Schema Exploration: (tag keys)',\n    description: 'Get a list of tag keys using flux',\n    value: `import \"influxdata/influxdb/v1\"\nv1.tagKeys(bucket: v.bucket)`,\n  },\n  {\n    label: 'Schema Exploration: (tag values)',\n    description: 'Get a list of tag values using flux',\n    value: `import \"influxdata/influxdb/v1\"\nv1.tagValues(\n    bucket: v.bucket,\n    tag: \"host\",\n    predicate: (r) => true,\n    start: -1d\n)`,\n  },\n];\n\nexport class FluxQueryEditor extends PureComponent<Props> {\n  onFluxQueryChange = (query: string) => {\n    const { target, change } = this.props;\n    change({ ...target, query });\n    this.props.refresh();\n  };\n\n  onSampleChange = (val: SelectableValue<string>) => {\n    this.props.change({\n      ...this.props.target,\n      query: val.value!,\n    });\n\n    // Angular HACK: Since the target does not actually change!\n    this.forceUpdate();\n    this.props.refresh();\n  };\n\n  getSuggestions = (): CodeEditorSuggestionItem[] => {\n    const sugs: CodeEditorSuggestionItem[] = [\n      {\n        label: 'v.timeRangeStart',\n        kind: CodeEditorSuggestionItemKind.Property,\n        detail: 'The start time',\n      },\n      {\n        label: 'v.timeRangeStop',\n        kind: CodeEditorSuggestionItemKind.Property,\n        detail: 'The stop time',\n      },\n      {\n        label: 'v.windowPeriod',\n        kind: CodeEditorSuggestionItemKind.Property,\n        detail: 'based on max data points',\n      },\n      {\n        label: 'v.defaultBucket',\n        kind: CodeEditorSuggestionItemKind.Property,\n        detail: 'bucket configured in the datsource',\n      },\n      {\n        label: 'v.organization',\n        kind: CodeEditorSuggestionItemKind.Property,\n        detail: 'org configured for the datsource',\n      },\n    ];\n\n    const templateSrv = getTemplateSrv();\n    templateSrv.getVariables().forEach(variable => {\n      const label = '${' + variable.name + '}';\n      let val = templateSrv.replace(label);\n      if (val === label) {\n        val = '';\n      }\n      sugs.push({\n        label,\n        kind: CodeEditorSuggestionItemKind.Text,\n        detail: `(Template Variable) ${val}`,\n      });\n    });\n\n    return sugs;\n  };\n\n  // For some reason in angular, when this component gets re-mounted, the width\n  // is not set properly.  This forces the layout shorly after mount so that it\n  // displays OK.  Note: this is not an issue when used directly in react\n  editorDidMountCallbackHack = (editor: any) => {\n    setTimeout(() => editor.layout(), 100);\n  };\n\n  render() {\n    const { target } = this.props;\n\n    const helpTooltip = (\n      <div>\n        Type: <i>ctrl+space</i> to show template variable suggestions <br />\n        Many queries can be copied from chronograph\n      </div>\n    );\n\n    return (\n      <>\n        <CodeEditor\n          height={'200px'}\n          language=\"sql\"\n          value={target.query || ''}\n          onBlur={this.onFluxQueryChange}\n          onSave={this.onFluxQueryChange}\n          showMiniMap={false}\n          showLineNumbers={true}\n          getSuggestions={this.getSuggestions}\n          onEditorDidMount={this.editorDidMountCallbackHack}\n        />\n        <div\n          className={cx(\n            'gf-form-inline',\n            css`\n              margin-top: 6px;\n            `\n          )}\n        >\n          <LinkButton\n            icon=\"external-link-alt\"\n            variant=\"secondary\"\n            target=\"blank\"\n            href=\"https://docs.influxdata.com/flux/latest/introduction/getting-started/\"\n          >\n            Flux language syntax\n          </LinkButton>\n          <Segment options={samples} value=\"Sample Query\" onChange={this.onSampleChange} />\n          <div className=\"gf-form gf-form--grow\">\n            <div className=\"gf-form-label gf-form-label--grow\"></div>\n          </div>\n          <InlineFormLabel width={5} tooltip={helpTooltip}>\n            Help\n          </InlineFormLabel>\n        </div>\n      </>\n    );\n  }\n}\n\ncoreModule.directive('fluxQueryEditor', [\n  'reactDirective',\n  (reactDirective: any) => {\n    return reactDirective(FluxQueryEditor, ['target', 'change', 'refresh']);\n  },\n]);\n","import InfluxDatasource from './datasource';\nimport { InfluxQueryCtrl } from './query_ctrl';\nimport InfluxStartPage from './components/InfluxStartPage';\nimport { DataSourcePlugin } from '@grafana/data';\nimport ConfigEditor from './components/ConfigEditor';\n\n// This adds a directive that is used in the query editor\nimport './components/FluxQueryEditor';\n\nclass InfluxAnnotationsQueryCtrl {\n  static templateUrl = 'partials/annotations.editor.html';\n}\n\nexport const plugin = new DataSourcePlugin(InfluxDatasource)\n  .setConfigEditor(ConfigEditor)\n  .setQueryCtrl(InfluxQueryCtrl)\n  .setAnnotationQueryCtrl(InfluxAnnotationsQueryCtrl)\n  .setExploreStartPage(InfluxStartPage);\n"],"sourceRoot":""}