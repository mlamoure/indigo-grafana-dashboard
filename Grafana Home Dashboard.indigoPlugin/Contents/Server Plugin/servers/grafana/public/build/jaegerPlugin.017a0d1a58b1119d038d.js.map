{"version":3,"sources":["webpack:///./public/app/plugins/datasource/jaeger/datasource.ts","webpack:///./public/app/plugins/datasource/jaeger/QueryField.tsx","webpack:///./public/app/plugins/datasource/jaeger/module.ts","webpack:///./public/app/plugins/datasource/jaeger/ConfigEditor.tsx"],"names":["JaegerDatasource","instanceSettings","url","params","this","_request","silent","toPromise","res","data","options","id","targets","query","pipe","map","response","MutableDataFrame","fields","name","type","FieldType","trace","values","of","range","getTimeSrv","timeRange","start","getTime","from","end","to","apiUrl","baseUrl","serializeParams","req","length","getBackendSrv","datasourceRequest","DataSourceApi","date","roundUp","dateMath","parse","valueOf","getLabelFromTrace","rootSpan","spans","find","s","references","operationName","duration","traceID","JaegerQueryField","props","context","onLoadOptions","selectedOptions","service","value","findOperations","operations","_isMounted","operationOptions","label","sort","operation","isLeaf","setState","state","serviceOptions","serviceOption","children","operationValue","findTraces","traces","traceOptions","operationOption","datasource","metadataRequest","appEvents","emit","AppEvents","alertError","getTimeRange","traceSearch","limit","lookback","maxDuration","minDuration","onSelectTrace","onChange","onRunQuery","getServices","services","cascaderOptions","noTracesFoundOptions","className","loadData","style","width","e","currentTarget","React","PureComponent","plugin","DataSourcePlugin","setConfigEditor","onOptionsChange","defaultUrl","dataSourceConfig","showAccessOptions","setExploreQueryField"],"mappings":"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","file":"jaegerPlugin.017a0d1a58b1119d038d.js","sourcesContent":["import {\n  dateMath,\n  DateTime,\n  MutableDataFrame,\n  DataSourceApi,\n  DataSourceInstanceSettings,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataQuery,\n  FieldType,\n} from '@grafana/data';\nimport { getBackendSrv } from '@grafana/runtime';\nimport { Observable, from, of } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nimport { getTimeSrv } from 'app/features/dashboard/services/TimeSrv';\nimport { DatasourceRequestOptions } from 'app/core/services/backend_srv';\nimport { serializeParams } from 'app/core/utils/fetch';\n\nexport type JaegerQuery = {\n  query: string;\n} & DataQuery;\n\nexport class JaegerDatasource extends DataSourceApi<JaegerQuery> {\n  constructor(private instanceSettings: DataSourceInstanceSettings) {\n    super(instanceSettings);\n  }\n\n  async metadataRequest(url: string, params?: Record<string, any>): Promise<any> {\n    const res = await this._request(url, params, { silent: true }).toPromise();\n    return res.data.data;\n  }\n\n  query(options: DataQueryRequest<JaegerQuery>): Observable<DataQueryResponse> {\n    // At this moment we expect only one target. In case we somehow change the UI to be able to show multiple\n    // traces at one we need to change this.\n    const id = options.targets[0]?.query;\n    if (id) {\n      // TODO: this api is internal, used in jaeger ui. Officially they have gRPC api that should be used.\n      return this._request(`/api/traces/${id}`).pipe(\n        map(response => {\n          return {\n            data: [\n              new MutableDataFrame({\n                fields: [\n                  {\n                    name: 'trace',\n                    type: FieldType.trace,\n                    values: response?.data?.data || [],\n                  },\n                ],\n              }),\n            ],\n          };\n        })\n      );\n    } else {\n      return of({\n        data: [\n          new MutableDataFrame({\n            fields: [\n              {\n                name: 'trace',\n                type: FieldType.trace,\n                values: [],\n              },\n            ],\n          }),\n        ],\n      });\n    }\n  }\n\n  async testDatasource(): Promise<any> {\n    return true;\n  }\n\n  getTimeRange(): { start: number; end: number } {\n    const range = getTimeSrv().timeRange();\n    return {\n      start: getTime(range.from, false),\n      end: getTime(range.to, true),\n    };\n  }\n\n  getQueryDisplayText(query: JaegerQuery) {\n    return query.query;\n  }\n\n  private _request(apiUrl: string, data?: any, options?: DatasourceRequestOptions): Observable<Record<string, any>> {\n    // Hack for proxying metadata requests\n    const baseUrl = `/api/datasources/proxy/${this.instanceSettings.id}`;\n    const params = data ? serializeParams(data) : '';\n    const url = `${baseUrl}${apiUrl}${params.length ? `?${params}` : ''}`;\n    const req = {\n      ...options,\n      url,\n    };\n\n    return from(getBackendSrv().datasourceRequest(req));\n  }\n}\n\nfunction getTime(date: string | DateTime, roundUp: boolean) {\n  if (typeof date === 'string') {\n    date = dateMath.parse(date, roundUp);\n  }\n  return date.valueOf() * 1000;\n}\n","import React from 'react';\nimport { JaegerDatasource, JaegerQuery } from './datasource';\nimport { ButtonCascader, CascaderOption } from '@grafana/ui';\n\nimport { AppEvents, ExploreQueryFieldProps } from '@grafana/data';\nimport { appEvents } from '../../../core/core';\nimport { Span, TraceData } from '@jaegertracing/jaeger-ui-components';\n\nconst ALL_OPERATIONS_KEY = '__ALL__';\nconst NO_TRACES_KEY = '__NO_TRACES__';\n\ntype Props = ExploreQueryFieldProps<JaegerDatasource, JaegerQuery>;\ninterface State {\n  serviceOptions: CascaderOption[];\n}\n\nfunction findRootSpan(spans: Span[]): Span | undefined {\n  return spans.find(s => !s.references?.length);\n}\n\nfunction getLabelFromTrace(trace: TraceData & { spans: Span[] }): string {\n  const rootSpan = findRootSpan(trace.spans);\n  if (rootSpan) {\n    return `${rootSpan.operationName} [${rootSpan.duration / 1000} ms]`;\n  }\n  return trace.traceID;\n}\n\nexport class JaegerQueryField extends React.PureComponent<Props, State> {\n  private _isMounted: boolean;\n\n  constructor(props: Props, context: React.Context<any>) {\n    super(props, context);\n    this.state = {\n      serviceOptions: [],\n    };\n  }\n\n  componentDidMount() {\n    this._isMounted = true;\n    // We should probably call this periodically to get new services after mount.\n    this.getServices();\n  }\n\n  componentWillUnmount(): void {\n    this._isMounted = false;\n  }\n\n  async getServices() {\n    const url = '/api/services';\n    const { datasource } = this.props;\n    try {\n      const services: string[] | null = await datasource.metadataRequest(url);\n      if (!this._isMounted) {\n        return;\n      }\n\n      if (services) {\n        const serviceOptions: CascaderOption[] = services.sort().map(service => ({\n          label: service,\n          value: service,\n          isLeaf: false,\n        }));\n        this.setState({ serviceOptions });\n      }\n    } catch (error) {\n      appEvents.emit(AppEvents.alertError, ['Failed to load services from Jaeger', error]);\n    }\n  }\n\n  onLoadOptions = async (selectedOptions: CascaderOption[]) => {\n    const service = selectedOptions[0].value;\n    if (selectedOptions.length === 1) {\n      // Load operations\n      const operations: string[] = await this.findOperations(service);\n      if (!this._isMounted) {\n        return;\n      }\n\n      const allOperationsOption: CascaderOption = {\n        label: '[ALL]',\n        value: ALL_OPERATIONS_KEY,\n      };\n      const operationOptions: CascaderOption[] = [\n        allOperationsOption,\n        ...operations.sort().map(operation => ({\n          label: operation,\n          value: operation,\n          isLeaf: false,\n        })),\n      ];\n      this.setState(state => {\n        const serviceOptions = state.serviceOptions.map(serviceOption => {\n          if (serviceOption.value === service) {\n            return {\n              ...serviceOption,\n              children: operationOptions,\n            };\n          }\n          return serviceOption;\n        });\n        return { serviceOptions };\n      });\n    } else if (selectedOptions.length === 2) {\n      // Load traces\n      const operationValue = selectedOptions[1].value;\n      const operation = operationValue === ALL_OPERATIONS_KEY ? '' : operationValue;\n      const traces: any[] = await this.findTraces(service, operation);\n      if (!this._isMounted) {\n        return;\n      }\n\n      let traceOptions: CascaderOption[] = traces.map(trace => ({\n        label: getLabelFromTrace(trace),\n        value: trace.traceID,\n      }));\n      if (traceOptions.length === 0) {\n        traceOptions = [\n          {\n            label: '[No traces in time range]',\n            value: NO_TRACES_KEY,\n          },\n        ];\n      }\n      this.setState(state => {\n        // Place new traces into the correct service/operation sub-tree\n        const serviceOptions = state.serviceOptions.map(serviceOption => {\n          if (serviceOption.value === service) {\n            const operationOptions = serviceOption.children.map(operationOption => {\n              if (operationOption.value === operationValue) {\n                return {\n                  ...operationOption,\n                  children: traceOptions,\n                };\n              }\n              return operationOption;\n            });\n            return {\n              ...serviceOption,\n              children: operationOptions,\n            };\n          }\n          return serviceOption;\n        });\n        return { serviceOptions };\n      });\n    }\n  };\n\n  findOperations = async (service: string) => {\n    const { datasource } = this.props;\n    const url = `/api/services/${service}/operations`;\n    try {\n      return await datasource.metadataRequest(url);\n    } catch (error) {\n      appEvents.emit(AppEvents.alertError, ['Failed to load operations from Jaeger', error]);\n    }\n    return [];\n  };\n\n  findTraces = async (service: string, operation?: string) => {\n    const { datasource } = this.props;\n    const { start, end } = datasource.getTimeRange();\n\n    const traceSearch = {\n      start,\n      end,\n      service,\n      operation,\n      limit: 10,\n      lookback: '1h',\n      maxDuration: '',\n      minDuration: '',\n    };\n    const url = '/api/traces';\n    try {\n      return await datasource.metadataRequest(url, traceSearch);\n    } catch (error) {\n      appEvents.emit(AppEvents.alertError, ['Failed to load traces from Jaeger', error]);\n    }\n    return [];\n  };\n\n  onSelectTrace = (values: string[], selectedOptions: CascaderOption[]) => {\n    const { query, onChange, onRunQuery } = this.props;\n    if (selectedOptions.length === 3) {\n      const traceID = selectedOptions[2].value;\n      onChange({ ...query, query: traceID });\n      onRunQuery();\n    }\n  };\n\n  render() {\n    const { query, onChange } = this.props;\n    const { serviceOptions } = this.state;\n    const cascaderOptions = serviceOptions && serviceOptions.length ? serviceOptions : noTracesFoundOptions;\n\n    return (\n      <>\n        <div className=\"gf-form-inline gf-form-inline--nowrap\">\n          <div className=\"gf-form flex-shrink-0\">\n            <ButtonCascader options={cascaderOptions} onChange={this.onSelectTrace} loadData={this.onLoadOptions}>\n              Traces\n            </ButtonCascader>\n          </div>\n          <div className=\"gf-form gf-form--grow flex-shrink-1\">\n            <div className={'slate-query-field__wrapper'}>\n              <div className=\"slate-query-field\">\n                <input\n                  style={{ width: '100%' }}\n                  value={query.query || ''}\n                  onChange={e =>\n                    onChange({\n                      ...query,\n                      query: e.currentTarget.value,\n                    })\n                  }\n                />\n              </div>\n            </div>\n          </div>\n        </div>\n      </>\n    );\n  }\n}\n\nconst noTracesFoundOptions = [\n  {\n    label: 'No traces found',\n    value: 'no_traces',\n    isLeaf: true,\n\n    // Cannot be disabled because then cascader shows 'loading' for some reason.\n    // disabled: true,\n  },\n];\n\nexport default JaegerQueryField;\n","import { DataSourcePlugin } from '@grafana/data';\nimport { JaegerDatasource } from './datasource';\nimport { JaegerQueryField } from './QueryField';\nimport { ConfigEditor } from './ConfigEditor';\n\nexport const plugin = new DataSourcePlugin(JaegerDatasource)\n  .setConfigEditor(ConfigEditor)\n  .setExploreQueryField(JaegerQueryField);\n","import React from 'react';\nimport { DataSourcePluginOptionsEditorProps } from '@grafana/data';\nimport { DataSourceHttpSettings } from '@grafana/ui';\n\nexport type Props = DataSourcePluginOptionsEditorProps;\n\nexport const ConfigEditor: React.FC<Props> = ({ options, onOptionsChange }) => {\n  return (\n    <>\n      <DataSourceHttpSettings\n        defaultUrl={'http://localhost:16686'}\n        dataSourceConfig={options}\n        showAccessOptions={true}\n        onChange={onOptionsChange}\n      />\n    </>\n  );\n};\n"],"sourceRoot":""}