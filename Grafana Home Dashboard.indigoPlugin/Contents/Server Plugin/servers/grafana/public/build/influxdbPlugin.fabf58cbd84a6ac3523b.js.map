{"version":3,"sources":["webpack:///./public/app/features/datasources/utils/passwordHandlers.ts","webpack:///./public/app/plugins/datasource/influxdb/influx_series.ts","webpack:///./public/app/plugins/datasource/influxdb/query_part.ts","webpack:///./public/app/plugins/datasource/influxdb/influx_query_model.ts","webpack:///./public/app/plugins/datasource/influxdb/response_parser.ts","webpack:///./public/app/features/explore/AdHocFilter.tsx","webpack:///./public/app/plugins/datasource/influxdb/query_builder.ts","webpack:///./public/app/plugins/datasource/influxdb/datasource.ts","webpack:///./public/app/plugins/datasource/influxdb/query_ctrl.ts","webpack:///./public/app/features/explore/AdHocFilterField.tsx","webpack:///./public/app/plugins/datasource/influxdb/components/InfluxLogsQueryField.tsx","webpack:///./public/app/plugins/datasource/influxdb/components/InfluxCheatSheet.tsx","webpack:///./public/app/plugins/datasource/influxdb/components/InfluxStartPage.tsx","webpack:///./public/app/plugins/datasource/influxdb/module.ts"],"names":["PasswordFieldEnum","__webpack_require__","d","__webpack_exports__","createResetHandler","createChangeHandler","ctrl","field","event","preventDefault","current","secureJsonFields","secureJsonData","currentTarget","value","InfluxSeries","options","this","series","alias","annotation","prototype","getTimeSeries","i","j","_this","output","length","lodash_default","a","each","columns","tags","map","key","seriesName","name","columnName","_getSeriesName","join","datapoints","values","push","target","index","segments","split","replace","match","g1","g2","group","segIndex","parseInt","isNaN","indexOf","tag","getAnnotations","list","titleCol","timeCol","tagsCol","textCol","column","titleColumn","includes","tagsColumn","textColumn","data","time","Date","title","flatten","filter","t","text","getTable","table","table_model","seriesIndex","type","src","keys","reordered","hasOwnProperty","rows","query_part_index","query_part_categories","Aggregations","Selectors","Transformations","Predictors","Math","Aliasing","Fields","createPart","part","def","message","query_part","register","category","groupByTimeFunctions","fieldRenderer","innerExpr","params","replaceAggregationAddStrategy","selectParts","partModel","morePartsAvailable","splice","addTransformationStrategy","addStrategy","query","parts","clone","selectModels","dynamicLookup","defaultParams","renderer","partCount","quote","renderMode","influxdb_query_part","create","getCategories","replaceAggregationAdd","InfluxQueryModel","templateSrv","scopedVars","policy","resultFormat","orderByTime","groupBy","select","updateProjection","$inject","groupByParts","updatePersistedParts","hasGroupByTime","find","g","hasFill","addGroupBy","stringParts","typePart","arg","removeGroupByPart","categories","s","removeSelect","removeSelectPart","modelsIndex","partIndex","addSelectPart","renderTagCondition","interpolate","str","operator","condition","test","getMeasurementAndPolicy","measurement","interpolateQueryStr","variable","defaultFormatFn","multi","includeAll","kbn","regexEscape","render","rawQuery","y","selectText","conditions","groupBySection","fill","limit","slimit","tz","renderAdhocFilters","filters","response_parser","ResponseParser","parse","results","influxResults","normalizedQuery","toLowerCase","isValueFirst","res","serie","isArray","addUnique","undefined","toString","arr","ChangeType","query_builder_InfluxQueryBuilder","InfluxQueryBuilder","database","buildExploreQuery","withKey","withMeasurementFilter","whereConditions","reduce","memo","_super","InfluxDatasource","instanceSettings","$q","backendSrv","call","urls","url","trim","username","password","basicAuth","withCredentials","settingsData","jsonData","interval","timeInterval","responseParser","Object","tslib_es6","queryModel","timeFilter","getTimeFilter","targets","cloneDeep","queryTargets","hide","__interval","influx_query_model","acc","allQueries","when","adhocFilters","getAdhocFilters","_seriesQuery","then","seriesList","result","influxSeries","influx_series","timeSeries","annotationQuery","reject","rangeRaw","timezone","e_1","_a","e_2","_b","_d","_e","_f","next","done","param","variableExists","error","interpolateVariablesInQueries","queries","expandedQueries","expandedQuery","datasource","expandedTags","metricFindQuery","interpolated","curry","getTagKeys","getTagValues","range","_influxRequest","httpMode","q","epoch","serializeParams","encodeURIComponent","testDatasource","get","status","catch","err","method","currentUrl","shift","u","p","db","has","extend","omit","pick","req","precision","inspect","paramSerializer","headers","Authorization","datasourceRequest","config","statusText","from","getInfluxTime","until","to","fromIsAbsolute","date","roundUp","isString","exec","valueOf","query_ctrl_InfluxQueryCtrl","InfluxQueryCtrl","$scope","$injector","uiSegmentSrv","panel","queryBuilder","groupBySegment","newPlusButton","resultFormats","policySegment","newSegment","measurementSegment","newSelectMeasurement","_c","tagSegments","newCondition","newKey","fixTagSegments","buildSelectMenu","removeTagFilterSegment","removeOrderByTime","cat","submenu","item","menu","getGroupByOptions","tags_1","tags_1_1","handleQueryError","bind","groupByAction","plusButton","html","panelCtrl","refresh","subitem","handleSelectPartEvent","evt","fieldsQuery","transformToSegments","handleGroupByPartEvent","tagsQuery","count","lastSegment","max","measurementChanged","getPolicySegments","policiesQuery","policyChanged","toggleEditorMode","console","log","getMeasurements","measurementFilter","segment","expandable","variables","unshift","e_3","getTagsOrValues","addTemplateVars","nextValue","newOperators","angular_default","copy","getFieldSegments","tagSegmentUpdated","newOperator","newFake","cssClass","rebuildTargetTagConditions","tagIndex","segment2","getTagValueOperator","tagOperator","tagValue","getCollapsedText","templateUrl","AdHocFilter","props","react","grafana_ui_src","styles","keyValueContainer","index_esm","templateObject_1","changeType","onKeyChanged","onValueChanged","onOperatorChanged","Key","Operator","Value","stringToOption","label","initialKey","keysPlaceHolder","initialOperator","initialValue","valuesPlaceHolder","keysAsOptions","selectedKey","option","valuesAsOptions","selectedValue","operatorsAsOptions","selectedOperator","react_default","createElement","className","isSearchable","onChange","placeholder","DEFAULT_REMOVE_FILTER_VALUE","addFilterButton","onAddFilter","onClick","AdHocFilterField","extendedOptions","sent","onPairsChanged_1","onPairsChanged","loadTagValues","setState","pairs","pairs_1","updatePairs","state","loadTagKeys","allPairs","pair","pairIndex","componentDidUpdate","prevProps","isEqual","pairs_2","newPairs","newPair","Fragment","adHocKey","concat","InfluxLogsQueryField","apply","arguments","every","allDefined","allEmpty","pairsAreValid","trys","measureMentsQuery","influxMeasurements","measurementObj","queryBuilder_1","influxFields","children","measurements","cascadeText","getChooserText","disabled","hasMeasurement","AdHocFilterField_AdHocFilterField","InfluxCheatSheet","InfluxStartPage","onClickExample","passwordHandlers","module_plugin","InfluxConfigCtrl","onPasswordReset","Password","onPasswordChange","InfluxAnnotationsQueryCtrl","influxdb_datasource","setConfigCtrl","module_InfluxConfigCtrl","setQueryCtrl"],"mappings":"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","file":"influxdbPlugin.fabf58cbd84a6ac3523b.js","sourcesContent":["/**\n * Set of handlers for secure password field in Angular components. They handle backward compatibility with\n * passwords stored in plain text fields.\n */\n\nimport { SyntheticEvent } from 'react';\n\nexport enum PasswordFieldEnum {\n  Password = 'password',\n  BasicAuthPassword = 'basicAuthPassword',\n}\n\n/**\n * Basic shape for settings controllers in at the moment mostly angular datasource plugins.\n */\nexport type Ctrl = {\n  current: {\n    secureJsonFields: {\n      [key: string]: boolean;\n    };\n    secureJsonData?: {\n      [key: string]: string;\n    };\n    password?: string;\n    basicAuthPassword?: string;\n  };\n};\n\nexport const createResetHandler = (ctrl: Ctrl, field: PasswordFieldEnum) => (\n  event: SyntheticEvent<HTMLInputElement>\n) => {\n  event.preventDefault();\n  // Reset also normal plain text password to remove it and only save it in secureJsonData.\n  ctrl.current[field] = null;\n  ctrl.current.secureJsonFields[field] = false;\n  ctrl.current.secureJsonData = ctrl.current.secureJsonData || {};\n  ctrl.current.secureJsonData[field] = '';\n};\n\nexport const createChangeHandler = (ctrl: any, field: PasswordFieldEnum) => (\n  event: SyntheticEvent<HTMLInputElement>\n) => {\n  ctrl.current.secureJsonData = ctrl.current.secureJsonData || {};\n  ctrl.current.secureJsonData[field] = event.currentTarget.value;\n};\n","import _ from 'lodash';\nimport TableModel from 'app/core/table_model';\nimport { FieldType } from '@grafana/data';\n\nexport default class InfluxSeries {\n  series: any;\n  alias: any;\n  annotation: any;\n\n  constructor(options: { series: any; alias?: any; annotation?: any }) {\n    this.series = options.series;\n    this.alias = options.alias;\n    this.annotation = options.annotation;\n  }\n\n  getTimeSeries() {\n    const output: any[] = [];\n    let i, j;\n\n    if (this.series.length === 0) {\n      return output;\n    }\n\n    _.each(this.series, series => {\n      const columns = series.columns.length;\n      const tags = _.map(series.tags, (value, key) => {\n        return key + ': ' + value;\n      });\n\n      for (j = 1; j < columns; j++) {\n        let seriesName = series.name;\n        const columnName = series.columns[j];\n        if (columnName !== 'value') {\n          seriesName = seriesName + '.' + columnName;\n        }\n\n        if (this.alias) {\n          seriesName = this._getSeriesName(series, j);\n        } else if (series.tags) {\n          seriesName = seriesName + ' {' + tags.join(', ') + '}';\n        }\n\n        const datapoints = [];\n        if (series.values) {\n          for (i = 0; i < series.values.length; i++) {\n            datapoints[i] = [series.values[i][j], series.values[i][0]];\n          }\n        }\n\n        output.push({ target: seriesName, datapoints: datapoints });\n      }\n    });\n\n    return output;\n  }\n\n  _getSeriesName(series: any, index: number) {\n    const regex = /\\$(\\w+)|\\[\\[([\\s\\S]+?)\\]\\]/g;\n    const segments = series.name.split('.');\n\n    return this.alias.replace(regex, (match: any, g1: any, g2: any) => {\n      const group = g1 || g2;\n      const segIndex = parseInt(group, 10);\n\n      if (group === 'm' || group === 'measurement') {\n        return series.name;\n      }\n      if (group === 'col') {\n        return series.columns[index];\n      }\n      if (!isNaN(segIndex)) {\n        return segments[segIndex];\n      }\n      if (group.indexOf('tag_') !== 0) {\n        return match;\n      }\n\n      const tag = group.replace('tag_', '');\n      if (!series.tags) {\n        return match;\n      }\n      return series.tags[tag];\n    });\n  }\n\n  getAnnotations() {\n    const list: any[] = [];\n\n    _.each(this.series, series => {\n      let titleCol: any = null;\n      let timeCol: any = null;\n      const tagsCol: any = [];\n      let textCol: any = null;\n\n      _.each(series.columns, (column, index) => {\n        if (column === 'time') {\n          timeCol = index;\n          return;\n        }\n        if (column === 'sequence_number') {\n          return;\n        }\n        if (column === this.annotation.titleColumn) {\n          titleCol = index;\n          return;\n        }\n        if (_.includes((this.annotation.tagsColumn || '').replace(' ', '').split(','), column)) {\n          tagsCol.push(index);\n          return;\n        }\n        if (column === this.annotation.textColumn) {\n          textCol = index;\n          return;\n        }\n        // legacy case\n        if (!titleCol && textCol !== index) {\n          titleCol = index;\n        }\n      });\n\n      _.each(series.values, value => {\n        const data = {\n          annotation: this.annotation,\n          time: +new Date(value[timeCol]),\n          title: value[titleCol],\n          // Remove empty values, then split in different tags for comma separated values\n          tags: _.flatten(\n            tagsCol\n              .filter((t: any) => {\n                return value[t];\n              })\n              .map((t: any) => {\n                return value[t].split(',');\n              })\n          ),\n          text: value[textCol],\n        };\n\n        list.push(data);\n      });\n    });\n\n    return list;\n  }\n\n  getTable() {\n    const table = new TableModel();\n    let i, j;\n\n    if (this.series.length === 0) {\n      return table;\n    }\n\n    _.each(this.series, (series: any, seriesIndex: number) => {\n      if (seriesIndex === 0) {\n        j = 0;\n        // Check that the first column is indeed 'time'\n        if (series.columns[0] === 'time') {\n          // Push this now before the tags and with the right type\n          table.columns.push({ text: 'Time', type: FieldType.time });\n          j++;\n        }\n        _.each(_.keys(series.tags), key => {\n          table.columns.push({ text: key });\n        });\n        for (; j < series.columns.length; j++) {\n          table.columns.push({ text: series.columns[j] });\n        }\n      }\n\n      if (series.values) {\n        for (i = 0; i < series.values.length; i++) {\n          const values = series.values[i];\n          const reordered = [values[0]];\n          if (series.tags) {\n            for (const key in series.tags) {\n              if (series.tags.hasOwnProperty(key)) {\n                reordered.push(series.tags[key]);\n              }\n            }\n          }\n          for (j = 1; j < values.length; j++) {\n            reordered.push(values[j]);\n          }\n          table.rows.push(reordered);\n        }\n      }\n    });\n\n    return table;\n  }\n}\n","import _ from 'lodash';\nimport { QueryPartDef, QueryPart, functionRenderer, suffixRenderer } from 'app/core/components/query_part/query_part';\n\nconst index: any[] = [];\nconst categories: any = {\n  Aggregations: [],\n  Selectors: [],\n  Transformations: [],\n  Predictors: [],\n  Math: [],\n  Aliasing: [],\n  Fields: [],\n};\n\nfunction createPart(part: any): any {\n  const def = index[part.type];\n  if (!def) {\n    throw { message: 'Could not find query part ' + part.type };\n  }\n\n  return new QueryPart(part, def);\n}\n\nfunction register(options: any) {\n  index[options.type] = new QueryPartDef(options);\n  options.category.push(index[options.type]);\n}\n\nconst groupByTimeFunctions: any[] = [];\n\nfunction aliasRenderer(part: { params: string[] }, innerExpr: string) {\n  return innerExpr + ' AS ' + '\"' + part.params[0] + '\"';\n}\n\nfunction fieldRenderer(part: { params: string[] }, innerExpr: any) {\n  if (part.params[0] === '*') {\n    return '*';\n  }\n  return '\"' + part.params[0] + '\"';\n}\n\nfunction replaceAggregationAddStrategy(selectParts: any[], partModel: { def: { type: string } }) {\n  // look for existing aggregation\n  for (let i = 0; i < selectParts.length; i++) {\n    const part = selectParts[i];\n    if (part.def.category === categories.Aggregations) {\n      if (part.def.type === partModel.def.type) {\n        return;\n      }\n      // count distinct is allowed\n      if (part.def.type === 'count' && partModel.def.type === 'distinct') {\n        break;\n      }\n      // remove next aggregation if distinct was replaced\n      if (part.def.type === 'distinct') {\n        const morePartsAvailable = selectParts.length >= i + 2;\n        if (partModel.def.type !== 'count' && morePartsAvailable) {\n          const nextPart = selectParts[i + 1];\n          if (nextPart.def.category === categories.Aggregations) {\n            selectParts.splice(i + 1, 1);\n          }\n        } else if (partModel.def.type === 'count') {\n          if (!morePartsAvailable || selectParts[i + 1].def.type !== 'count') {\n            selectParts.splice(i + 1, 0, partModel);\n          }\n          return;\n        }\n      }\n      selectParts[i] = partModel;\n      return;\n    }\n    if (part.def.category === categories.Selectors) {\n      selectParts[i] = partModel;\n      return;\n    }\n  }\n\n  selectParts.splice(1, 0, partModel);\n}\n\nfunction addTransformationStrategy(selectParts: any[], partModel: any) {\n  let i;\n  // look for index to add transformation\n  for (i = 0; i < selectParts.length; i++) {\n    const part = selectParts[i];\n    if (part.def.category === categories.Math || part.def.category === categories.Aliasing) {\n      break;\n    }\n  }\n\n  selectParts.splice(i, 0, partModel);\n}\n\nfunction addMathStrategy(selectParts: any[], partModel: any) {\n  const partCount = selectParts.length;\n  if (partCount > 0) {\n    // if last is math, replace it\n    if (selectParts[partCount - 1].def.type === 'math') {\n      selectParts[partCount - 1] = partModel;\n      return;\n    }\n    // if next to last is math, replace it\n    if (partCount > 1 && selectParts[partCount - 2].def.type === 'math') {\n      selectParts[partCount - 2] = partModel;\n      return;\n    } else if (selectParts[partCount - 1].def.type === 'alias') {\n      // if last is alias add it before\n      selectParts.splice(partCount - 1, 0, partModel);\n      return;\n    }\n  }\n  selectParts.push(partModel);\n}\n\nfunction addAliasStrategy(selectParts: any[], partModel: any) {\n  const partCount = selectParts.length;\n  if (partCount > 0) {\n    // if last is alias, replace it\n    if (selectParts[partCount - 1].def.type === 'alias') {\n      selectParts[partCount - 1] = partModel;\n      return;\n    }\n  }\n  selectParts.push(partModel);\n}\n\nfunction addFieldStrategy(selectParts: any, partModel: any, query: { selectModels: any[][] }) {\n  // copy all parts\n  const parts = _.map(selectParts, (part: any) => {\n    return createPart({ type: part.def.type, params: _.clone(part.params) });\n  });\n\n  query.selectModels.push(parts);\n}\n\nregister({\n  type: 'field',\n  addStrategy: addFieldStrategy,\n  category: categories.Fields,\n  params: [{ type: 'field', dynamicLookup: true }],\n  defaultParams: ['value'],\n  renderer: fieldRenderer,\n});\n\n// Aggregations\nregister({\n  type: 'count',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'distinct',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'integral',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'mean',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'median',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'mode',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'sum',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\n// transformations\n\nregister({\n  type: 'derivative',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [\n    {\n      name: 'duration',\n      type: 'interval',\n      options: ['1s', '10s', '1m', '5m', '10m', '15m', '1h'],\n    },\n  ],\n  defaultParams: ['10s'],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'spread',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'non_negative_derivative',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [\n    {\n      name: 'duration',\n      type: 'interval',\n      options: ['1s', '10s', '1m', '5m', '10m', '15m', '1h'],\n    },\n  ],\n  defaultParams: ['10s'],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'difference',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'non_negative_difference',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'moving_average',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [{ name: 'window', type: 'int', options: [5, 10, 20, 30, 40] }],\n  defaultParams: [10],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'cumulative_sum',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'stddev',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'time',\n  category: groupByTimeFunctions,\n  params: [\n    {\n      name: 'interval',\n      type: 'time',\n      options: ['$__interval', '1s', '10s', '1m', '5m', '10m', '15m', '1h'],\n    },\n  ],\n  defaultParams: ['$__interval'],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'fill',\n  category: groupByTimeFunctions,\n  params: [\n    {\n      name: 'fill',\n      type: 'string',\n      options: ['none', 'null', '0', 'previous', 'linear'],\n    },\n  ],\n  defaultParams: ['null'],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'elapsed',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [\n    {\n      name: 'duration',\n      type: 'interval',\n      options: ['1s', '10s', '1m', '5m', '10m', '15m', '1h'],\n    },\n  ],\n  defaultParams: ['10s'],\n  renderer: functionRenderer,\n});\n\n// predictions\nregister({\n  type: 'holt_winters',\n  addStrategy: addTransformationStrategy,\n  category: categories.Predictors,\n  params: [\n    { name: 'number', type: 'int', options: [5, 10, 20, 30, 40] },\n    { name: 'season', type: 'int', options: [0, 1, 2, 5, 10] },\n  ],\n  defaultParams: [10, 2],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'holt_winters_with_fit',\n  addStrategy: addTransformationStrategy,\n  category: categories.Predictors,\n  params: [\n    { name: 'number', type: 'int', options: [5, 10, 20, 30, 40] },\n    { name: 'season', type: 'int', options: [0, 1, 2, 5, 10] },\n  ],\n  defaultParams: [10, 2],\n  renderer: functionRenderer,\n});\n\n// Selectors\nregister({\n  type: 'bottom',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [{ name: 'count', type: 'int' }],\n  defaultParams: [3],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'first',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'last',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'max',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'min',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'percentile',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [{ name: 'nth', type: 'int' }],\n  defaultParams: [95],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'top',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [{ name: 'count', type: 'int' }],\n  defaultParams: [3],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'tag',\n  category: groupByTimeFunctions,\n  params: [{ name: 'tag', type: 'string', dynamicLookup: true }],\n  defaultParams: ['tag'],\n  renderer: fieldRenderer,\n});\n\nregister({\n  type: 'math',\n  addStrategy: addMathStrategy,\n  category: categories.Math,\n  params: [{ name: 'expr', type: 'string' }],\n  defaultParams: [' / 100'],\n  renderer: suffixRenderer,\n});\n\nregister({\n  type: 'alias',\n  addStrategy: addAliasStrategy,\n  category: categories.Aliasing,\n  params: [{ name: 'name', type: 'string', quote: 'double' }],\n  defaultParams: ['alias'],\n  renderMode: 'suffix',\n  renderer: aliasRenderer,\n});\n\nexport default {\n  create: createPart,\n  getCategories: () => {\n    return categories;\n  },\n  replaceAggregationAdd: replaceAggregationAddStrategy,\n};\n","import _ from 'lodash';\nimport queryPart from './query_part';\nimport kbn from 'app/core/utils/kbn';\nimport { InfluxQuery, InfluxQueryTag } from './types';\nimport { ScopedVars } from '@grafana/data';\nimport { TemplateSrv } from 'app/features/templating/template_srv';\n\nexport default class InfluxQueryModel {\n  target: InfluxQuery;\n  selectModels: any[];\n  queryBuilder: any;\n  groupByParts: any;\n  templateSrv: any;\n  scopedVars: any;\n  refId: string;\n\n  /** @ngInject */\n  constructor(target: InfluxQuery, templateSrv?: TemplateSrv, scopedVars?: ScopedVars) {\n    this.target = target;\n    this.templateSrv = templateSrv;\n    this.scopedVars = scopedVars;\n\n    target.policy = target.policy || 'default';\n    target.resultFormat = target.resultFormat || 'time_series';\n    target.orderByTime = target.orderByTime || 'ASC';\n    target.tags = target.tags || [];\n    target.groupBy = target.groupBy || [{ type: 'time', params: ['$__interval'] }, { type: 'fill', params: ['null'] }];\n    target.select = target.select || [[{ type: 'field', params: ['value'] }, { type: 'mean', params: [] }]];\n\n    this.updateProjection();\n  }\n\n  updateProjection() {\n    this.selectModels = _.map(this.target.select, (parts: any) => {\n      return _.map(parts, queryPart.create);\n    });\n    this.groupByParts = _.map(this.target.groupBy, queryPart.create);\n  }\n\n  updatePersistedParts() {\n    this.target.select = _.map(this.selectModels, selectParts => {\n      return _.map(selectParts, (part: any) => {\n        return { type: part.def.type, params: part.params };\n      });\n    });\n  }\n\n  hasGroupByTime() {\n    return _.find(this.target.groupBy, (g: any) => g.type === 'time');\n  }\n\n  hasFill() {\n    return _.find(this.target.groupBy, (g: any) => g.type === 'fill');\n  }\n\n  addGroupBy(value: string) {\n    const stringParts = value.match(/^(\\w+)\\((.*)\\)$/);\n    const typePart = stringParts[1];\n    const arg = stringParts[2];\n    const partModel = queryPart.create({ type: typePart, params: [arg] });\n    const partCount = this.target.groupBy.length;\n\n    if (partCount === 0) {\n      this.target.groupBy.push(partModel.part);\n    } else if (typePart === 'time') {\n      this.target.groupBy.splice(0, 0, partModel.part);\n    } else if (typePart === 'tag') {\n      if (this.target.groupBy[partCount - 1].type === 'fill') {\n        this.target.groupBy.splice(partCount - 1, 0, partModel.part);\n      } else {\n        this.target.groupBy.push(partModel.part);\n      }\n    } else {\n      this.target.groupBy.push(partModel.part);\n    }\n\n    this.updateProjection();\n  }\n\n  removeGroupByPart(part: { def: { type: string } }, index: number) {\n    const categories = queryPart.getCategories();\n\n    if (part.def.type === 'time') {\n      // remove fill\n      this.target.groupBy = _.filter(this.target.groupBy, (g: any) => g.type !== 'fill');\n      // remove aggregations\n      this.target.select = _.map(this.target.select, (s: any) => {\n        return _.filter(s, (part: any) => {\n          const partModel = queryPart.create(part);\n          if (partModel.def.category === categories.Aggregations) {\n            return false;\n          }\n          if (partModel.def.category === categories.Selectors) {\n            return false;\n          }\n          return true;\n        });\n      });\n    }\n\n    this.target.groupBy.splice(index, 1);\n    this.updateProjection();\n  }\n\n  removeSelect(index: number) {\n    this.target.select.splice(index, 1);\n    this.updateProjection();\n  }\n\n  removeSelectPart(selectParts: any[], part: any) {\n    // if we remove the field remove the whole statement\n    if (part.def.type === 'field') {\n      if (this.selectModels.length > 1) {\n        const modelsIndex = _.indexOf(this.selectModels, selectParts);\n        this.selectModels.splice(modelsIndex, 1);\n      }\n    } else {\n      const partIndex = _.indexOf(selectParts, part);\n      selectParts.splice(partIndex, 1);\n    }\n\n    this.updatePersistedParts();\n  }\n\n  addSelectPart(selectParts: any[], type: string) {\n    const partModel = queryPart.create({ type: type });\n    partModel.def.addStrategy(selectParts, partModel, this);\n    this.updatePersistedParts();\n  }\n\n  private renderTagCondition(tag: InfluxQueryTag, index: number, interpolate: boolean) {\n    let str = '';\n    let operator = tag.operator;\n    let value = tag.value;\n    if (index > 0) {\n      str = (tag.condition || 'AND') + ' ';\n    }\n\n    if (!operator) {\n      if (/^\\/.*\\/$/.test(value)) {\n        operator = '=~';\n      } else {\n        operator = '=';\n      }\n    }\n\n    // quote value unless regex\n    if (operator !== '=~' && operator !== '!~') {\n      if (interpolate) {\n        value = this.templateSrv.replace(value, this.scopedVars);\n      }\n      if (operator !== '>' && operator !== '<') {\n        value = \"'\" + value.replace(/\\\\/g, '\\\\\\\\').replace(/\\'/g, \"\\\\'\") + \"'\";\n      }\n    } else if (interpolate) {\n      value = this.templateSrv.replace(value, this.scopedVars, 'regex');\n    }\n\n    return str + '\"' + tag.key + '\" ' + operator + ' ' + value;\n  }\n\n  getMeasurementAndPolicy(interpolate: any) {\n    let policy = this.target.policy;\n    let measurement = this.target.measurement || 'measurement';\n\n    if (!measurement.match('^/.*/$')) {\n      measurement = '\"' + measurement + '\"';\n    } else if (interpolate) {\n      measurement = this.templateSrv.replace(measurement, this.scopedVars, 'regex');\n    }\n\n    if (policy !== 'default') {\n      policy = '\"' + this.target.policy + '\".';\n    } else {\n      policy = '';\n    }\n\n    return policy + measurement;\n  }\n\n  interpolateQueryStr(value: any[], variable: { multi: any; includeAll: any }, defaultFormatFn: any) {\n    // if no multi or include all do not regexEscape\n    if (!variable.multi && !variable.includeAll) {\n      return value;\n    }\n\n    if (typeof value === 'string') {\n      return kbn.regexEscape(value);\n    }\n\n    const escapedValues = _.map(value, kbn.regexEscape);\n    return '(' + escapedValues.join('|') + ')';\n  }\n\n  render(interpolate?: boolean) {\n    const target = this.target;\n\n    if (target.rawQuery) {\n      if (interpolate) {\n        return this.templateSrv.replace(target.query, this.scopedVars, this.interpolateQueryStr);\n      } else {\n        return target.query;\n      }\n    }\n\n    let query = 'SELECT ';\n    let i, y;\n    for (i = 0; i < this.selectModels.length; i++) {\n      const parts = this.selectModels[i];\n      let selectText = '';\n      for (y = 0; y < parts.length; y++) {\n        const part = parts[y];\n        selectText = part.render(selectText);\n      }\n\n      if (i > 0) {\n        query += ', ';\n      }\n      query += selectText;\n    }\n\n    query += ' FROM ' + this.getMeasurementAndPolicy(interpolate) + ' WHERE ';\n    const conditions = _.map(target.tags, (tag, index) => {\n      return this.renderTagCondition(tag, index, interpolate);\n    });\n\n    if (conditions.length > 0) {\n      query += '(' + conditions.join(' ') + ') AND ';\n    }\n\n    query += '$timeFilter';\n\n    let groupBySection = '';\n    for (i = 0; i < this.groupByParts.length; i++) {\n      const part = this.groupByParts[i];\n      if (i > 0) {\n        // for some reason fill has no separator\n        groupBySection += part.def.type === 'fill' ? ' ' : ', ';\n      }\n      groupBySection += part.render('');\n    }\n\n    if (groupBySection.length) {\n      query += ' GROUP BY ' + groupBySection;\n    }\n\n    if (target.fill) {\n      query += ' fill(' + target.fill + ')';\n    }\n\n    if (target.orderByTime === 'DESC') {\n      query += ' ORDER BY time DESC';\n    }\n\n    if (target.limit) {\n      query += ' LIMIT ' + target.limit;\n    }\n\n    if (target.slimit) {\n      query += ' SLIMIT ' + target.slimit;\n    }\n\n    if (target.tz) {\n      query += \" tz('\" + target.tz + \"')\";\n    }\n\n    return query;\n  }\n\n  renderAdhocFilters(filters: any[]) {\n    const conditions = _.map(filters, (tag, index) => {\n      return this.renderTagCondition(tag, index, true);\n    });\n    return conditions.join(' ');\n  }\n}\n","import _ from 'lodash';\n\nexport default class ResponseParser {\n  parse(query: string, results: { results: any }) {\n    if (!results || results.results.length === 0) {\n      return [];\n    }\n\n    const influxResults = results.results[0];\n    if (!influxResults.series) {\n      return [];\n    }\n\n    const normalizedQuery = query.toLowerCase();\n    const isValueFirst =\n      normalizedQuery.indexOf('show field keys') >= 0 || normalizedQuery.indexOf('show retention policies') >= 0;\n\n    const res = {};\n    _.each(influxResults.series, serie => {\n      _.each(serie.values, value => {\n        if (_.isArray(value)) {\n          // In general, there are 2 possible shapes for the returned value.\n          // The first one is a two-element array,\n          // where the first element is somewhat a metadata value:\n          // the tag name for SHOW TAG VALUES queries,\n          // the time field for SELECT queries, etc.\n          // The second shape is an one-element array,\n          // that is containing an immediate value.\n          // For example, SHOW FIELD KEYS queries return such shape.\n          // Note, pre-0.11 versions return\n          // the second shape for SHOW TAG VALUES queries\n          // (while the newer versionsfirst).\n\n          if (isValueFirst) {\n            addUnique(res, value[0]);\n          } else if (value[1] !== undefined) {\n            addUnique(res, value[1]);\n          } else {\n            addUnique(res, value[0]);\n          }\n        } else {\n          addUnique(res, value);\n        }\n      });\n    });\n\n    // @ts-ignore problems with typings for this _.map only accepts [] but this needs to be object\n    return _.map(res, value => {\n      // @ts-ignore\n      return { text: value.toString() };\n    });\n  }\n}\n\nfunction addUnique(arr: { [x: string]: any }, value: string | number) {\n  arr[value] = value;\n}\n","import React, { useContext } from 'react';\nimport { Select, ThemeContext } from '@grafana/ui';\nimport { css, cx } from 'emotion';\nimport { GrafanaTheme, SelectableValue } from '@grafana/data';\n\nconst getStyles = (theme: GrafanaTheme) => ({\n  keyValueContainer: css`\n    label: key-value-container;\n    display: flex;\n    flex-flow: row nowrap;\n  `,\n});\n\nenum ChangeType {\n  Key = 'key',\n  Value = 'value',\n  Operator = 'operator',\n}\n\nexport interface Props {\n  keys: string[];\n  keysPlaceHolder?: string;\n  initialKey?: string;\n  initialOperator?: string;\n  initialValue?: string;\n  values?: string[];\n  valuesPlaceHolder?: string;\n  onKeyChanged: (key: string) => void;\n  onValueChanged: (value: string) => void;\n  onOperatorChanged: (operator: string) => void;\n}\n\nexport const AdHocFilter: React.FunctionComponent<Props> = props => {\n  const theme = useContext(ThemeContext);\n  const styles = getStyles(theme);\n\n  const onChange = (changeType: ChangeType) => (item: SelectableValue<string>) => {\n    const { onKeyChanged, onValueChanged, onOperatorChanged } = props;\n    switch (changeType) {\n      case ChangeType.Key:\n        onKeyChanged(item.value);\n        break;\n      case ChangeType.Operator:\n        onOperatorChanged(item.value);\n        break;\n      case ChangeType.Value:\n        onValueChanged(item.value);\n        break;\n    }\n  };\n\n  const stringToOption = (value: string) => ({ label: value, value: value });\n\n  const { keys, initialKey, keysPlaceHolder, initialOperator, values, initialValue, valuesPlaceHolder } = props;\n  const operators = ['=', '!='];\n  const keysAsOptions = keys ? keys.map(stringToOption) : [];\n  const selectedKey = initialKey ? keysAsOptions.filter(option => option.value === initialKey) : null;\n  const valuesAsOptions = values ? values.map(stringToOption) : [];\n  const selectedValue = initialValue ? valuesAsOptions.filter(option => option.value === initialValue) : null;\n  const operatorsAsOptions = operators.map(stringToOption);\n  const selectedOperator = initialOperator\n    ? operatorsAsOptions.filter(option => option.value === initialOperator)\n    : null;\n\n  return (\n    <div className={cx([styles.keyValueContainer])}>\n      <Select\n        options={keysAsOptions}\n        isSearchable\n        value={selectedKey}\n        onChange={onChange(ChangeType.Key)}\n        placeholder={keysPlaceHolder}\n      />\n      <Select options={operatorsAsOptions} value={selectedOperator} onChange={onChange(ChangeType.Operator)} />\n      <Select\n        options={valuesAsOptions}\n        isSearchable\n        value={selectedValue}\n        onChange={onChange(ChangeType.Value)}\n        placeholder={valuesPlaceHolder}\n      />\n    </div>\n  );\n};\n","import _ from 'lodash';\nimport kbn from 'app/core/utils/kbn';\n\nfunction renderTagCondition(tag: { operator: any; value: string; condition: any; key: string }, index: number) {\n  let str = '';\n  let operator = tag.operator;\n  let value = tag.value;\n  if (index > 0) {\n    str = (tag.condition || 'AND') + ' ';\n  }\n\n  if (!operator) {\n    if (/^\\/.*\\/$/.test(tag.value)) {\n      operator = '=~';\n    } else {\n      operator = '=';\n    }\n  }\n\n  // quote value unless regex or number\n  if (operator !== '=~' && operator !== '!~' && isNaN(+value)) {\n    value = \"'\" + value + \"'\";\n  }\n\n  return str + '\"' + tag.key + '\" ' + operator + ' ' + value;\n}\n\nexport class InfluxQueryBuilder {\n  constructor(private target: { measurement: any; tags: any; policy?: any }, private database?: string) {}\n\n  buildExploreQuery(type: string, withKey?: string, withMeasurementFilter?: string) {\n    let query;\n    let measurement;\n    let policy;\n\n    if (type === 'TAG_KEYS') {\n      query = 'SHOW TAG KEYS';\n      measurement = this.target.measurement;\n      policy = this.target.policy;\n    } else if (type === 'TAG_VALUES') {\n      query = 'SHOW TAG VALUES';\n      measurement = this.target.measurement;\n      policy = this.target.policy;\n    } else if (type === 'MEASUREMENTS') {\n      query = 'SHOW MEASUREMENTS';\n      if (withMeasurementFilter) {\n        query += ' WITH MEASUREMENT =~ /' + kbn.regexEscape(withMeasurementFilter) + '/';\n      }\n    } else if (type === 'FIELDS') {\n      measurement = this.target.measurement;\n      policy = this.target.policy;\n\n      if (!measurement.match('^/.*/')) {\n        measurement = '\"' + measurement + '\"';\n\n        if (policy && policy !== 'default') {\n          policy = '\"' + policy + '\"';\n          measurement = policy + '.' + measurement;\n        }\n      }\n\n      return 'SHOW FIELD KEYS FROM ' + measurement;\n    } else if (type === 'RETENTION POLICIES') {\n      query = 'SHOW RETENTION POLICIES on \"' + this.database + '\"';\n      return query;\n    }\n\n    if (measurement) {\n      if (!measurement.match('^/.*/') && !measurement.match(/^merge\\(.*\\)/)) {\n        measurement = '\"' + measurement + '\"';\n      }\n\n      if (policy && policy !== 'default') {\n        policy = '\"' + policy + '\"';\n        measurement = policy + '.' + measurement;\n      }\n\n      query += ' FROM ' + measurement;\n    }\n\n    if (withKey) {\n      query += ' WITH KEY = \"' + withKey + '\"';\n    }\n\n    if (this.target.tags && this.target.tags.length > 0) {\n      const whereConditions = _.reduce(\n        this.target.tags,\n        (memo, tag) => {\n          // do not add a condition for the key we want to explore for\n          if (tag.key === withKey) {\n            return memo;\n          }\n          memo.push(renderTagCondition(tag, memo.length));\n          return memo;\n        },\n        []\n      );\n\n      if (whereConditions.length > 0) {\n        query += ' WHERE ' + whereConditions.join(' ');\n      }\n    }\n    if (type === 'MEASUREMENTS') {\n      query += ' LIMIT 100';\n      //Solve issue #2524 by limiting the number of measurements returned\n      //LIMIT must be after WITH MEASUREMENT and WHERE clauses\n      //This also could be used for TAG KEYS and TAG VALUES, if desired\n    }\n    return query;\n  }\n}\n","import _ from 'lodash';\n\nimport { dateMath, DataSourceApi, DataSourceInstanceSettings } from '@grafana/data';\nimport InfluxSeries from './influx_series';\nimport InfluxQueryModel from './influx_query_model';\nimport ResponseParser from './response_parser';\nimport { InfluxQueryBuilder } from './query_builder';\nimport { InfluxQuery, InfluxOptions } from './types';\nimport { BackendSrv } from 'app/core/services/backend_srv';\nimport { TemplateSrv } from 'app/features/templating/template_srv';\nimport { IQService } from 'angular';\n\nexport default class InfluxDatasource extends DataSourceApi<InfluxQuery, InfluxOptions> {\n  type: string;\n  urls: any;\n  username: string;\n  password: string;\n  name: string;\n  database: any;\n  basicAuth: any;\n  withCredentials: any;\n  interval: any;\n  responseParser: any;\n  httpMode: string;\n\n  /** @ngInject */\n  constructor(\n    instanceSettings: DataSourceInstanceSettings<InfluxOptions>,\n    private $q: IQService,\n    private backendSrv: BackendSrv,\n    private templateSrv: TemplateSrv\n  ) {\n    super(instanceSettings);\n    this.type = 'influxdb';\n    this.urls = _.map(instanceSettings.url.split(','), url => {\n      return url.trim();\n    });\n\n    this.username = instanceSettings.username;\n    this.password = instanceSettings.password;\n    this.name = instanceSettings.name;\n    this.database = instanceSettings.database;\n    this.basicAuth = instanceSettings.basicAuth;\n    this.withCredentials = instanceSettings.withCredentials;\n    const settingsData = instanceSettings.jsonData || ({} as InfluxOptions);\n    this.interval = settingsData.timeInterval;\n    this.httpMode = settingsData.httpMode || 'GET';\n    this.responseParser = new ResponseParser();\n  }\n\n  query(options: any) {\n    let timeFilter = this.getTimeFilter(options);\n    const scopedVars = options.scopedVars;\n    const targets = _.cloneDeep(options.targets);\n    const queryTargets: any[] = [];\n    let queryModel: InfluxQueryModel;\n    let i, y;\n\n    let allQueries = _.map(targets, target => {\n      if (target.hide) {\n        return '';\n      }\n\n      queryTargets.push(target);\n\n      // backward compatibility\n      scopedVars.interval = scopedVars.__interval;\n\n      queryModel = new InfluxQueryModel(target, this.templateSrv, scopedVars);\n      return queryModel.render(true);\n    }).reduce((acc, current) => {\n      if (current !== '') {\n        acc += ';' + current;\n      }\n      return acc;\n    });\n\n    if (allQueries === '') {\n      return this.$q.when({ data: [] });\n    }\n\n    // add global adhoc filters to timeFilter\n    const adhocFilters = this.templateSrv.getAdhocFilters(this.name);\n    if (adhocFilters.length > 0) {\n      timeFilter += ' AND ' + queryModel.renderAdhocFilters(adhocFilters);\n    }\n\n    // replace grafana variables\n    scopedVars.timeFilter = { value: timeFilter };\n\n    // replace templated variables\n    allQueries = this.templateSrv.replace(allQueries, scopedVars);\n\n    return this._seriesQuery(allQueries, options).then(\n      (data: any): any => {\n        if (!data || !data.results) {\n          return [];\n        }\n\n        const seriesList = [];\n        for (i = 0; i < data.results.length; i++) {\n          const result = data.results[i];\n          if (!result || !result.series) {\n            continue;\n          }\n\n          const target = queryTargets[i];\n          let alias = target.alias;\n          if (alias) {\n            alias = this.templateSrv.replace(target.alias, options.scopedVars);\n          }\n\n          const influxSeries = new InfluxSeries({\n            series: data.results[i].series,\n            alias: alias,\n          });\n\n          switch (target.resultFormat) {\n            case 'table': {\n              seriesList.push(influxSeries.getTable());\n              break;\n            }\n            default: {\n              const timeSeries = influxSeries.getTimeSeries();\n              for (y = 0; y < timeSeries.length; y++) {\n                seriesList.push(timeSeries[y]);\n              }\n              break;\n            }\n          }\n        }\n\n        return { data: seriesList };\n      }\n    );\n  }\n\n  annotationQuery(options: any) {\n    if (!options.annotation.query) {\n      return this.$q.reject({\n        message: 'Query missing in annotation definition',\n      });\n    }\n\n    const timeFilter = this.getTimeFilter({ rangeRaw: options.rangeRaw, timezone: options.timezone });\n    let query = options.annotation.query.replace('$timeFilter', timeFilter);\n    query = this.templateSrv.replace(query, null, 'regex');\n\n    return this._seriesQuery(query, options).then((data: any) => {\n      if (!data || !data.results || !data.results[0]) {\n        throw { message: 'No results in response from InfluxDB' };\n      }\n      return new InfluxSeries({\n        series: data.results[0].series,\n        annotation: options.annotation,\n      }).getAnnotations();\n    });\n  }\n\n  targetContainsTemplate(target: any) {\n    for (const group of target.groupBy) {\n      for (const param of group.params) {\n        if (this.templateSrv.variableExists(param)) {\n          return true;\n        }\n      }\n    }\n\n    for (const i in target.tags) {\n      if (this.templateSrv.variableExists(target.tags[i].value)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  interpolateVariablesInQueries(queries: InfluxQuery[]): InfluxQuery[] {\n    if (!queries || queries.length === 0) {\n      return [];\n    }\n\n    let expandedQueries = queries;\n    if (queries && queries.length > 0) {\n      expandedQueries = queries.map(query => {\n        const expandedQuery = {\n          ...query,\n          datasource: this.name,\n          measurement: this.templateSrv.replace(query.measurement, null, 'regex'),\n        };\n\n        if (query.rawQuery) {\n          expandedQuery.query = this.templateSrv.replace(query.query, null, 'regex');\n        }\n\n        if (query.tags) {\n          const expandedTags = query.tags.map(tag => {\n            const expandedTag = {\n              ...tag,\n              value: this.templateSrv.replace(tag.value, null, 'regex'),\n            };\n            return expandedTag;\n          });\n          expandedQuery.tags = expandedTags;\n        }\n        return expandedQuery;\n      });\n    }\n    return expandedQueries;\n  }\n\n  metricFindQuery(query: string, options?: any) {\n    const interpolated = this.templateSrv.replace(query, null, 'regex');\n\n    return this._seriesQuery(interpolated, options).then(_.curry(this.responseParser.parse)(query));\n  }\n\n  getTagKeys(options: any = {}) {\n    const queryBuilder = new InfluxQueryBuilder({ measurement: options.measurement || '', tags: [] }, this.database);\n    const query = queryBuilder.buildExploreQuery('TAG_KEYS');\n    return this.metricFindQuery(query, options);\n  }\n\n  getTagValues(options: any = {}) {\n    const queryBuilder = new InfluxQueryBuilder({ measurement: options.measurement || '', tags: [] }, this.database);\n    const query = queryBuilder.buildExploreQuery('TAG_VALUES', options.key);\n    return this.metricFindQuery(query, options);\n  }\n\n  _seriesQuery(query: string, options?: any) {\n    if (!query) {\n      return this.$q.when({ results: [] });\n    }\n\n    if (options && options.range) {\n      const timeFilter = this.getTimeFilter({ rangeRaw: options.range, timezone: options.timezone });\n      query = query.replace('$timeFilter', timeFilter);\n    }\n\n    return this._influxRequest(this.httpMode, '/query', { q: query, epoch: 'ms' }, options);\n  }\n\n  serializeParams(params: any) {\n    if (!params) {\n      return '';\n    }\n\n    return _.reduce(\n      params,\n      (memo, value, key) => {\n        if (value === null || value === undefined) {\n          return memo;\n        }\n        memo.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));\n        return memo;\n      },\n      []\n    ).join('&');\n  }\n\n  testDatasource() {\n    const queryBuilder = new InfluxQueryBuilder({ measurement: '', tags: [] }, this.database);\n    const query = queryBuilder.buildExploreQuery('RETENTION POLICIES');\n\n    return this._seriesQuery(query)\n      .then((res: any) => {\n        const error = _.get(res, 'results[0].error');\n        if (error) {\n          return { status: 'error', message: error };\n        }\n        return { status: 'success', message: 'Data source is working' };\n      })\n      .catch((err: any) => {\n        return { status: 'error', message: err.message };\n      });\n  }\n\n  _influxRequest(method: string, url: string, data: any, options?: any) {\n    const currentUrl = this.urls.shift();\n    this.urls.push(currentUrl);\n\n    const params: any = {};\n\n    if (this.username) {\n      params.u = this.username;\n      params.p = this.password;\n    }\n\n    if (options && options.database) {\n      params.db = options.database;\n    } else if (this.database) {\n      params.db = this.database;\n    }\n\n    if (method === 'POST' && _.has(data, 'q')) {\n      // verb is POST and 'q' param is defined\n      _.extend(params, _.omit(data, ['q']));\n      data = this.serializeParams(_.pick(data, ['q']));\n    } else if (method === 'GET' || method === 'POST') {\n      // verb is GET, or POST without 'q' param\n      _.extend(params, data);\n      data = null;\n    }\n\n    const req: any = {\n      method: method,\n      url: currentUrl + url,\n      params: params,\n      data: data,\n      precision: 'ms',\n      inspect: { type: 'influxdb' },\n      paramSerializer: this.serializeParams,\n    };\n\n    req.headers = req.headers || {};\n    if (this.basicAuth || this.withCredentials) {\n      req.withCredentials = true;\n    }\n    if (this.basicAuth) {\n      req.headers.Authorization = this.basicAuth;\n    }\n\n    if (method === 'POST') {\n      req.headers['Content-type'] = 'application/x-www-form-urlencoded';\n    }\n\n    return this.backendSrv.datasourceRequest(req).then(\n      (result: any) => {\n        return result.data;\n      },\n      (err: any) => {\n        if (err.status !== 0 || err.status >= 300) {\n          if (err.data && err.data.error) {\n            throw {\n              message: 'InfluxDB Error: ' + err.data.error,\n              data: err.data,\n              config: err.config,\n            };\n          } else {\n            throw {\n              message: 'Network Error: ' + err.statusText + '(' + err.status + ')',\n              data: err.data,\n              config: err.config,\n            };\n          }\n        }\n      }\n    );\n  }\n\n  getTimeFilter(options: any) {\n    const from = this.getInfluxTime(options.rangeRaw.from, false, options.timezone);\n    const until = this.getInfluxTime(options.rangeRaw.to, true, options.timezone);\n    const fromIsAbsolute = from[from.length - 1] === 'ms';\n\n    if (until === 'now()' && !fromIsAbsolute) {\n      return 'time >= ' + from;\n    }\n\n    return 'time >= ' + from + ' and time <= ' + until;\n  }\n\n  getInfluxTime(date: any, roundUp: any, timezone: any) {\n    if (_.isString(date)) {\n      if (date === 'now') {\n        return 'now()';\n      }\n\n      const parts = /^now-(\\d+)([dhms])$/.exec(date);\n      if (parts) {\n        const amount = parseInt(parts[1], 10);\n        const unit = parts[2];\n        return 'now() - ' + amount + unit;\n      }\n      date = dateMath.parse(date, roundUp, timezone);\n    }\n\n    return date.valueOf() + 'ms';\n  }\n}\n","import angular, { auto, IQService } from 'angular';\nimport _ from 'lodash';\nimport { InfluxQueryBuilder } from './query_builder';\nimport InfluxQueryModel from './influx_query_model';\nimport queryPart from './query_part';\nimport { QueryCtrl } from 'app/plugins/sdk';\nimport { TemplateSrv } from 'app/features/templating/template_srv';\n\nexport class InfluxQueryCtrl extends QueryCtrl {\n  static templateUrl = 'partials/query.editor.html';\n\n  queryModel: InfluxQueryModel;\n  queryBuilder: any;\n  groupBySegment: any;\n  resultFormats: any[];\n  orderByTime: any[];\n  policySegment: any;\n  tagSegments: any[];\n  selectMenu: any;\n  measurementSegment: any;\n  removeTagFilterSegment: any;\n\n  /** @ngInject */\n  constructor(\n    $scope: any,\n    $injector: auto.IInjectorService,\n    private templateSrv: TemplateSrv,\n    private $q: IQService,\n    private uiSegmentSrv: any\n  ) {\n    super($scope, $injector);\n    this.target = this.target;\n    this.queryModel = new InfluxQueryModel(this.target, templateSrv, this.panel.scopedVars);\n    this.queryBuilder = new InfluxQueryBuilder(this.target, this.datasource.database);\n    this.groupBySegment = this.uiSegmentSrv.newPlusButton();\n    this.resultFormats = [{ text: 'Time series', value: 'time_series' }, { text: 'Table', value: 'table' }];\n    this.policySegment = uiSegmentSrv.newSegment(this.target.policy);\n\n    if (!this.target.measurement) {\n      this.measurementSegment = uiSegmentSrv.newSelectMeasurement();\n    } else {\n      this.measurementSegment = uiSegmentSrv.newSegment(this.target.measurement);\n    }\n\n    this.tagSegments = [];\n    for (const tag of this.target.tags) {\n      if (!tag.operator) {\n        if (/^\\/.*\\/$/.test(tag.value)) {\n          tag.operator = '=~';\n        } else {\n          tag.operator = '=';\n        }\n      }\n\n      if (tag.condition) {\n        this.tagSegments.push(uiSegmentSrv.newCondition(tag.condition));\n      }\n\n      this.tagSegments.push(uiSegmentSrv.newKey(tag.key));\n      this.tagSegments.push(uiSegmentSrv.newOperator(tag.operator));\n      this.tagSegments.push(uiSegmentSrv.newKeyValue(tag.value));\n    }\n\n    this.fixTagSegments();\n    this.buildSelectMenu();\n    this.removeTagFilterSegment = uiSegmentSrv.newSegment({\n      fake: true,\n      value: '-- remove tag filter --',\n    });\n  }\n\n  removeOrderByTime() {\n    this.target.orderByTime = 'ASC';\n  }\n\n  buildSelectMenu() {\n    const categories = queryPart.getCategories();\n    this.selectMenu = _.reduce(\n      categories,\n      (memo, cat, key) => {\n        const menu = {\n          text: key,\n          submenu: cat.map((item: any) => {\n            return { text: item.type, value: item.type };\n          }),\n        };\n        memo.push(menu);\n        return memo;\n      },\n      []\n    );\n  }\n\n  getGroupByOptions() {\n    const query = this.queryBuilder.buildExploreQuery('TAG_KEYS');\n\n    return this.datasource\n      .metricFindQuery(query)\n      .then((tags: any) => {\n        const options = [];\n        if (!this.queryModel.hasFill()) {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'fill(null)' }));\n        }\n        if (!this.target.limit) {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'LIMIT' }));\n        }\n        if (!this.target.slimit) {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'SLIMIT' }));\n        }\n        if (!this.target.tz) {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'tz' }));\n        }\n        if (this.target.orderByTime === 'ASC') {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'ORDER BY time DESC' }));\n        }\n        if (!this.queryModel.hasGroupByTime()) {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'time($interval)' }));\n        }\n        for (const tag of tags) {\n          options.push(this.uiSegmentSrv.newSegment({ value: 'tag(' + tag.text + ')' }));\n        }\n        return options;\n      })\n      .catch(this.handleQueryError.bind(this));\n  }\n\n  groupByAction() {\n    switch (this.groupBySegment.value) {\n      case 'LIMIT': {\n        this.target.limit = 10;\n        break;\n      }\n      case 'SLIMIT': {\n        this.target.slimit = 10;\n        break;\n      }\n      case 'tz': {\n        this.target.tz = 'UTC';\n        break;\n      }\n      case 'ORDER BY time DESC': {\n        this.target.orderByTime = 'DESC';\n        break;\n      }\n      default: {\n        this.queryModel.addGroupBy(this.groupBySegment.value);\n      }\n    }\n\n    const plusButton = this.uiSegmentSrv.newPlusButton();\n    this.groupBySegment.value = plusButton.value;\n    this.groupBySegment.html = plusButton.html;\n    this.panelCtrl.refresh();\n  }\n\n  addSelectPart(selectParts: any, cat: any, subitem: { value: any }) {\n    this.queryModel.addSelectPart(selectParts, subitem.value);\n    this.panelCtrl.refresh();\n  }\n\n  handleSelectPartEvent(selectParts: any, part: any, evt: { name: any }) {\n    switch (evt.name) {\n      case 'get-param-options': {\n        const fieldsQuery = this.queryBuilder.buildExploreQuery('FIELDS');\n        return this.datasource\n          .metricFindQuery(fieldsQuery)\n          .then(this.transformToSegments(true))\n          .catch(this.handleQueryError.bind(this));\n      }\n      case 'part-param-changed': {\n        this.panelCtrl.refresh();\n        break;\n      }\n      case 'action': {\n        this.queryModel.removeSelectPart(selectParts, part);\n        this.panelCtrl.refresh();\n        break;\n      }\n      case 'get-part-actions': {\n        return this.$q.when([{ text: 'Remove', value: 'remove-part' }]);\n      }\n    }\n  }\n\n  handleGroupByPartEvent(part: any, index: any, evt: { name: any }) {\n    switch (evt.name) {\n      case 'get-param-options': {\n        const tagsQuery = this.queryBuilder.buildExploreQuery('TAG_KEYS');\n        return this.datasource\n          .metricFindQuery(tagsQuery)\n          .then(this.transformToSegments(true))\n          .catch(this.handleQueryError.bind(this));\n      }\n      case 'part-param-changed': {\n        this.panelCtrl.refresh();\n        break;\n      }\n      case 'action': {\n        this.queryModel.removeGroupByPart(part, index);\n        this.panelCtrl.refresh();\n        break;\n      }\n      case 'get-part-actions': {\n        return this.$q.when([{ text: 'Remove', value: 'remove-part' }]);\n      }\n    }\n  }\n\n  fixTagSegments() {\n    const count = this.tagSegments.length;\n    const lastSegment = this.tagSegments[Math.max(count - 1, 0)];\n\n    if (!lastSegment || lastSegment.type !== 'plus-button') {\n      this.tagSegments.push(this.uiSegmentSrv.newPlusButton());\n    }\n  }\n\n  measurementChanged() {\n    this.target.measurement = this.measurementSegment.value;\n    this.panelCtrl.refresh();\n  }\n\n  getPolicySegments() {\n    const policiesQuery = this.queryBuilder.buildExploreQuery('RETENTION POLICIES');\n    return this.datasource\n      .metricFindQuery(policiesQuery)\n      .then(this.transformToSegments(false))\n      .catch(this.handleQueryError.bind(this));\n  }\n\n  policyChanged() {\n    this.target.policy = this.policySegment.value;\n    this.panelCtrl.refresh();\n  }\n\n  toggleEditorMode() {\n    try {\n      this.target.query = this.queryModel.render(false);\n    } catch (err) {\n      console.log('query render error');\n    }\n    this.target.rawQuery = !this.target.rawQuery;\n  }\n\n  getMeasurements(measurementFilter: any) {\n    const query = this.queryBuilder.buildExploreQuery('MEASUREMENTS', undefined, measurementFilter);\n    return this.datasource\n      .metricFindQuery(query)\n      .then(this.transformToSegments(true))\n      .catch(this.handleQueryError.bind(this));\n  }\n\n  handleQueryError(err: any): any[] {\n    this.error = err.message || 'Failed to issue metric query';\n    return [];\n  }\n\n  transformToSegments(addTemplateVars: any) {\n    return (results: any) => {\n      const segments = _.map(results, segment => {\n        return this.uiSegmentSrv.newSegment({\n          value: segment.text,\n          expandable: segment.expandable,\n        });\n      });\n\n      if (addTemplateVars) {\n        for (const variable of this.templateSrv.variables) {\n          segments.unshift(\n            this.uiSegmentSrv.newSegment({\n              type: 'value',\n              value: '/^$' + variable.name + '$/',\n              expandable: true,\n            })\n          );\n        }\n      }\n\n      return segments;\n    };\n  }\n\n  getTagsOrValues(segment: { type: string }, index: number) {\n    if (segment.type === 'condition') {\n      return this.$q.when([this.uiSegmentSrv.newSegment('AND'), this.uiSegmentSrv.newSegment('OR')]);\n    }\n    if (segment.type === 'operator') {\n      const nextValue = this.tagSegments[index + 1].value;\n      if (/^\\/.*\\/$/.test(nextValue)) {\n        return this.$q.when(this.uiSegmentSrv.newOperators(['=~', '!~']));\n      } else {\n        return this.$q.when(this.uiSegmentSrv.newOperators(['=', '!=', '<>', '<', '>']));\n      }\n    }\n\n    let query, addTemplateVars;\n    if (segment.type === 'key' || segment.type === 'plus-button') {\n      query = this.queryBuilder.buildExploreQuery('TAG_KEYS');\n      addTemplateVars = false;\n    } else if (segment.type === 'value') {\n      query = this.queryBuilder.buildExploreQuery('TAG_VALUES', this.tagSegments[index - 2].value);\n      addTemplateVars = true;\n    }\n\n    return this.datasource\n      .metricFindQuery(query)\n      .then(this.transformToSegments(addTemplateVars))\n      .then((results: any) => {\n        if (segment.type === 'key') {\n          results.splice(0, 0, angular.copy(this.removeTagFilterSegment));\n        }\n        return results;\n      })\n      .catch(this.handleQueryError.bind(this));\n  }\n\n  getFieldSegments() {\n    const fieldsQuery = this.queryBuilder.buildExploreQuery('FIELDS');\n    return this.datasource\n      .metricFindQuery(fieldsQuery)\n      .then(this.transformToSegments(false))\n      .catch(this.handleQueryError);\n  }\n\n  tagSegmentUpdated(segment: { value: any; type: string; cssClass: string }, index: number) {\n    this.tagSegments[index] = segment;\n\n    // handle remove tag condition\n    if (segment.value === this.removeTagFilterSegment.value) {\n      this.tagSegments.splice(index, 3);\n      if (this.tagSegments.length === 0) {\n        this.tagSegments.push(this.uiSegmentSrv.newPlusButton());\n      } else if (this.tagSegments.length > 2) {\n        this.tagSegments.splice(Math.max(index - 1, 0), 1);\n        if (this.tagSegments[this.tagSegments.length - 1].type !== 'plus-button') {\n          this.tagSegments.push(this.uiSegmentSrv.newPlusButton());\n        }\n      }\n    } else {\n      if (segment.type === 'plus-button') {\n        if (index > 2) {\n          this.tagSegments.splice(index, 0, this.uiSegmentSrv.newCondition('AND'));\n        }\n        this.tagSegments.push(this.uiSegmentSrv.newOperator('='));\n        this.tagSegments.push(this.uiSegmentSrv.newFake('select tag value', 'value', 'query-segment-value'));\n        segment.type = 'key';\n        segment.cssClass = 'query-segment-key';\n      }\n\n      if (index + 1 === this.tagSegments.length) {\n        this.tagSegments.push(this.uiSegmentSrv.newPlusButton());\n      }\n    }\n\n    this.rebuildTargetTagConditions();\n  }\n\n  rebuildTargetTagConditions() {\n    const tags: any[] = [];\n    let tagIndex = 0;\n    let tagOperator = '';\n\n    _.each(this.tagSegments, (segment2, index) => {\n      if (segment2.type === 'key') {\n        if (tags.length === 0) {\n          tags.push({});\n        }\n        tags[tagIndex].key = segment2.value;\n      } else if (segment2.type === 'value') {\n        tagOperator = this.getTagValueOperator(segment2.value, tags[tagIndex].operator);\n        if (tagOperator) {\n          this.tagSegments[index - 1] = this.uiSegmentSrv.newOperator(tagOperator);\n          tags[tagIndex].operator = tagOperator;\n        }\n        tags[tagIndex].value = segment2.value;\n      } else if (segment2.type === 'condition') {\n        tags.push({ condition: segment2.value });\n        tagIndex += 1;\n      } else if (segment2.type === 'operator') {\n        tags[tagIndex].operator = segment2.value;\n      }\n    });\n\n    this.target.tags = tags;\n    this.panelCtrl.refresh();\n  }\n\n  getTagValueOperator(tagValue: string, tagOperator: string): string {\n    if (tagOperator !== '=~' && tagOperator !== '!~' && /^\\/.*\\/$/.test(tagValue)) {\n      return '=~';\n    } else if ((tagOperator === '=~' || tagOperator === '!~') && /^(?!\\/.*\\/$)/.test(tagValue)) {\n      return '=';\n    }\n    return null;\n  }\n\n  getCollapsedText() {\n    return this.queryModel.render(false);\n  }\n}\n","import React from 'react';\nimport _ from 'lodash';\nimport { DataSourceApi, DataQuery, DataSourceJsonData } from '@grafana/data';\nimport { AdHocFilter } from './AdHocFilter';\nexport const DEFAULT_REMOVE_FILTER_VALUE = '-- remove filter --';\n\nconst addFilterButton = (onAddFilter: (event: React.MouseEvent) => void) => (\n  <button className=\"gf-form-label gf-form-label--btn query-part\" onClick={onAddFilter}>\n    <i className=\"fa fa-plus\" />\n  </button>\n);\n\nexport interface KeyValuePair {\n  keys: string[];\n  key: string;\n  operator: string;\n  value: string;\n  values: string[];\n}\n\nexport interface Props<TQuery extends DataQuery = DataQuery, TOptions extends DataSourceJsonData = DataSourceJsonData> {\n  datasource: DataSourceApi<TQuery, TOptions>;\n  onPairsChanged: (pairs: KeyValuePair[]) => void;\n  extendedOptions?: any;\n}\n\nexport interface State {\n  pairs: KeyValuePair[];\n}\n\nexport class AdHocFilterField<\n  TQuery extends DataQuery = DataQuery,\n  TOptions extends DataSourceJsonData = DataSourceJsonData\n> extends React.PureComponent<Props<TQuery, TOptions>, State> {\n  state: State = { pairs: [] };\n\n  componentDidUpdate(prevProps: Props) {\n    if (_.isEqual(prevProps.extendedOptions, this.props.extendedOptions) === false) {\n      const pairs: any[] = [];\n\n      this.setState({ pairs }, () => this.props.onPairsChanged(pairs));\n    }\n  }\n\n  loadTagKeys = async () => {\n    const { datasource, extendedOptions } = this.props;\n    const options = extendedOptions || {};\n    const tagKeys = datasource.getTagKeys ? await datasource.getTagKeys(options) : [];\n    const keys = tagKeys.map(tagKey => tagKey.text);\n\n    return keys;\n  };\n\n  loadTagValues = async (key: string) => {\n    const { datasource, extendedOptions } = this.props;\n    const options = extendedOptions || {};\n    const tagValues = datasource.getTagValues ? await datasource.getTagValues({ ...options, key }) : [];\n    const values = tagValues.map(tagValue => tagValue.text);\n\n    return values;\n  };\n\n  updatePairs(pairs: KeyValuePair[], index: number, pair: Partial<KeyValuePair>) {\n    if (pairs.length === 0) {\n      return [\n        {\n          key: pair.key || '',\n          keys: pair.keys || [],\n          operator: pair.operator || '',\n          value: pair.value || '',\n          values: pair.values || [],\n        },\n      ];\n    }\n\n    const newPairs: KeyValuePair[] = [];\n    for (let pairIndex = 0; pairIndex < pairs.length; pairIndex++) {\n      const newPair = pairs[pairIndex];\n      if (index === pairIndex) {\n        newPairs.push({\n          ...newPair,\n          key: pair.key || newPair.key,\n          value: pair.value || newPair.value,\n          operator: pair.operator || newPair.operator,\n          keys: pair.keys || newPair.keys,\n          values: pair.values || newPair.values,\n        });\n        continue;\n      }\n\n      newPairs.push(newPair);\n    }\n\n    return newPairs;\n  }\n\n  onKeyChanged = (index: number) => async (key: string) => {\n    if (key !== DEFAULT_REMOVE_FILTER_VALUE) {\n      const { onPairsChanged } = this.props;\n      const values = await this.loadTagValues(key);\n      const pairs = this.updatePairs(this.state.pairs, index, { key, values });\n\n      this.setState({ pairs }, () => onPairsChanged(pairs));\n    } else {\n      this.onRemoveFilter(index);\n    }\n  };\n\n  onValueChanged = (index: number) => (value: string) => {\n    const pairs = this.updatePairs(this.state.pairs, index, { value });\n\n    this.setState({ pairs }, () => this.props.onPairsChanged(pairs));\n  };\n\n  onOperatorChanged = (index: number) => (operator: string) => {\n    const pairs = this.updatePairs(this.state.pairs, index, { operator });\n\n    this.setState({ pairs }, () => this.props.onPairsChanged(pairs));\n  };\n\n  onAddFilter = async () => {\n    const keys = await this.loadTagKeys();\n    const pairs = this.state.pairs.concat(this.updatePairs([], 0, { keys }));\n\n    this.setState({ pairs }, () => this.props.onPairsChanged(pairs));\n  };\n\n  onRemoveFilter = async (index: number) => {\n    const pairs = this.state.pairs.reduce((allPairs, pair, pairIndex) => {\n      if (pairIndex === index) {\n        return allPairs;\n      }\n      return allPairs.concat(pair);\n    }, []);\n\n    this.setState({ pairs });\n  };\n\n  render() {\n    const { pairs } = this.state;\n    return (\n      <>\n        {pairs.length < 1 && addFilterButton(this.onAddFilter)}\n        {pairs.map((pair, index) => {\n          const adHocKey = `adhoc-filter-${index}-${pair.key}-${pair.value}`;\n          return (\n            <div className=\"align-items-center flex-grow-1\" key={adHocKey}>\n              <AdHocFilter\n                keys={[DEFAULT_REMOVE_FILTER_VALUE].concat(pair.keys)}\n                values={pair.values}\n                initialKey={pair.key}\n                initialOperator={pair.operator}\n                initialValue={pair.value}\n                onKeyChanged={this.onKeyChanged(index)}\n                onOperatorChanged={this.onOperatorChanged(index)}\n                onValueChanged={this.onValueChanged(index)}\n              />\n              {index < pairs.length - 1 && <span>&nbsp;AND&nbsp;</span>}\n              {index === pairs.length - 1 && addFilterButton(this.onAddFilter)}\n            </div>\n          );\n        })}\n      </>\n    );\n  }\n}\n","import React from 'react';\nimport { ExploreQueryFieldProps } from '@grafana/data';\n// @ts-ignore\nimport Cascader from 'rc-cascader';\n\nimport InfluxQueryModel from '../influx_query_model';\nimport { AdHocFilterField, KeyValuePair } from 'app/features/explore/AdHocFilterField';\nimport { TemplateSrv } from 'app/features/templating/template_srv';\nimport InfluxDatasource from '../datasource';\nimport { InfluxQueryBuilder } from '../query_builder';\nimport { InfluxQuery, InfluxOptions } from '../types';\nimport { CascaderOption } from '../../loki/components/LokiQueryFieldForm';\n\nexport interface Props extends ExploreQueryFieldProps<InfluxDatasource, InfluxQuery, InfluxOptions> {}\n\nexport interface State {\n  measurements: CascaderOption[];\n  measurement: string;\n  field: string;\n  error: string;\n}\n\ninterface ChooserOptions {\n  measurement: string;\n  field: string;\n  error: string;\n}\n\n// Helper function for determining if a collection of pairs are valid\n// where a valid pair is either fully defined, or not defined at all, but not partially defined\nexport function pairsAreValid(pairs: KeyValuePair[]) {\n  return (\n    !pairs ||\n    pairs.every(pair => {\n      const allDefined = !!(pair.key && pair.operator && pair.value);\n      const allEmpty = pair.key === undefined && pair.operator === undefined && pair.value === undefined;\n      return allDefined || allEmpty;\n    })\n  );\n}\n\nfunction getChooserText({ measurement, field, error }: ChooserOptions): string {\n  if (error) {\n    return '(No measurement found)';\n  }\n  if (measurement) {\n    return `Measurements (${measurement}/${field})`;\n  }\n  return 'Measurements';\n}\n\nexport class InfluxLogsQueryField extends React.PureComponent<Props, State> {\n  templateSrv: TemplateSrv = new TemplateSrv();\n  state: State = { measurements: [], measurement: null, field: null, error: null };\n\n  async componentDidMount() {\n    const { datasource } = this.props;\n    try {\n      const queryBuilder = new InfluxQueryBuilder({ measurement: '', tags: [] }, datasource.database);\n      const measureMentsQuery = queryBuilder.buildExploreQuery('MEASUREMENTS');\n      const influxMeasurements = await datasource.metricFindQuery(measureMentsQuery);\n\n      const measurements = [];\n      for (let index = 0; index < influxMeasurements.length; index++) {\n        const measurementObj = influxMeasurements[index];\n        const queryBuilder = new InfluxQueryBuilder(\n          { measurement: measurementObj.text, tags: [] },\n          datasource.database\n        );\n        const fieldsQuery = queryBuilder.buildExploreQuery('FIELDS');\n        const influxFields = await datasource.metricFindQuery(fieldsQuery);\n        const fields: any[] = influxFields.map(\n          (field: any): any => ({\n            label: field.text,\n            value: field.text,\n            children: [],\n          })\n        );\n        measurements.push({\n          label: measurementObj.text,\n          value: measurementObj.text,\n          children: fields,\n        });\n      }\n      this.setState({ measurements });\n    } catch (error) {\n      const message = error && error.message ? error.message : error;\n      this.setState({ error: message });\n    }\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    if (prevProps.query.measurement && !this.props.query.measurement) {\n      this.setState({ measurement: null, field: null });\n    }\n  }\n\n  onMeasurementsChange = async (values: string[]) => {\n    const { query } = this.props;\n    const measurement = values[0];\n    const field = values[1];\n\n    this.setState({ measurement, field }, () => {\n      this.onPairsChanged((query as any).tags);\n    });\n  };\n\n  onPairsChanged = (pairs: KeyValuePair[]) => {\n    const { query } = this.props;\n    const { measurement, field } = this.state;\n    const queryModel = new InfluxQueryModel(\n      {\n        ...query,\n        resultFormat: 'table',\n        groupBy: [],\n        select: [[{ type: 'field', params: [field] }]],\n        tags: pairs,\n        limit: '1000',\n        measurement,\n      },\n      this.templateSrv\n    );\n\n    this.props.onChange(queryModel.target);\n\n    // Only run the query if measurement & field are set, and there are no invalid pairs\n    if (measurement && field && pairsAreValid(pairs)) {\n      this.props.onRunQuery();\n    }\n  };\n\n  render() {\n    const { datasource } = this.props;\n    const { measurements, measurement, field, error } = this.state;\n    const cascadeText = getChooserText({ measurement, field, error });\n    const hasMeasurement = measurements && measurements.length > 0;\n\n    return (\n      <div className=\"gf-form-inline gf-form-inline--nowrap\">\n        <div className=\"gf-form flex-shrink-0\">\n          <Cascader\n            options={measurements}\n            value={[measurement, field]}\n            onChange={this.onMeasurementsChange}\n            expandIcon={null}\n          >\n            <button className=\"gf-form-label gf-form-label--btn\" disabled={!hasMeasurement}>\n              {cascadeText} <i className=\"fa fa-caret-down\" />\n            </button>\n          </Cascader>\n        </div>\n        <div className=\"flex-shrink-1 flex-flow-column-nowrap\">\n          {measurement && (\n            <AdHocFilterField\n              onPairsChanged={this.onPairsChanged}\n              datasource={datasource}\n              extendedOptions={{ measurement }}\n            />\n          )}\n          {error ? (\n            <span className=\"gf-form-label gf-form-label--transparent gf-form-label--error m-l-2\">{error}</span>\n          ) : null}\n        </div>\n      </div>\n    );\n  }\n}\n","import React from 'react';\n\nconst CHEAT_SHEET_ITEMS = [\n  {\n    title: 'Getting started',\n    label:\n      'Start by selecting a measurement and field from the dropdown above. You can then use the tag selector to further narrow your search.',\n  },\n];\n\nexport default (props: any) => (\n  <div>\n    <h2>InfluxDB Cheat Sheet</h2>\n    {CHEAT_SHEET_ITEMS.map(item => (\n      <div className=\"cheat-sheet-item\" key={item.title}>\n        <div className=\"cheat-sheet-item__title\">{item.title}</div>\n        <div className=\"cheat-sheet-item__label\">{item.label}</div>\n      </div>\n    ))}\n  </div>\n);\n","import React, { PureComponent } from 'react';\nimport { ExploreStartPageProps } from '@grafana/data';\nimport InfluxCheatSheet from './InfluxCheatSheet';\n\nexport default class InfluxStartPage extends PureComponent<ExploreStartPageProps> {\n  render() {\n    return <InfluxCheatSheet onClickExample={this.props.onClickExample} />;\n  }\n}\n","import InfluxDatasource from './datasource';\nimport { InfluxQueryCtrl } from './query_ctrl';\nimport { InfluxLogsQueryField } from './components/InfluxLogsQueryField';\nimport InfluxStartPage from './components/InfluxStartPage';\n\nimport {\n  createChangeHandler,\n  createResetHandler,\n  PasswordFieldEnum,\n} from '../../../features/datasources/utils/passwordHandlers';\nimport { DataSourcePlugin } from '@grafana/data';\n\nclass InfluxConfigCtrl {\n  static templateUrl = 'partials/config.html';\n  current: any;\n  onPasswordReset: ReturnType<typeof createResetHandler>;\n  onPasswordChange: ReturnType<typeof createChangeHandler>;\n\n  constructor() {\n    this.onPasswordReset = createResetHandler(this, PasswordFieldEnum.Password);\n    this.onPasswordChange = createChangeHandler(this, PasswordFieldEnum.Password);\n    this.current.jsonData.httpMode = this.current.jsonData.httpMode || 'GET';\n  }\n\n  httpMode = [{ name: 'GET', value: 'GET' }, { name: 'POST', value: 'POST' }];\n}\n\nclass InfluxAnnotationsQueryCtrl {\n  static templateUrl = 'partials/annotations.editor.html';\n}\n\nexport const plugin = new DataSourcePlugin(InfluxDatasource)\n  .setConfigCtrl(InfluxConfigCtrl)\n  .setQueryCtrl(InfluxQueryCtrl)\n  .setAnnotationQueryCtrl(InfluxAnnotationsQueryCtrl)\n  .setExploreLogsQueryField(InfluxLogsQueryField)\n  .setExploreStartPage(InfluxStartPage);\n"],"sourceRoot":""}