{"version":3,"sources":["webpack:///./public/app/core/utils/version.ts","webpack:///./public/app/plugins/datasource/graphite/gfunc.ts","webpack:///./public/app/plugins/datasource/graphite/types.ts","webpack:///./public/app/plugins/datasource/graphite/datasource.ts","webpack:///./public/app/plugins/datasource/graphite/add_graphite_func.ts","webpack:///./public/app/plugins/datasource/graphite/func_editor.ts","webpack:///./public/app/plugins/datasource/graphite/lexer.ts","webpack:///./public/app/plugins/datasource/graphite/parser.ts","webpack:///./public/app/plugins/datasource/graphite/graphite_query.ts","webpack:///./public/app/plugins/datasource/graphite/query_ctrl.ts","webpack:///./public/app/plugins/datasource/graphite/config_ctrl.ts","webpack:///./public/app/plugins/datasource/graphite/module.ts"],"names":["versionPattern","SemVersion","version","match","exec","this","major","Number","minor","patch","meta","prototype","isGtOrEq","compared","i","comparable","length","isValid","lodash_default","a","isNumber","get","enumerable","configurable","isVersionGtOrEq","b","version_SemVersion","gfunc_index","addFuncDef","funcDef","params","defaultParams","name","shortName","optionalSeriesRefArgs","type","optional","multiple","isVersionRelatedFunction","obj","graphiteVersion","category","options","fake","FuncInstance","def","withDefaultParams","slice","updateText","render","metricExp","replaceVariables","_this","str","parameters","map","value","index","paramType","last","includes","valueInterpolated","isString","isFinite","toString","pop","unshift","join","_hasMultipleParamsInString","strValue","indexOf","updateParam","each","split","partVal","idx","trim","splice","text","getFuncDef","message","GraphiteType","gfunc","createFuncInstance","gfunc_FuncInstance","getFuncDefs","funcs","forEach","assign","filter","param","rawDefs","funcDefs","funcName","group","description","replace","func","test","required","shift","rawParam","undefined","default","push","suggestions","datasource_GraphiteDatasource","GraphiteDatasource","instanceSettings","$q","backendSrv","templateSrv","funcDefsPromise","basicAuth","url","jsonData","isMetricTank","graphiteType","Metrictank","supportsTags","cacheTimeout","withCredentials","_seriesRefLetters","$inject","getQueryOptionsInfo","tslib_es6","Promise","httpOptions","_a","from","translateTime","rangeRaw","timezone","until","to","targets","format","maxDataPoints","buildGraphiteParams","graphOptions","scopedVars","when","data","method","headers","Content-Type","addTracingHeaders","panelId","doGraphiteRequest","then","convertResponseToDataFrames","dashboardId","result","series","isArray","s","y","datapoints","frame","Object","src","metrictank","metrictankReq","parseTags","tagString","tags","interpolateVariablesInQueries","queries","expandedQueries","query","datasource","target","annotationQuery","annotation","graphiteQuery","list","target_1","datapoint","time","title","events","range","results","e","tags_1","what","err","reject","targetContainsTemplate","variableExists","date","roundUp","substring","parse","add","subtract","unix","metricFindQuery","optionalOptions","interpolatedQuery","variable","wildcardChar","matches","expressions","exprRegex","limit","getTagValuesAutoComplete","getTagsAutoComplete","requestId","metric","expandable","getTags","tag","id","getTagValues","values","tagPrefix","expr","expression","valuePrefix","getVersion","catch","waitForFuncDefsLoaded","resolve","status","parseFuncDefs","console","log","testDatasource","Authorization","inspect","datasourceRequest","targetValue","graphiteOptions","cleanOptions","regex","intervalFormatFixRegex","hasTargets","fixIntervalFormat","refId","nestedSeriesRegexReplacer","g1","hide","encodeURIComponent","key","graphiteAddFunc","$compile","$scope","elem","ctrl","$input","jquery_js_exposed_default","$button","appendTo","allFunctions","sort","functionMenu","categories","click","sortBy","submenu","createFunctionDropDownMenu","attr","typeahead","source","toLowerCase","find","$apply","addFunction","trigger","show","focus","keyup","toggleClass","val","blur","removeClass","contents","drop","destroy","label","shortDesc","contentElement","document","createElement","__webpack_require__","t","bind","sent","innerHTML","rst2html","drop_default","content","attachment","on","cleanUpDrop","$on","graphiteFuncEditor","paramTemplate","$funcLink","scheduledRelink","paramCountAtLink","cancelBlur","clickFuncParam","paramIndex","$link","$comma","prev","next","select","lookup","paramDef","switchToLink","inputElem","clearTimeout","newValue","html","highlightVariablesAsHtml","setTimeout","relink","targetChanged","hasClass","addClass","inputBlur","inputKeyPress","which","inputKeyDown","style","width","addElementsAndCompile","defParams","clone","lastParam","paramValue","hasValue","$paramLink","partial","keypress","$element","process","addTypeahead","children","remove","added","first","handleRemoveFunction","removeFunction","handleMoveLeft","moveFunction","handleMoveRight","directive","core_module","unicodeLetterTable","lexer_i","identifierStartTable","Lexer","input","char","peek","charAt","skip","tokenize","token","scanStringLiteral","scanPunctuator","scanNumericLiteral","scanIdentifier","scanTemplateSequence","pos","code","isHexDigit","readUnicodeEscapeSequence","ch1","ch2","ch3","ch4","isUnicodeLetter","parseInt","getIdentifierStart","chr","charCodeAt","getIdentifierPart","identifierPartTable","bad","isDecimalDigit","isOctalDigit","isIdentifierStart","ch","isMalformed","base","isPunctuator","quote","isUnclosed","Parser","lexer","lexer_Lexer","tokens","getAst","start","functionCall","metricExpression","curlyBraceSegment","curlySegment","consumeToken","errorMark","metricSegment","curly","parts","node","segments","segment","functionParameters","boolExpression","numericLiteral","seriesRefExpression","stringLiteral","concat","parseFloat","currentToken","matchToken","token1","token2","GraphiteQuery","parseTarget","removeTagValue","functions","seriesByTagUsed","error","textEditor","astNode","parser_Parser","parseTargetRecursive","checkOtherSegmentsIndex","getSegmentPathUpTo","arr","reduce","innerFunc_1","hidden","splitSeriesByTagParams","getSeriesByTagFuncIndex","addFunctionParameter","updateSegmentValue","addSelectMetricSegment","newFunc","without","offset","move","updateModelTarget","metricPath","_b","_c","done","return","call","e_1","updateRenderedTarget","targetsByRefId","keyBy","nestedSeriesRefRegex","targetWithNestedQueries","count","refCount","countTargetRefs","updated","targetFull","flatten","tagPattern","operator","findIndex","getSeriesByTagFunc","seriesByTagFuncIndex","addTag","newTagParam","renderTagString","removeTag","updateTag","tagIndex","renderTagExpressions","excludeIndex","compact","tagExpr","app_events","GRAPHITE_TAG_OPERATORS","TAG_PREFIX","_super","GraphiteQueryCtrl","$injector","uiSegmentSrv","$timeout","paused","queryModel","graphite_query","buildSegments","toggleEditorMode","newSegment","checkOtherSegments","fixTagSegments","newSelectMetric","fromIndex","path","emit","alertError","setSegmentFocus","segmentIndex","getAltSegments","prefix","panelCtrl","altSegments","eachRight","panel","variables","removeTaggedEntry","addAltTagSegments","getTagsAsSegments","tagSegments","apply","segmentValueChanged","pause","addSeriesByTagFunc","spliceSegments","emptySegments","targetTextChanged","refresh","oldTarget","smartlyHandleNewAliasByNode","tagParam","getAllTags","altTags","mapToDropdownOptions","tagExpressions","getTagOperators","getAllTagValues","tagKey","altValues","tagChanged","addNewTag","newTag","addTagSegments","newPlusButton","showDelimiter","unpause","getCollapsedText","templateUrl","GraphiteConfigCtrl","datasourceSrv","graphiteVersions","current","Default","autoDetectGraphiteVersion","graphiteTypes","keys","ds","d","__webpack_exports__","AnnotationsQueryCtrl","query_ctrl_GraphiteQueryCtrl","config_ctrl_GraphiteConfigCtrl"],"mappings":"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IAiNP8N,QD9GW,EAAA+B,UAAU,kBAAOzG,GE5IN0G,EAAA,EAAAD,UAAA,qBAAArD,WAcrBuD,EAAG,CACH,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,IACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OAEI,OAEN,UAEgB,KACX,EAAAC,EAAW,IAAIA,MACVA,MACL,IAAKA,GAAW,IACX,KAANA,GACM,MAANA,GACM,MAANA,GACAA,GAAM,IAAMA,GAAI,IACV,KAANA,GACM,KAANA,GACM,KAANA,GACM,KAANA,GACM,KAANA,GACM,KAANA,GACM,KAANA,GACM,KAANA,GACH,KAAAA,GAEwB,KAAnBA,GAENA,GAAA,IAAAA,GAAA,UAMiBC,IACC,oBACTC,EAAIzI,GACVrN,KAAA+V,MAAA1I,EAEDr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","file":"graphitePlugin.fabf58cbd84a6ac3523b.js","sourcesContent":["import _ from 'lodash';\n\nconst versionPattern = /^(\\d+)(?:\\.(\\d+))?(?:\\.(\\d+))?(?:-([0-9A-Za-z\\.]+))?/;\n\nexport class SemVersion {\n  major: number;\n  minor: number;\n  patch: number;\n  meta: string;\n\n  constructor(version: string) {\n    const match = versionPattern.exec(version);\n    if (match) {\n      this.major = Number(match[1]);\n      this.minor = Number(match[2] || 0);\n      this.patch = Number(match[3] || 0);\n      this.meta = match[4];\n    }\n  }\n\n  isGtOrEq(version: string): boolean {\n    const compared = new SemVersion(version);\n\n    for (let i = 0; i < this.comparable.length; ++i) {\n      if (this.comparable[i] > compared.comparable[i]) {\n        return true;\n      }\n      if (this.comparable[i] < compared.comparable[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  isValid(): boolean {\n    return _.isNumber(this.major);\n  }\n\n  get comparable() {\n    return [this.major, this.minor, this.patch];\n  }\n}\n\nexport function isVersionGtOrEq(a: string, b: string): boolean {\n  const aSemver = new SemVersion(a);\n  return aSemver.isGtOrEq(b);\n}\n","import _ from 'lodash';\nimport { isVersionGtOrEq } from 'app/core/utils/version';\nimport { InterpolateFunction } from '@grafana/data';\n\nconst index: any = {};\n\nexport interface FuncDef {\n  name: any;\n  category?: string;\n  params?: any;\n  defaultParams?: any;\n  shortName?: any;\n  fake?: boolean;\n  version?: string;\n  description?: string;\n}\n\nfunction addFuncDef(funcDef: FuncDef) {\n  funcDef.params = funcDef.params || [];\n  funcDef.defaultParams = funcDef.defaultParams || [];\n\n  index[funcDef.name] = funcDef;\n  if (funcDef.shortName) {\n    index[funcDef.shortName] = funcDef;\n  }\n}\n\nconst optionalSeriesRefArgs = [{ name: 'other', type: 'value_or_series', optional: true, multiple: true }];\n\naddFuncDef({\n  name: 'scaleToSeconds',\n  category: 'Transform',\n  params: [{ name: 'seconds', type: 'int' }],\n  defaultParams: [1],\n});\n\naddFuncDef({\n  name: 'perSecond',\n  category: 'Transform',\n  params: [{ name: 'max value', type: 'int', optional: true }],\n  defaultParams: [],\n});\n\naddFuncDef({\n  name: 'holtWintersForecast',\n  category: 'Calculate',\n});\n\naddFuncDef({\n  name: 'holtWintersConfidenceBands',\n  category: 'Calculate',\n  params: [{ name: 'delta', type: 'int' }],\n  defaultParams: [3],\n});\n\naddFuncDef({\n  name: 'holtWintersAberration',\n  category: 'Calculate',\n  params: [{ name: 'delta', type: 'int' }],\n  defaultParams: [3],\n});\n\naddFuncDef({\n  name: 'nPercentile',\n  category: 'Calculate',\n  params: [{ name: 'Nth percentile', type: 'int' }],\n  defaultParams: [95],\n});\n\naddFuncDef({\n  name: 'diffSeries',\n  params: optionalSeriesRefArgs,\n  defaultParams: ['#A'],\n  category: 'Combine',\n});\n\naddFuncDef({\n  name: 'stddevSeries',\n  params: optionalSeriesRefArgs,\n  defaultParams: [''],\n  category: 'Combine',\n});\n\naddFuncDef({\n  name: 'divideSeries',\n  params: optionalSeriesRefArgs,\n  defaultParams: ['#A'],\n  category: 'Combine',\n});\n\naddFuncDef({\n  name: 'multiplySeries',\n  params: optionalSeriesRefArgs,\n  defaultParams: ['#A'],\n  category: 'Combine',\n});\n\naddFuncDef({\n  name: 'asPercent',\n  params: optionalSeriesRefArgs,\n  defaultParams: ['#A'],\n  category: 'Combine',\n});\n\naddFuncDef({\n  name: 'group',\n  params: optionalSeriesRefArgs,\n  defaultParams: ['#A', '#B'],\n  category: 'Combine',\n});\n\naddFuncDef({\n  name: 'sumSeries',\n  shortName: 'sum',\n  category: 'Combine',\n  params: optionalSeriesRefArgs,\n  defaultParams: [''],\n});\n\naddFuncDef({\n  name: 'averageSeries',\n  shortName: 'avg',\n  category: 'Combine',\n  params: optionalSeriesRefArgs,\n  defaultParams: [''],\n});\n\naddFuncDef({\n  name: 'rangeOfSeries',\n  category: 'Combine',\n});\n\naddFuncDef({\n  name: 'percentileOfSeries',\n  category: 'Combine',\n  params: [{ name: 'n', type: 'int' }, { name: 'interpolate', type: 'boolean', options: ['true', 'false'] }],\n  defaultParams: [95, 'false'],\n});\n\naddFuncDef({\n  name: 'sumSeriesWithWildcards',\n  category: 'Combine',\n  params: [{ name: 'node', type: 'int', multiple: true }],\n  defaultParams: [3],\n});\n\naddFuncDef({\n  name: 'maxSeries',\n  shortName: 'max',\n  category: 'Combine',\n});\n\naddFuncDef({\n  name: 'minSeries',\n  shortName: 'min',\n  category: 'Combine',\n});\n\naddFuncDef({\n  name: 'averageSeriesWithWildcards',\n  category: 'Combine',\n  params: [{ name: 'node', type: 'int', multiple: true }],\n  defaultParams: [3],\n});\n\naddFuncDef({\n  name: 'alias',\n  category: 'Alias',\n  params: [{ name: 'alias', type: 'string' }],\n  defaultParams: ['alias'],\n});\n\naddFuncDef({\n  name: 'aliasSub',\n  category: 'Alias',\n  params: [{ name: 'search', type: 'string' }, { name: 'replace', type: 'string' }],\n  defaultParams: ['', '\\\\1'],\n});\n\naddFuncDef({\n  name: 'consolidateBy',\n  category: 'Special',\n  params: [\n    {\n      name: 'function',\n      type: 'string',\n      options: ['sum', 'average', 'min', 'max'],\n    },\n  ],\n  defaultParams: ['max'],\n});\n\naddFuncDef({\n  name: 'cumulative',\n  category: 'Special',\n  params: [],\n  defaultParams: [],\n});\n\naddFuncDef({\n  name: 'groupByNode',\n  category: 'Combine',\n  params: [\n    {\n      name: 'node',\n      type: 'int',\n      options: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12],\n    },\n    {\n      name: 'function',\n      type: 'string',\n      options: ['sum', 'avg', 'maxSeries'],\n    },\n  ],\n  defaultParams: [3, 'sum'],\n});\n\naddFuncDef({\n  name: 'aliasByNode',\n  category: 'Alias',\n  params: [\n    {\n      name: 'node',\n      type: 'int',\n      options: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12],\n      multiple: true,\n    },\n  ],\n  defaultParams: [3],\n});\n\naddFuncDef({\n  name: 'substr',\n  category: 'Special',\n  params: [\n    {\n      name: 'start',\n      type: 'int',\n      options: [-6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12],\n    },\n    {\n      name: 'stop',\n      type: 'int',\n      options: [-6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12],\n    },\n  ],\n  defaultParams: [0, 0],\n});\n\naddFuncDef({\n  name: 'sortByName',\n  category: 'Sorting',\n  params: [\n    {\n      name: 'natural',\n      type: 'boolean',\n      options: ['true', 'false'],\n      optional: true,\n    },\n  ],\n  defaultParams: ['false'],\n});\n\naddFuncDef({\n  name: 'sortByMaxima',\n  category: 'Sorting',\n});\n\naddFuncDef({\n  name: 'sortByMinima',\n  category: 'Sorting',\n});\n\naddFuncDef({\n  name: 'sortByTotal',\n  category: 'Sorting',\n});\n\naddFuncDef({\n  name: 'aliasByMetric',\n  category: 'Alias',\n});\n\naddFuncDef({\n  name: 'randomWalk',\n  fake: true,\n  category: 'Special',\n  params: [{ name: 'name', type: 'string' }],\n  defaultParams: ['randomWalk'],\n});\n\naddFuncDef({\n  name: 'countSeries',\n  category: 'Combine',\n});\n\naddFuncDef({\n  name: 'constantLine',\n  category: 'Special',\n  params: [{ name: 'value', type: 'int' }],\n  defaultParams: [10],\n});\n\naddFuncDef({\n  name: 'cactiStyle',\n  category: 'Special',\n});\n\naddFuncDef({\n  name: 'keepLastValue',\n  category: 'Transform',\n  params: [{ name: 'n', type: 'int' }],\n  defaultParams: [100],\n});\n\naddFuncDef({\n  name: 'changed',\n  category: 'Special',\n  params: [],\n  defaultParams: [],\n});\n\naddFuncDef({\n  name: 'scale',\n  category: 'Transform',\n  params: [{ name: 'factor', type: 'int' }],\n  defaultParams: [1],\n});\n\naddFuncDef({\n  name: 'offset',\n  category: 'Transform',\n  params: [{ name: 'amount', type: 'int' }],\n  defaultParams: [10],\n});\n\naddFuncDef({\n  name: 'transformNull',\n  category: 'Transform',\n  params: [{ name: 'amount', type: 'int' }],\n  defaultParams: [0],\n});\n\naddFuncDef({\n  name: 'integral',\n  category: 'Transform',\n});\n\naddFuncDef({\n  name: 'derivative',\n  category: 'Transform',\n});\n\naddFuncDef({\n  name: 'nonNegativeDerivative',\n  category: 'Transform',\n  params: [{ name: 'max value or 0', type: 'int', optional: true }],\n  defaultParams: [''],\n});\n\naddFuncDef({\n  name: 'timeShift',\n  category: 'Transform',\n  params: [\n    {\n      name: 'amount',\n      type: 'select',\n      options: ['1h', '6h', '12h', '1d', '2d', '7d', '14d', '30d'],\n    },\n  ],\n  defaultParams: ['1d'],\n});\n\naddFuncDef({\n  name: 'timeStack',\n  category: 'Transform',\n  params: [\n    {\n      name: 'timeShiftUnit',\n      type: 'select',\n      options: ['1h', '6h', '12h', '1d', '2d', '7d', '14d', '30d'],\n    },\n    { name: 'timeShiftStart', type: 'int' },\n    { name: 'timeShiftEnd', type: 'int' },\n  ],\n  defaultParams: ['1d', 0, 7],\n});\n\naddFuncDef({\n  name: 'summarize',\n  category: 'Transform',\n  params: [\n    { name: 'interval', type: 'string' },\n    {\n      name: 'func',\n      type: 'select',\n      options: ['sum', 'avg', 'min', 'max', 'last'],\n    },\n    {\n      name: 'alignToFrom',\n      type: 'boolean',\n      optional: true,\n      options: ['false', 'true'],\n    },\n  ],\n  defaultParams: ['1h', 'sum', 'false'],\n});\n\naddFuncDef({\n  name: 'smartSummarize',\n  category: 'Transform',\n  params: [\n    { name: 'interval', type: 'string' },\n    {\n      name: 'func',\n      type: 'select',\n      options: ['sum', 'avg', 'min', 'max', 'last'],\n    },\n  ],\n  defaultParams: ['1h', 'sum'],\n});\n\naddFuncDef({\n  name: 'absolute',\n  category: 'Transform',\n});\n\naddFuncDef({\n  name: 'hitcount',\n  category: 'Transform',\n  params: [{ name: 'interval', type: 'string' }],\n  defaultParams: ['10s'],\n});\n\naddFuncDef({\n  name: 'log',\n  category: 'Transform',\n  params: [{ name: 'base', type: 'int' }],\n  defaultParams: ['10'],\n});\n\naddFuncDef({\n  name: 'averageAbove',\n  category: 'Filter Series',\n  params: [{ name: 'n', type: 'int' }],\n  defaultParams: [25],\n});\n\naddFuncDef({\n  name: 'averageBelow',\n  category: 'Filter Series',\n  params: [{ name: 'n', type: 'int' }],\n  defaultParams: [25],\n});\n\naddFuncDef({\n  name: 'currentAbove',\n  category: 'Filter Series',\n  params: [{ name: 'n', type: 'int' }],\n  defaultParams: [25],\n});\n\naddFuncDef({\n  name: 'currentBelow',\n  category: 'Filter Series',\n  params: [{ name: 'n', type: 'int' }],\n  defaultParams: [25],\n});\n\naddFuncDef({\n  name: 'maximumAbove',\n  category: 'Filter Series',\n  params: [{ name: 'value', type: 'int' }],\n  defaultParams: [0],\n});\n\naddFuncDef({\n  name: 'maximumBelow',\n  category: 'Filter Series',\n  params: [{ name: 'value', type: 'int' }],\n  defaultParams: [0],\n});\n\naddFuncDef({\n  name: 'minimumAbove',\n  category: 'Filter Series',\n  params: [{ name: 'value', type: 'int' }],\n  defaultParams: [0],\n});\n\naddFuncDef({\n  name: 'minimumBelow',\n  category: 'Filter Series',\n  params: [{ name: 'value', type: 'int' }],\n  defaultParams: [0],\n});\n\naddFuncDef({\n  name: 'limit',\n  category: 'Filter Series',\n  params: [{ name: 'n', type: 'int' }],\n  defaultParams: [5],\n});\n\naddFuncDef({\n  name: 'mostDeviant',\n  category: 'Filter Series',\n  params: [{ name: 'n', type: 'int' }],\n  defaultParams: [10],\n});\n\naddFuncDef({\n  name: 'exclude',\n  category: 'Filter Series',\n  params: [{ name: 'exclude', type: 'string' }],\n  defaultParams: ['exclude'],\n});\n\naddFuncDef({\n  name: 'highestCurrent',\n  category: 'Filter Series',\n  params: [{ name: 'count', type: 'int' }],\n  defaultParams: [5],\n});\n\naddFuncDef({\n  name: 'highestMax',\n  category: 'Filter Series',\n  params: [{ name: 'count', type: 'int' }],\n  defaultParams: [5],\n});\n\naddFuncDef({\n  name: 'lowestCurrent',\n  category: 'Filter Series',\n  params: [{ name: 'count', type: 'int' }],\n  defaultParams: [5],\n});\n\naddFuncDef({\n  name: 'movingAverage',\n  category: 'Calculate',\n  params: [\n    {\n      name: 'windowSize',\n      type: 'int_or_interval',\n      options: ['5', '7', '10', '5min', '10min', '30min', '1hour'],\n    },\n  ],\n  defaultParams: [10],\n});\n\naddFuncDef({\n  name: 'movingMedian',\n  category: 'Calculate',\n  params: [\n    {\n      name: 'windowSize',\n      type: 'int_or_interval',\n      options: ['5', '7', '10', '5min', '10min', '30min', '1hour'],\n    },\n  ],\n  defaultParams: ['5'],\n});\n\naddFuncDef({\n  name: 'stdev',\n  category: 'Calculate',\n  params: [{ name: 'n', type: 'int' }, { name: 'tolerance', type: 'int' }],\n  defaultParams: [5, 0.1],\n});\n\naddFuncDef({\n  name: 'highestAverage',\n  category: 'Filter Series',\n  params: [{ name: 'count', type: 'int' }],\n  defaultParams: [5],\n});\n\naddFuncDef({\n  name: 'lowestAverage',\n  category: 'Filter Series',\n  params: [{ name: 'count', type: 'int' }],\n  defaultParams: [5],\n});\n\naddFuncDef({\n  name: 'removeAbovePercentile',\n  category: 'Filter Data',\n  params: [{ name: 'n', type: 'int' }],\n  defaultParams: [5],\n});\n\naddFuncDef({\n  name: 'removeAboveValue',\n  category: 'Filter Data',\n  params: [{ name: 'n', type: 'int' }],\n  defaultParams: [5],\n});\n\naddFuncDef({\n  name: 'removeBelowPercentile',\n  category: 'Filter Data',\n  params: [{ name: 'n', type: 'int' }],\n  defaultParams: [5],\n});\n\naddFuncDef({\n  name: 'removeBelowValue',\n  category: 'Filter Data',\n  params: [{ name: 'n', type: 'int' }],\n  defaultParams: [5],\n});\n\naddFuncDef({\n  name: 'useSeriesAbove',\n  category: 'Filter Series',\n  params: [{ name: 'value', type: 'int' }, { name: 'search', type: 'string' }, { name: 'replace', type: 'string' }],\n  defaultParams: [0, 'search', 'replace'],\n});\n\n////////////////////\n// Graphite 1.0.x //\n////////////////////\n\naddFuncDef({\n  name: 'aggregateLine',\n  category: 'Calculate',\n  params: [\n    {\n      name: 'func',\n      type: 'select',\n      options: ['sum', 'avg', 'min', 'max', 'last'],\n    },\n  ],\n  defaultParams: ['avg'],\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'averageOutsidePercentile',\n  category: 'Filter Series',\n  params: [{ name: 'n', type: 'int' }],\n  defaultParams: [95],\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'delay',\n  category: 'Transform',\n  params: [{ name: 'steps', type: 'int' }],\n  defaultParams: [1],\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'exponentialMovingAverage',\n  category: 'Calculate',\n  params: [\n    {\n      name: 'windowSize',\n      type: 'int_or_interval',\n      options: ['5', '7', '10', '5min', '10min', '30min', '1hour'],\n    },\n  ],\n  defaultParams: [10],\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'fallbackSeries',\n  category: 'Special',\n  params: [{ name: 'fallback', type: 'string' }],\n  defaultParams: ['constantLine(0)'],\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'grep',\n  category: 'Filter Series',\n  params: [{ name: 'grep', type: 'string' }],\n  defaultParams: ['grep'],\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'groupByNodes',\n  category: 'Combine',\n  params: [\n    {\n      name: 'function',\n      type: 'string',\n      options: ['sum', 'avg', 'maxSeries'],\n    },\n    {\n      name: 'node',\n      type: 'int',\n      options: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12],\n      multiple: true,\n    },\n  ],\n  defaultParams: ['sum', 3],\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'integralByInterval',\n  category: 'Transform',\n  params: [\n    {\n      name: 'intervalUnit',\n      type: 'select',\n      options: ['1h', '6h', '12h', '1d', '2d', '7d', '14d', '30d'],\n    },\n  ],\n  defaultParams: ['1d'],\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'interpolate',\n  category: 'Transform',\n  params: [{ name: 'limit', type: 'int', optional: true }],\n  defaultParams: [],\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'invert',\n  category: 'Transform',\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'isNonNull',\n  category: 'Combine',\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'linearRegression',\n  category: 'Calculate',\n  params: [\n    {\n      name: 'startSourceAt',\n      type: 'select',\n      options: ['-1h', '-6h', '-12h', '-1d', '-2d', '-7d', '-14d', '-30d'],\n      optional: true,\n    },\n    {\n      name: 'endSourceAt',\n      type: 'select',\n      options: ['-1h', '-6h', '-12h', '-1d', '-2d', '-7d', '-14d', '-30d'],\n      optional: true,\n    },\n  ],\n  defaultParams: [],\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'mapSeries',\n  shortName: 'map',\n  params: [{ name: 'node', type: 'int' }],\n  defaultParams: [3],\n  category: 'Combine',\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'movingMin',\n  category: 'Calculate',\n  params: [\n    {\n      name: 'windowSize',\n      type: 'int_or_interval',\n      options: ['5', '7', '10', '5min', '10min', '30min', '1hour'],\n    },\n  ],\n  defaultParams: [10],\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'movingMax',\n  category: 'Calculate',\n  params: [\n    {\n      name: 'windowSize',\n      type: 'int_or_interval',\n      options: ['5', '7', '10', '5min', '10min', '30min', '1hour'],\n    },\n  ],\n  defaultParams: [10],\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'movingSum',\n  category: 'Calculate',\n  params: [\n    {\n      name: 'windowSize',\n      type: 'int_or_interval',\n      options: ['5', '7', '10', '5min', '10min', '30min', '1hour'],\n    },\n  ],\n  defaultParams: [10],\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'multiplySeriesWithWildcards',\n  category: 'Combine',\n  params: [\n    {\n      name: 'position',\n      type: 'int',\n      options: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12],\n      multiple: true,\n    },\n  ],\n  defaultParams: [2],\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'offsetToZero',\n  category: 'Transform',\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'pow',\n  category: 'Transform',\n  params: [{ name: 'factor', type: 'int' }],\n  defaultParams: [10],\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'powSeries',\n  category: 'Transform',\n  params: optionalSeriesRefArgs,\n  defaultParams: [''],\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'reduceSeries',\n  shortName: 'reduce',\n  params: [\n    {\n      name: 'function',\n      type: 'string',\n      options: ['asPercent', 'diffSeries', 'divideSeries'],\n    },\n    {\n      name: 'reduceNode',\n      type: 'int',\n      options: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],\n    },\n    { name: 'reduceMatchers', type: 'string', multiple: true },\n  ],\n  defaultParams: ['asPercent', 2, 'used_bytes'],\n  category: 'Combine',\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'removeBetweenPercentile',\n  category: 'Filter Series',\n  params: [{ name: 'n', type: 'int' }],\n  defaultParams: [95],\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'removeEmptySeries',\n  category: 'Filter Series',\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'squareRoot',\n  category: 'Transform',\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'timeSlice',\n  category: 'Transform',\n  params: [\n    {\n      name: 'startSliceAt',\n      type: 'select',\n      options: ['-1h', '-6h', '-12h', '-1d', '-2d', '-7d', '-14d', '-30d'],\n    },\n    {\n      name: 'endSliceAt',\n      type: 'select',\n      options: ['-1h', '-6h', '-12h', '-1d', '-2d', '-7d', '-14d', '-30d'],\n      optional: true,\n    },\n  ],\n  defaultParams: ['-1h'],\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'weightedAverage',\n  category: 'Combine',\n  params: [\n    { name: 'other', type: 'value_or_series', optional: true },\n    {\n      name: 'node',\n      type: 'int',\n      options: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12],\n    },\n  ],\n  defaultParams: ['#A', 4],\n  version: '1.0',\n});\n\naddFuncDef({\n  name: 'seriesByTag',\n  category: 'Special',\n  params: [{ name: 'tagExpression', type: 'string', multiple: true }],\n  version: '1.1',\n});\n\naddFuncDef({\n  name: 'groupByTags',\n  category: 'Combine',\n  params: [\n    {\n      name: 'function',\n      type: 'string',\n      options: ['sum', 'avg', 'maxSeries'],\n    },\n    { name: 'tag', type: 'string', multiple: true },\n  ],\n  defaultParams: ['sum', 'tag'],\n  version: '1.1',\n});\n\naddFuncDef({\n  name: 'aliasByTags',\n  category: 'Alias',\n  params: [{ name: 'tag', type: 'string', multiple: true }],\n  defaultParams: ['tag'],\n  version: '1.1',\n});\n\nfunction isVersionRelatedFunction(obj: { version: string }, graphiteVersion: string) {\n  return !obj.version || isVersionGtOrEq(graphiteVersion, obj.version);\n}\n\nexport class FuncInstance {\n  def: any;\n  params: any;\n  text: any;\n  added: boolean;\n\n  constructor(funcDef: any, options: { withDefaultParams: any }) {\n    this.def = funcDef;\n    this.params = [];\n\n    if (options && options.withDefaultParams) {\n      this.params = funcDef.defaultParams.slice(0);\n    }\n\n    this.updateText();\n  }\n\n  render(metricExp: string, replaceVariables: InterpolateFunction): string {\n    const str = this.def.name + '(';\n\n    const parameters = _.map(this.params, (value, index) => {\n      let paramType;\n\n      if (index < this.def.params.length) {\n        paramType = this.def.params[index].type;\n      } else if (_.get(_.last(this.def.params), 'multiple')) {\n        paramType = _.get(_.last(this.def.params), 'type');\n      }\n\n      // param types that should never be quoted\n      if (_.includes(['value_or_series', 'boolean', 'int', 'float', 'node'], paramType)) {\n        return value;\n      }\n\n      const valueInterpolated = _.isString(value) ? replaceVariables(value) : value;\n\n      // param types that might be quoted\n      // To quote variables correctly we need to interpolate it to check if it contains a numeric or string value\n      if (_.includes(['int_or_interval', 'node_or_tag'], paramType) && _.isFinite(+valueInterpolated)) {\n        return _.toString(value);\n      }\n\n      return \"'\" + value + \"'\";\n    });\n\n    // don't send any blank parameters to graphite\n    while (parameters[parameters.length - 1] === '') {\n      parameters.pop();\n    }\n\n    if (metricExp) {\n      parameters.unshift(metricExp);\n    }\n\n    return str + parameters.join(', ') + ')';\n  }\n\n  _hasMultipleParamsInString(strValue: any, index: number) {\n    if (strValue.indexOf(',') === -1) {\n      return false;\n    }\n\n    if (this.def.params[index + 1] && this.def.params[index + 1].optional) {\n      return true;\n    }\n\n    if (index + 1 >= this.def.params.length && _.get(_.last(this.def.params), 'multiple')) {\n      return true;\n    }\n\n    return false;\n  }\n\n  updateParam(strValue: any, index: any) {\n    // handle optional parameters\n    // if string contains ',' and next param is optional, split and update both\n    if (this._hasMultipleParamsInString(strValue, index)) {\n      _.each(strValue.split(','), (partVal, idx) => {\n        this.updateParam(partVal.trim(), index + idx);\n      });\n      return;\n    }\n\n    if (strValue === '' && (index >= this.def.params.length || this.def.params[index].optional)) {\n      this.params.splice(index, 1);\n    } else {\n      this.params[index] = strValue;\n    }\n\n    this.updateText();\n  }\n\n  updateText() {\n    if (this.params.length === 0) {\n      this.text = this.def.name + '()';\n      return;\n    }\n\n    let text = this.def.name + '(';\n    text += this.params.join(', ');\n    text += ')';\n    this.text = text;\n  }\n}\n\nfunction createFuncInstance(funcDef: any, options?: { withDefaultParams: any }, idx?: any) {\n  if (_.isString(funcDef)) {\n    funcDef = getFuncDef(funcDef, idx);\n  }\n  return new FuncInstance(funcDef, options);\n}\n\nfunction getFuncDef(name: string, idx?: any) {\n  if (!(idx || index)[name]) {\n    throw { message: 'Method not found ' + name };\n  }\n  return (idx || index)[name];\n}\n\nfunction getFuncDefs(graphiteVersion: string, idx?: any) {\n  const funcs: any = {};\n  _.forEach(idx || index, funcDef => {\n    if (isVersionRelatedFunction(funcDef, graphiteVersion)) {\n      funcs[funcDef.name] = _.assign({}, funcDef, {\n        params: _.filter(funcDef.params, param => {\n          return isVersionRelatedFunction(param, graphiteVersion);\n        }),\n      });\n    }\n  });\n  return funcs;\n}\n\n// parse response from graphite /functions endpoint into internal format\nfunction parseFuncDefs(rawDefs: any) {\n  const funcDefs: any = {};\n\n  _.forEach(rawDefs || {}, (funcDef, funcName) => {\n    // skip graphite graph functions\n    if (funcDef.group === 'Graph') {\n      return;\n    }\n\n    let description = funcDef.description;\n    if (description) {\n      // tidy up some pydoc syntax that rst2html can't handle\n      description = description\n        .replace(/:py:func:`(.+)( <[^>]*>)?`/g, '``$1``')\n        .replace(/.. seealso:: /g, 'See also: ')\n        .replace(/.. code-block *:: *none/g, '.. code-block::');\n    }\n\n    const func: FuncDef = {\n      name: funcDef.name,\n      description,\n      category: funcDef.group,\n      params: [],\n      defaultParams: [],\n      fake: false,\n    };\n\n    // get rid of the first \"seriesList\" param\n    if (/^seriesLists?$/.test(_.get(funcDef, 'params[0].type', ''))) {\n      // handle functions that accept multiple seriesLists\n      // we leave the param in place but mark it optional, so users can add more series if they wish\n      if (funcDef.params[0].multiple) {\n        funcDef.params[0].required = false;\n        // otherwise chop off the first param, it'll be handled separately\n      } else {\n        funcDef.params.shift();\n      }\n      // tag function as fake\n    } else {\n      func.fake = true;\n    }\n\n    _.forEach(funcDef.params, rawParam => {\n      const param: any = {\n        name: rawParam.name,\n        type: 'string',\n        optional: !rawParam.required,\n        multiple: !!rawParam.multiple,\n        options: undefined,\n      };\n\n      if (rawParam.default !== undefined) {\n        func.defaultParams.push(_.toString(rawParam.default));\n      } else if (rawParam.suggestions) {\n        func.defaultParams.push(_.toString(rawParam.suggestions[0]));\n      } else {\n        func.defaultParams.push('');\n      }\n\n      if (rawParam.type === 'boolean') {\n        param.type = 'boolean';\n        param.options = ['true', 'false'];\n      } else if (rawParam.type === 'integer') {\n        param.type = 'int';\n      } else if (rawParam.type === 'float') {\n        param.type = 'float';\n      } else if (rawParam.type === 'node') {\n        param.type = 'node';\n        param.options = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'];\n      } else if (rawParam.type === 'nodeOrTag') {\n        param.type = 'node_or_tag';\n        param.options = ['name', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12'];\n      } else if (rawParam.type === 'intOrInterval') {\n        param.type = 'int_or_interval';\n      } else if (rawParam.type === 'seriesList') {\n        param.type = 'value_or_series';\n      }\n\n      if (rawParam.options) {\n        param.options = _.map(rawParam.options, _.toString);\n      } else if (rawParam.suggestions) {\n        param.options = _.map(rawParam.suggestions, _.toString);\n      }\n\n      func.params.push(param);\n    });\n\n    funcDefs[funcName] = func;\n  });\n\n  return funcDefs;\n}\n\nexport default {\n  createFuncInstance: createFuncInstance,\n  getFuncDef: getFuncDef,\n  getFuncDefs: getFuncDefs,\n  parseFuncDefs: parseFuncDefs,\n};\n","import { DataQuery } from '@grafana/data';\n\nexport interface GraphiteQuery extends DataQuery {\n  target?: string;\n}\n\nexport enum GraphiteType {\n  Default = 'default',\n  Metrictank = 'metrictank',\n}\n","import _ from 'lodash';\nimport { DataFrame, dateMath, ScopedVars, DataQueryResponse, DataQueryRequest, toDataFrame } from '@grafana/data';\nimport { isVersionGtOrEq, SemVersion } from 'app/core/utils/version';\nimport gfunc from './gfunc';\nimport { IQService } from 'angular';\nimport { BackendSrv } from 'app/core/services/backend_srv';\nimport { TemplateSrv } from 'app/features/templating/template_srv';\n//Types\nimport { GraphiteQuery, GraphiteType } from './types';\nimport { getSearchFilterScopedVar } from '../../../features/templating/variable';\n\nexport class GraphiteDatasource {\n  basicAuth: string;\n  url: string;\n  name: string;\n  graphiteVersion: any;\n  supportsTags: boolean;\n  isMetricTank: boolean;\n  cacheTimeout: any;\n  withCredentials: boolean;\n  funcDefs: any = null;\n  funcDefsPromise: Promise<any> = null;\n  _seriesRefLetters: string;\n\n  /** @ngInject */\n  constructor(\n    instanceSettings: any,\n    private $q: IQService,\n    private backendSrv: BackendSrv,\n    private templateSrv: TemplateSrv\n  ) {\n    this.basicAuth = instanceSettings.basicAuth;\n    this.url = instanceSettings.url;\n    this.name = instanceSettings.name;\n    this.graphiteVersion = instanceSettings.jsonData.graphiteVersion || '0.9';\n    this.isMetricTank = instanceSettings.jsonData.graphiteType === GraphiteType.Metrictank;\n    this.supportsTags = supportsTags(this.graphiteVersion);\n    this.cacheTimeout = instanceSettings.cacheTimeout;\n    this.withCredentials = instanceSettings.withCredentials;\n    this.funcDefs = null;\n    this.funcDefsPromise = null;\n    this._seriesRefLetters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  }\n\n  getQueryOptionsInfo() {\n    return {\n      maxDataPoints: true,\n      cacheTimeout: true,\n      links: [\n        {\n          text: 'Help',\n          url: 'http://docs.grafana.org/features/datasources/graphite/#using-graphite-in-grafana',\n        },\n      ],\n    };\n  }\n\n  async query(options: DataQueryRequest<GraphiteQuery>): Promise<DataQueryResponse> {\n    const graphOptions = {\n      from: this.translateTime(options.rangeRaw.from, false, options.timezone),\n      until: this.translateTime(options.rangeRaw.to, true, options.timezone),\n      targets: options.targets,\n      format: (options as any).format,\n      cacheTimeout: options.cacheTimeout || this.cacheTimeout,\n      maxDataPoints: options.maxDataPoints,\n    };\n\n    const params = this.buildGraphiteParams(graphOptions, options.scopedVars);\n    if (params.length === 0) {\n      return this.$q.when({ data: [] });\n    }\n\n    if (this.isMetricTank) {\n      params.push('meta=true');\n    }\n\n    const httpOptions: any = {\n      method: 'POST',\n      url: '/render',\n      data: params.join('&'),\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n    };\n\n    this.addTracingHeaders(httpOptions, options);\n\n    if (options.panelId) {\n      httpOptions.requestId = this.name + '.panelId.' + options.panelId;\n    }\n\n    return this.doGraphiteRequest(httpOptions).then(this.convertResponseToDataFrames);\n  }\n\n  addTracingHeaders(httpOptions: { headers: any }, options: { dashboardId: any; panelId: any }) {\n    const proxyMode = !this.url.match(/^http/);\n    if (proxyMode) {\n      httpOptions.headers['X-Dashboard-Id'] = options.dashboardId;\n      httpOptions.headers['X-Panel-Id'] = options.panelId;\n    }\n  }\n\n  convertResponseToDataFrames(result: any): DataQueryResponse {\n    const data: DataFrame[] = [];\n    if (!result || !result.data) {\n      return { data };\n    }\n    // Series are either at the root or under a node called 'series'\n    const series = result.data.series || result.data;\n    if (!_.isArray(series)) {\n      throw { message: 'Missing series in result', data: result };\n    }\n\n    for (let i = 0; i < series.length; i++) {\n      const s = series[i];\n      for (let y = 0; y < s.datapoints.length; y++) {\n        s.datapoints[y][1] *= 1000;\n      }\n      const frame = toDataFrame(s);\n\n      // Metrictank metadata\n      if (s.meta) {\n        frame.meta = {\n          metrictank: s.meta, // array of metadata\n          metrictankReq: result.data.meta, // info on the request\n        };\n      }\n      data.push(frame);\n    }\n    return { data };\n  }\n\n  parseTags(tagString: string) {\n    let tags: string[] = [];\n    tags = tagString.split(',');\n    if (tags.length === 1) {\n      tags = tagString.split(' ');\n      if (tags[0] === '') {\n        tags = [];\n      }\n    }\n    return tags;\n  }\n\n  interpolateVariablesInQueries(queries: GraphiteQuery[]): GraphiteQuery[] {\n    let expandedQueries = queries;\n    if (queries && queries.length > 0) {\n      expandedQueries = queries.map(query => {\n        const expandedQuery = {\n          ...query,\n          datasource: this.name,\n          target: this.templateSrv.replace(query.target),\n        };\n        return expandedQuery;\n      });\n    }\n    return expandedQueries;\n  }\n\n  annotationQuery(options: { annotation: { target: string; tags: string }; rangeRaw: any }) {\n    // Graphite metric as annotation\n    if (options.annotation.target) {\n      const target = this.templateSrv.replace(options.annotation.target, {}, 'glob');\n      const graphiteQuery = ({\n        rangeRaw: options.rangeRaw,\n        targets: [{ target: target }],\n        format: 'json',\n        maxDataPoints: 100,\n      } as unknown) as DataQueryRequest<GraphiteQuery>;\n\n      return this.query(graphiteQuery).then((result: { data: any[] }) => {\n        const list = [];\n\n        for (let i = 0; i < result.data.length; i++) {\n          const target = result.data[i];\n\n          for (let y = 0; y < target.datapoints.length; y++) {\n            const datapoint = target.datapoints[y];\n            if (!datapoint[0]) {\n              continue;\n            }\n\n            list.push({\n              annotation: options.annotation,\n              time: datapoint[1],\n              title: target.target,\n            });\n          }\n        }\n\n        return list;\n      });\n    } else {\n      // Graphite event as annotation\n      const tags = this.templateSrv.replace(options.annotation.tags);\n      return this.events({ range: options.rangeRaw, tags: tags }).then((results: any) => {\n        const list = [];\n        for (let i = 0; i < results.data.length; i++) {\n          const e = results.data[i];\n\n          let tags = e.tags;\n          if (_.isString(e.tags)) {\n            tags = this.parseTags(e.tags);\n          }\n\n          list.push({\n            annotation: options.annotation,\n            time: e.when * 1000,\n            title: e.what,\n            tags: tags,\n            text: e.data,\n          });\n        }\n\n        return list;\n      });\n    }\n  }\n\n  events(options: { range: any; tags: any; timezone?: any }) {\n    try {\n      let tags = '';\n      if (options.tags) {\n        tags = '&tags=' + options.tags;\n      }\n      return this.doGraphiteRequest({\n        method: 'GET',\n        url:\n          '/events/get_data?from=' +\n          this.translateTime(options.range.from, false, options.timezone) +\n          '&until=' +\n          this.translateTime(options.range.to, true, options.timezone) +\n          tags,\n      });\n    } catch (err) {\n      return this.$q.reject(err);\n    }\n  }\n\n  targetContainsTemplate(target: { target: any }) {\n    return this.templateSrv.variableExists(target.target);\n  }\n\n  translateTime(date: any, roundUp: any, timezone: any) {\n    if (_.isString(date)) {\n      if (date === 'now') {\n        return 'now';\n      } else if (date.indexOf('now-') >= 0 && date.indexOf('/') === -1) {\n        date = date.substring(3);\n        date = date.replace('m', 'min');\n        date = date.replace('M', 'mon');\n        return date;\n      }\n      date = dateMath.parse(date, roundUp, timezone);\n    }\n\n    // graphite' s from filter is exclusive\n    // here we step back one minute in order\n    // to guarantee that we get all the data that\n    // exists for the specified range\n    if (roundUp) {\n      if (date.get('s')) {\n        date.add(1, 's');\n      }\n    } else if (roundUp === false) {\n      if (date.get('s')) {\n        date.subtract(1, 's');\n      }\n    }\n\n    return date.unix();\n  }\n\n  metricFindQuery(query: string, optionalOptions: any) {\n    const options: any = optionalOptions || {};\n    let interpolatedQuery = this.templateSrv.replace(\n      query,\n      getSearchFilterScopedVar({ query, wildcardChar: '', options: optionalOptions })\n    );\n\n    // special handling for tag_values(<tag>[,<expression>]*), this is used for template variables\n    let matches = interpolatedQuery.match(/^tag_values\\(([^,]+)((, *[^,]+)*)\\)$/);\n    if (matches) {\n      const expressions = [];\n      const exprRegex = /, *([^,]+)/g;\n      let match = exprRegex.exec(matches[2]);\n      while (match !== null) {\n        expressions.push(match[1]);\n        match = exprRegex.exec(matches[2]);\n      }\n      options.limit = 10000;\n      return this.getTagValuesAutoComplete(expressions, matches[1], undefined, options);\n    }\n\n    // special handling for tags(<expression>[,<expression>]*), this is used for template variables\n    matches = interpolatedQuery.match(/^tags\\(([^,]*)((, *[^,]+)*)\\)$/);\n    if (matches) {\n      const expressions = [];\n      if (matches[1]) {\n        expressions.push(matches[1]);\n        const exprRegex = /, *([^,]+)/g;\n        let match = exprRegex.exec(matches[2]);\n        while (match !== null) {\n          expressions.push(match[1]);\n          match = exprRegex.exec(matches[2]);\n        }\n      }\n      options.limit = 10000;\n      return this.getTagsAutoComplete(expressions, undefined, options);\n    }\n\n    interpolatedQuery = this.templateSrv.replace(\n      query,\n      getSearchFilterScopedVar({ query, wildcardChar: '*', options: optionalOptions })\n    );\n\n    const httpOptions: any = {\n      method: 'POST',\n      url: '/metrics/find',\n      params: {},\n      data: `query=${interpolatedQuery}`,\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n      // for cancellations\n      requestId: options.requestId,\n    };\n\n    if (options.range) {\n      httpOptions.params.from = this.translateTime(options.range.from, false, options.timezone);\n      httpOptions.params.until = this.translateTime(options.range.to, true, options.timezone);\n    }\n\n    return this.doGraphiteRequest(httpOptions).then((results: any) => {\n      return _.map(results.data, metric => {\n        return {\n          text: metric.text,\n          expandable: metric.expandable ? true : false,\n        };\n      });\n    });\n  }\n\n  getTags(optionalOptions: any) {\n    const options = optionalOptions || {};\n\n    const httpOptions: any = {\n      method: 'GET',\n      url: '/tags',\n      // for cancellations\n      requestId: options.requestId,\n    };\n\n    if (options.range) {\n      httpOptions.params.from = this.translateTime(options.range.from, false, options.timezone);\n      httpOptions.params.until = this.translateTime(options.range.to, true, options.timezone);\n    }\n\n    return this.doGraphiteRequest(httpOptions).then((results: any) => {\n      return _.map(results.data, tag => {\n        return {\n          text: tag.tag,\n          id: tag.id,\n        };\n      });\n    });\n  }\n\n  getTagValues(tag: string, optionalOptions: any) {\n    const options = optionalOptions || {};\n\n    const httpOptions: any = {\n      method: 'GET',\n      url: '/tags/' + this.templateSrv.replace(tag),\n      // for cancellations\n      requestId: options.requestId,\n    };\n\n    if (options.range) {\n      httpOptions.params.from = this.translateTime(options.range.from, false, options.timezone);\n      httpOptions.params.until = this.translateTime(options.range.to, true, options.timezone);\n    }\n\n    return this.doGraphiteRequest(httpOptions).then((results: any) => {\n      if (results.data && results.data.values) {\n        return _.map(results.data.values, value => {\n          return {\n            text: value.value,\n            id: value.id,\n          };\n        });\n      } else {\n        return [];\n      }\n    });\n  }\n\n  getTagsAutoComplete(expressions: any[], tagPrefix: any, optionalOptions: any) {\n    const options = optionalOptions || {};\n\n    const httpOptions: any = {\n      method: 'GET',\n      url: '/tags/autoComplete/tags',\n      params: {\n        expr: _.map(expressions, expression => this.templateSrv.replace((expression || '').trim())),\n      },\n      // for cancellations\n      requestId: options.requestId,\n    };\n\n    if (tagPrefix) {\n      httpOptions.params.tagPrefix = tagPrefix;\n    }\n    if (options.limit) {\n      httpOptions.params.limit = options.limit;\n    }\n    if (options.range) {\n      httpOptions.params.from = this.translateTime(options.range.from, false, options.timezone);\n      httpOptions.params.until = this.translateTime(options.range.to, true, options.timezone);\n    }\n\n    return this.doGraphiteRequest(httpOptions).then((results: any) => {\n      if (results.data) {\n        return _.map(results.data, tag => {\n          return { text: tag };\n        });\n      } else {\n        return [];\n      }\n    });\n  }\n\n  getTagValuesAutoComplete(expressions: any[], tag: any, valuePrefix: any, optionalOptions: any) {\n    const options = optionalOptions || {};\n\n    const httpOptions: any = {\n      method: 'GET',\n      url: '/tags/autoComplete/values',\n      params: {\n        expr: _.map(expressions, expression => this.templateSrv.replace((expression || '').trim())),\n        tag: this.templateSrv.replace((tag || '').trim()),\n      },\n      // for cancellations\n      requestId: options.requestId,\n    };\n\n    if (valuePrefix) {\n      httpOptions.params.valuePrefix = valuePrefix;\n    }\n    if (options.limit) {\n      httpOptions.params.limit = options.limit;\n    }\n    if (options.range) {\n      httpOptions.params.from = this.translateTime(options.range.from, false, options.timezone);\n      httpOptions.params.until = this.translateTime(options.range.to, true, options.timezone);\n    }\n\n    return this.doGraphiteRequest(httpOptions).then((results: any) => {\n      if (results.data) {\n        return _.map(results.data, value => {\n          return { text: value };\n        });\n      } else {\n        return [];\n      }\n    });\n  }\n\n  getVersion(optionalOptions: any) {\n    const options = optionalOptions || {};\n\n    const httpOptions = {\n      method: 'GET',\n      url: '/version',\n      requestId: options.requestId,\n    };\n\n    return this.doGraphiteRequest(httpOptions)\n      .then((results: any) => {\n        if (results.data) {\n          const semver = new SemVersion(results.data);\n          return semver.isValid() ? results.data : '';\n        }\n        return '';\n      })\n      .catch(() => {\n        return '';\n      });\n  }\n\n  createFuncInstance(funcDef: any, options?: any) {\n    return gfunc.createFuncInstance(funcDef, options, this.funcDefs);\n  }\n\n  getFuncDef(name: string) {\n    return gfunc.getFuncDef(name, this.funcDefs);\n  }\n\n  waitForFuncDefsLoaded() {\n    return this.getFuncDefs();\n  }\n\n  getFuncDefs() {\n    if (this.funcDefsPromise !== null) {\n      return this.funcDefsPromise;\n    }\n\n    if (!supportsFunctionIndex(this.graphiteVersion)) {\n      this.funcDefs = gfunc.getFuncDefs(this.graphiteVersion);\n      this.funcDefsPromise = Promise.resolve(this.funcDefs);\n      return this.funcDefsPromise;\n    }\n\n    const httpOptions = {\n      method: 'GET',\n      url: '/functions',\n    };\n\n    this.funcDefsPromise = this.doGraphiteRequest(httpOptions)\n      .then((results: any) => {\n        if (results.status !== 200 || typeof results.data !== 'object') {\n          this.funcDefs = gfunc.getFuncDefs(this.graphiteVersion);\n        } else {\n          this.funcDefs = gfunc.parseFuncDefs(results.data);\n        }\n        return this.funcDefs;\n      })\n      .catch((err: any) => {\n        console.log('Fetching graphite functions error', err);\n        this.funcDefs = gfunc.getFuncDefs(this.graphiteVersion);\n        return this.funcDefs;\n      });\n\n    return this.funcDefsPromise;\n  }\n\n  testDatasource() {\n    const query = ({\n      panelId: 3,\n      rangeRaw: { from: 'now-1h', to: 'now' },\n      targets: [{ target: 'constantLine(100)' }],\n      maxDataPoints: 300,\n    } as unknown) as DataQueryRequest<GraphiteQuery>;\n    return this.query(query).then(() => {\n      return { status: 'success', message: 'Data source is working' };\n    });\n  }\n\n  doGraphiteRequest(options: {\n    method?: string;\n    url: any;\n    requestId?: any;\n    withCredentials?: any;\n    headers?: any;\n    inspect?: any;\n  }) {\n    if (this.basicAuth || this.withCredentials) {\n      options.withCredentials = true;\n    }\n    if (this.basicAuth) {\n      options.headers = options.headers || {};\n      options.headers.Authorization = this.basicAuth;\n    }\n\n    options.url = this.url + options.url;\n    options.inspect = { type: 'graphite' };\n\n    return this.backendSrv.datasourceRequest(options);\n  }\n\n  buildGraphiteParams(options: any, scopedVars: ScopedVars): string[] {\n    const graphiteOptions = ['from', 'until', 'rawData', 'format', 'maxDataPoints', 'cacheTimeout'];\n    const cleanOptions = [],\n      targets: any = {};\n    let target, targetValue, i;\n    const regex = /\\#([A-Z])/g;\n    const intervalFormatFixRegex = /'(\\d+)m'/gi;\n    let hasTargets = false;\n\n    options['format'] = 'json';\n\n    function fixIntervalFormat(match: any) {\n      return match.replace('m', 'min').replace('M', 'mon');\n    }\n\n    for (i = 0; i < options.targets.length; i++) {\n      target = options.targets[i];\n      if (!target.target) {\n        continue;\n      }\n\n      if (!target.refId) {\n        target.refId = this._seriesRefLetters[i];\n      }\n\n      targetValue = this.templateSrv.replace(target.target, scopedVars);\n      targetValue = targetValue.replace(intervalFormatFixRegex, fixIntervalFormat);\n      targets[target.refId] = targetValue;\n    }\n\n    function nestedSeriesRegexReplacer(match: any, g1: string | number) {\n      return targets[g1] || match;\n    }\n\n    for (i = 0; i < options.targets.length; i++) {\n      target = options.targets[i];\n      if (!target.target) {\n        continue;\n      }\n\n      targetValue = targets[target.refId];\n      targetValue = targetValue.replace(regex, nestedSeriesRegexReplacer);\n      targets[target.refId] = targetValue;\n\n      if (!target.hide) {\n        hasTargets = true;\n        cleanOptions.push('target=' + encodeURIComponent(targetValue));\n      }\n    }\n\n    _.each(options, (value, key) => {\n      if (_.indexOf(graphiteOptions, key) === -1) {\n        return;\n      }\n      if (value) {\n        cleanOptions.push(key + '=' + encodeURIComponent(value));\n      }\n    });\n\n    if (!hasTargets) {\n      return [];\n    }\n\n    return cleanOptions;\n  }\n}\n\nfunction supportsTags(version: string): boolean {\n  return isVersionGtOrEq(version, '1.1');\n}\n\nfunction supportsFunctionIndex(version: string): boolean {\n  return isVersionGtOrEq(version, '1.1');\n}\n","import _ from 'lodash';\nimport $ from 'jquery';\n// @ts-ignore\nimport Drop from 'tether-drop';\nimport coreModule from 'app/core/core_module';\nimport { FuncDef } from './gfunc';\n\n/** @ngInject */\nexport function graphiteAddFunc($compile: any) {\n  const inputTemplate =\n    '<input type=\"text\"' + ' class=\"gf-form-input\"' + ' spellcheck=\"false\" style=\"display:none\"></input>';\n\n  const buttonTemplate =\n    '<a class=\"gf-form-label query-part dropdown-toggle\"' +\n    ' tabindex=\"1\" gf-dropdown=\"functionMenu\" data-toggle=\"dropdown\">' +\n    '<i class=\"fa fa-plus\"></i></a>';\n\n  return {\n    link: function($scope: any, elem: JQuery) {\n      const ctrl = $scope.ctrl;\n\n      const $input = $(inputTemplate);\n      const $button = $(buttonTemplate);\n\n      $input.appendTo(elem);\n      $button.appendTo(elem);\n\n      ctrl.datasource.getFuncDefs().then((funcDefs: FuncDef[]) => {\n        const allFunctions = _.map(funcDefs, 'name').sort();\n\n        $scope.functionMenu = createFunctionDropDownMenu(funcDefs);\n\n        $input.attr('data-provide', 'typeahead');\n        $input.typeahead({\n          source: allFunctions,\n          minLength: 1,\n          items: 10,\n          updater: (value: any) => {\n            let funcDef: any = ctrl.datasource.getFuncDef(value);\n            if (!funcDef) {\n              // try find close match\n              value = value.toLowerCase();\n              funcDef = _.find(allFunctions, funcName => {\n                return funcName.toLowerCase().indexOf(value) === 0;\n              });\n\n              if (!funcDef) {\n                return '';\n              }\n            }\n\n            $scope.$apply(() => {\n              ctrl.addFunction(funcDef);\n            });\n\n            $input.trigger('blur');\n            return '';\n          },\n        });\n\n        $button.click(() => {\n          $button.hide();\n          $input.show();\n          $input.focus();\n        });\n\n        $input.keyup(() => {\n          elem.toggleClass('open', $input.val() === '');\n        });\n\n        $input.blur(() => {\n          // clicking the function dropdown menu won't\n          // work if you remove class at once\n          setTimeout(() => {\n            $input.val('');\n            $input.hide();\n            $button.show();\n            elem.removeClass('open');\n          }, 200);\n        });\n\n        $compile(elem.contents())($scope);\n      });\n\n      let drop: any;\n      const cleanUpDrop = () => {\n        if (drop) {\n          drop.destroy();\n          drop = null;\n        }\n      };\n\n      $(elem)\n        .on('mouseenter', 'ul.dropdown-menu li', async () => {\n          cleanUpDrop();\n\n          let funcDef;\n          try {\n            funcDef = ctrl.datasource.getFuncDef($('a', this).text());\n          } catch (e) {\n            // ignore\n          }\n\n          if (funcDef && funcDef.description) {\n            let shortDesc = funcDef.description;\n            if (shortDesc.length > 500) {\n              shortDesc = shortDesc.substring(0, 497) + '...';\n            }\n\n            const contentElement = document.createElement('div');\n            // @ts-ignore\n            const { default: rst2html } = await import(/* webpackChunkName: \"rst2html\" */ 'rst2html');\n            contentElement.innerHTML = '<h4>' + funcDef.name + '</h4>' + rst2html(shortDesc);\n\n            drop = new Drop({\n              target: this,\n              content: contentElement,\n              classes: 'drop-popover',\n              openOn: 'always',\n              tetherOptions: {\n                attachment: 'bottom left',\n                targetAttachment: 'bottom right',\n              },\n            });\n          }\n        })\n        .on('mouseout', 'ul.dropdown-menu li', () => {\n          cleanUpDrop();\n        });\n\n      $scope.$on('$destroy', cleanUpDrop);\n    },\n  };\n}\n\ncoreModule.directive('graphiteAddFunc', graphiteAddFunc);\n\nfunction createFunctionDropDownMenu(funcDefs: FuncDef[]) {\n  const categories: any = {};\n\n  _.forEach(funcDefs, funcDef => {\n    if (!funcDef.category) {\n      return;\n    }\n    if (!categories[funcDef.category]) {\n      categories[funcDef.category] = [];\n    }\n    categories[funcDef.category].push({\n      text: funcDef.name,\n      click: \"ctrl.addFunction('\" + funcDef.name + \"')\",\n    });\n  });\n\n  return _.sortBy(\n    _.map(categories, (submenu, category) => {\n      return {\n        text: category,\n        submenu: _.sortBy(submenu, 'text'),\n      };\n    }),\n    'text'\n  );\n}\n","import _ from 'lodash';\nimport $ from 'jquery';\nimport coreModule from 'app/core/core_module';\nimport { TemplateSrv } from 'app/features/templating/template_srv';\n\n/** @ngInject */\nexport function graphiteFuncEditor($compile: any, templateSrv: TemplateSrv) {\n  const funcSpanTemplate = `\n    <function-editor\n      func=\"func\"\n      onRemove=\"ctrl.handleRemoveFunction\"\n      onMoveLeft=\"ctrl.handleMoveLeft\"\n      onMoveRight=\"ctrl.handleMoveRight\"\n    /><span>(</span>\n  `;\n  const paramTemplate =\n    '<input type=\"text\" style=\"display:none\"' + ' class=\"input-small tight-form-func-param\"></input>';\n\n  return {\n    restrict: 'A',\n    link: function postLink($scope: any, elem: JQuery) {\n      const $funcLink = $(funcSpanTemplate);\n      const ctrl = $scope.ctrl;\n      const func = $scope.func;\n      let scheduledRelink = false;\n      let paramCountAtLink = 0;\n      let cancelBlur: any = null;\n\n      ctrl.handleRemoveFunction = (func: any) => {\n        ctrl.removeFunction(func);\n      };\n\n      ctrl.handleMoveLeft = (func: any) => {\n        ctrl.moveFunction(func, -1);\n      };\n\n      ctrl.handleMoveRight = (func: any) => {\n        ctrl.moveFunction(func, 1);\n      };\n\n      function clickFuncParam(this: any, paramIndex: any) {\n        /*jshint validthis:true */\n\n        const $link = $(this);\n        const $comma = $link.prev('.comma');\n        const $input = $link.next();\n\n        $input.val(func.params[paramIndex]);\n\n        $comma.removeClass('query-part__last');\n        $link.hide();\n        $input.show();\n        $input.focus();\n        $input.select();\n\n        const typeahead = $input.data('typeahead');\n        if (typeahead) {\n          $input.val('');\n          typeahead.lookup();\n        }\n      }\n\n      function scheduledRelinkIfNeeded() {\n        if (paramCountAtLink === func.params.length) {\n          return;\n        }\n\n        if (!scheduledRelink) {\n          scheduledRelink = true;\n          setTimeout(() => {\n            relink();\n            scheduledRelink = false;\n          }, 200);\n        }\n      }\n\n      function paramDef(index: number) {\n        if (index < func.def.params.length) {\n          return func.def.params[index];\n        }\n        if ((_.last(func.def.params) as any).multiple) {\n          return _.assign({}, _.last(func.def.params), { optional: true });\n        }\n        return {};\n      }\n\n      function switchToLink(inputElem: HTMLElement, paramIndex: any) {\n        /*jshint validthis:true */\n        const $input = $(inputElem);\n\n        clearTimeout(cancelBlur);\n        cancelBlur = null;\n\n        const $link = $input.prev();\n        const $comma = $link.prev('.comma');\n        const newValue = $input.val();\n\n        // remove optional empty params\n        if (newValue !== '' || paramDef(paramIndex).optional) {\n          func.updateParam(newValue, paramIndex);\n          $link.html(newValue ? templateSrv.highlightVariablesAsHtml(newValue) : '&nbsp;');\n        }\n\n        scheduledRelinkIfNeeded();\n\n        $scope.$apply(() => {\n          ctrl.targetChanged();\n        });\n\n        if ($link.hasClass('query-part__last') && newValue === '') {\n          $comma.addClass('query-part__last');\n        } else {\n          $link.removeClass('query-part__last');\n        }\n\n        $input.hide();\n        $link.show();\n      }\n\n      // this = input element\n      function inputBlur(this: any, paramIndex: any) {\n        /*jshint validthis:true */\n        const inputElem = this;\n        // happens long before the click event on the typeahead options\n        // need to have long delay because the blur\n        cancelBlur = setTimeout(() => {\n          switchToLink(inputElem, paramIndex);\n        }, 200);\n      }\n\n      function inputKeyPress(this: any, paramIndex: any, e: any) {\n        /*jshint validthis:true */\n        if (e.which === 13) {\n          $(this).blur();\n        }\n      }\n\n      function inputKeyDown(this: any) {\n        /*jshint validthis:true */\n        this.style.width = (3 + this.value.length) * 8 + 'px';\n      }\n\n      function addTypeahead($input: any, paramIndex: any) {\n        $input.attr('data-provide', 'typeahead');\n\n        let options = paramDef(paramIndex).options;\n        if (paramDef(paramIndex).type === 'int') {\n          options = _.map(options, val => {\n            return val.toString();\n          });\n        }\n\n        $input.typeahead({\n          source: options,\n          minLength: 0,\n          items: 20,\n          updater: (value: any) => {\n            $input.val(value);\n            switchToLink($input[0], paramIndex);\n            return value;\n          },\n        });\n\n        const typeahead = $input.data('typeahead');\n        typeahead.lookup = function() {\n          this.query = this.$element.val() || '';\n          return this.process(this.source);\n        };\n      }\n\n      function addElementsAndCompile() {\n        $funcLink.appendTo(elem);\n\n        const defParams: any = _.clone(func.def.params);\n        const lastParam: any = _.last(func.def.params);\n\n        while (func.params.length >= defParams.length && lastParam && lastParam.multiple) {\n          defParams.push(_.assign({}, lastParam, { optional: true }));\n        }\n\n        _.each(defParams, (param: any, index: number) => {\n          if (param.optional && func.params.length < index) {\n            return false;\n          }\n\n          let paramValue = templateSrv.highlightVariablesAsHtml(func.params[index]);\n          const hasValue = paramValue !== null && paramValue !== undefined;\n\n          const last = index >= func.params.length - 1 && param.optional && !hasValue;\n          if (last && param.multiple) {\n            paramValue = '+';\n          }\n\n          if (index > 0) {\n            $('<span class=\"comma' + (last ? ' query-part__last' : '') + '\">, </span>').appendTo(elem);\n          }\n\n          const $paramLink = $(\n            '<a ng-click=\"\" class=\"graphite-func-param-link' +\n              (last ? ' query-part__last' : '') +\n              '\">' +\n              (hasValue ? paramValue : '&nbsp;') +\n              '</a>'\n          );\n          const $input = $(paramTemplate);\n          $input.attr('placeholder', param.name);\n\n          paramCountAtLink++;\n\n          $paramLink.appendTo(elem);\n          $input.appendTo(elem);\n\n          $input.blur(_.partial(inputBlur, index));\n          $input.keyup(inputKeyDown);\n          $input.keypress(_.partial(inputKeyPress, index));\n          $paramLink.click(_.partial(clickFuncParam, index));\n\n          if (param.options) {\n            addTypeahead($input, index);\n          }\n\n          return true;\n        });\n\n        $('<span>)</span>').appendTo(elem);\n\n        $compile(elem.contents())($scope);\n      }\n\n      function ifJustAddedFocusFirstParam() {\n        if ($scope.func.added) {\n          $scope.func.added = false;\n          setTimeout(() => {\n            elem\n              .find('.graphite-func-param-link')\n              .first()\n              .click();\n          }, 10);\n        }\n      }\n\n      function relink() {\n        elem.children().remove();\n        addElementsAndCompile();\n        ifJustAddedFocusFirstParam();\n      }\n\n      relink();\n    },\n  };\n}\n\ncoreModule.directive('graphiteFuncEditor', graphiteFuncEditor);\n","import _ from 'lodash';\n\n// This is auto generated from the unicode tables.\n// The tables are at:\n// http://www.fileformat.info/info/unicode/category/Lu/list.htm\n// http://www.fileformat.info/info/unicode/category/Ll/list.htm\n// http://www.fileformat.info/info/unicode/category/Lt/list.htm\n// http://www.fileformat.info/info/unicode/category/Lm/list.htm\n// http://www.fileformat.info/info/unicode/category/Lo/list.htm\n// http://www.fileformat.info/info/unicode/category/Nl/list.htm\n\nconst unicodeLetterTable = [\n  170,\n  170,\n  181,\n  181,\n  186,\n  186,\n  192,\n  214,\n  216,\n  246,\n  248,\n  705,\n  710,\n  721,\n  736,\n  740,\n  748,\n  748,\n  750,\n  750,\n  880,\n  884,\n  886,\n  887,\n  890,\n  893,\n  902,\n  902,\n  904,\n  906,\n  908,\n  908,\n  910,\n  929,\n  931,\n  1013,\n  1015,\n  1153,\n  1162,\n  1319,\n  1329,\n  1366,\n  1369,\n  1369,\n  1377,\n  1415,\n  1488,\n  1514,\n  1520,\n  1522,\n  1568,\n  1610,\n  1646,\n  1647,\n  1649,\n  1747,\n  1749,\n  1749,\n  1765,\n  1766,\n  1774,\n  1775,\n  1786,\n  1788,\n  1791,\n  1791,\n  1808,\n  1808,\n  1810,\n  1839,\n  1869,\n  1957,\n  1969,\n  1969,\n  1994,\n  2026,\n  2036,\n  2037,\n  2042,\n  2042,\n  2048,\n  2069,\n  2074,\n  2074,\n  2084,\n  2084,\n  2088,\n  2088,\n  2112,\n  2136,\n  2308,\n  2361,\n  2365,\n  2365,\n  2384,\n  2384,\n  2392,\n  2401,\n  2417,\n  2423,\n  2425,\n  2431,\n  2437,\n  2444,\n  2447,\n  2448,\n  2451,\n  2472,\n  2474,\n  2480,\n  2482,\n  2482,\n  2486,\n  2489,\n  2493,\n  2493,\n  2510,\n  2510,\n  2524,\n  2525,\n  2527,\n  2529,\n  2544,\n  2545,\n  2565,\n  2570,\n  2575,\n  2576,\n  2579,\n  2600,\n  2602,\n  2608,\n  2610,\n  2611,\n  2613,\n  2614,\n  2616,\n  2617,\n  2649,\n  2652,\n  2654,\n  2654,\n  2674,\n  2676,\n  2693,\n  2701,\n  2703,\n  2705,\n  2707,\n  2728,\n  2730,\n  2736,\n  2738,\n  2739,\n  2741,\n  2745,\n  2749,\n  2749,\n  2768,\n  2768,\n  2784,\n  2785,\n  2821,\n  2828,\n  2831,\n  2832,\n  2835,\n  2856,\n  2858,\n  2864,\n  2866,\n  2867,\n  2869,\n  2873,\n  2877,\n  2877,\n  2908,\n  2909,\n  2911,\n  2913,\n  2929,\n  2929,\n  2947,\n  2947,\n  2949,\n  2954,\n  2958,\n  2960,\n  2962,\n  2965,\n  2969,\n  2970,\n  2972,\n  2972,\n  2974,\n  2975,\n  2979,\n  2980,\n  2984,\n  2986,\n  2990,\n  3001,\n  3024,\n  3024,\n  3077,\n  3084,\n  3086,\n  3088,\n  3090,\n  3112,\n  3114,\n  3123,\n  3125,\n  3129,\n  3133,\n  3133,\n  3160,\n  3161,\n  3168,\n  3169,\n  3205,\n  3212,\n  3214,\n  3216,\n  3218,\n  3240,\n  3242,\n  3251,\n  3253,\n  3257,\n  3261,\n  3261,\n  3294,\n  3294,\n  3296,\n  3297,\n  3313,\n  3314,\n  3333,\n  3340,\n  3342,\n  3344,\n  3346,\n  3386,\n  3389,\n  3389,\n  3406,\n  3406,\n  3424,\n  3425,\n  3450,\n  3455,\n  3461,\n  3478,\n  3482,\n  3505,\n  3507,\n  3515,\n  3517,\n  3517,\n  3520,\n  3526,\n  3585,\n  3632,\n  3634,\n  3635,\n  3648,\n  3654,\n  3713,\n  3714,\n  3716,\n  3716,\n  3719,\n  3720,\n  3722,\n  3722,\n  3725,\n  3725,\n  3732,\n  3735,\n  3737,\n  3743,\n  3745,\n  3747,\n  3749,\n  3749,\n  3751,\n  3751,\n  3754,\n  3755,\n  3757,\n  3760,\n  3762,\n  3763,\n  3773,\n  3773,\n  3776,\n  3780,\n  3782,\n  3782,\n  3804,\n  3805,\n  3840,\n  3840,\n  3904,\n  3911,\n  3913,\n  3948,\n  3976,\n  3980,\n  4096,\n  4138,\n  4159,\n  4159,\n  4176,\n  4181,\n  4186,\n  4189,\n  4193,\n  4193,\n  4197,\n  4198,\n  4206,\n  4208,\n  4213,\n  4225,\n  4238,\n  4238,\n  4256,\n  4293,\n  4304,\n  4346,\n  4348,\n  4348,\n  4352,\n  4680,\n  4682,\n  4685,\n  4688,\n  4694,\n  4696,\n  4696,\n  4698,\n  4701,\n  4704,\n  4744,\n  4746,\n  4749,\n  4752,\n  4784,\n  4786,\n  4789,\n  4792,\n  4798,\n  4800,\n  4800,\n  4802,\n  4805,\n  4808,\n  4822,\n  4824,\n  4880,\n  4882,\n  4885,\n  4888,\n  4954,\n  4992,\n  5007,\n  5024,\n  5108,\n  5121,\n  5740,\n  5743,\n  5759,\n  5761,\n  5786,\n  5792,\n  5866,\n  5870,\n  5872,\n  5888,\n  5900,\n  5902,\n  5905,\n  5920,\n  5937,\n  5952,\n  5969,\n  5984,\n  5996,\n  5998,\n  6000,\n  6016,\n  6067,\n  6103,\n  6103,\n  6108,\n  6108,\n  6176,\n  6263,\n  6272,\n  6312,\n  6314,\n  6314,\n  6320,\n  6389,\n  6400,\n  6428,\n  6480,\n  6509,\n  6512,\n  6516,\n  6528,\n  6571,\n  6593,\n  6599,\n  6656,\n  6678,\n  6688,\n  6740,\n  6823,\n  6823,\n  6917,\n  6963,\n  6981,\n  6987,\n  7043,\n  7072,\n  7086,\n  7087,\n  7104,\n  7141,\n  7168,\n  7203,\n  7245,\n  7247,\n  7258,\n  7293,\n  7401,\n  7404,\n  7406,\n  7409,\n  7424,\n  7615,\n  7680,\n  7957,\n  7960,\n  7965,\n  7968,\n  8005,\n  8008,\n  8013,\n  8016,\n  8023,\n  8025,\n  8025,\n  8027,\n  8027,\n  8029,\n  8029,\n  8031,\n  8061,\n  8064,\n  8116,\n  8118,\n  8124,\n  8126,\n  8126,\n  8130,\n  8132,\n  8134,\n  8140,\n  8144,\n  8147,\n  8150,\n  8155,\n  8160,\n  8172,\n  8178,\n  8180,\n  8182,\n  8188,\n  8305,\n  8305,\n  8319,\n  8319,\n  8336,\n  8348,\n  8450,\n  8450,\n  8455,\n  8455,\n  8458,\n  8467,\n  8469,\n  8469,\n  8473,\n  8477,\n  8484,\n  8484,\n  8486,\n  8486,\n  8488,\n  8488,\n  8490,\n  8493,\n  8495,\n  8505,\n  8508,\n  8511,\n  8517,\n  8521,\n  8526,\n  8526,\n  8544,\n  8584,\n  11264,\n  11310,\n  11312,\n  11358,\n  11360,\n  11492,\n  11499,\n  11502,\n  11520,\n  11557,\n  11568,\n  11621,\n  11631,\n  11631,\n  11648,\n  11670,\n  11680,\n  11686,\n  11688,\n  11694,\n  11696,\n  11702,\n  11704,\n  11710,\n  11712,\n  11718,\n  11720,\n  11726,\n  11728,\n  11734,\n  11736,\n  11742,\n  11823,\n  11823,\n  12293,\n  12295,\n  12321,\n  12329,\n  12337,\n  12341,\n  12344,\n  12348,\n  12353,\n  12438,\n  12445,\n  12447,\n  12449,\n  12538,\n  12540,\n  12543,\n  12549,\n  12589,\n  12593,\n  12686,\n  12704,\n  12730,\n  12784,\n  12799,\n  13312,\n  13312,\n  19893,\n  19893,\n  19968,\n  19968,\n  40907,\n  40907,\n  40960,\n  42124,\n  42192,\n  42237,\n  42240,\n  42508,\n  42512,\n  42527,\n  42538,\n  42539,\n  42560,\n  42606,\n  42623,\n  42647,\n  42656,\n  42735,\n  42775,\n  42783,\n  42786,\n  42888,\n  42891,\n  42894,\n  42896,\n  42897,\n  42912,\n  42921,\n  43002,\n  43009,\n  43011,\n  43013,\n  43015,\n  43018,\n  43020,\n  43042,\n  43072,\n  43123,\n  43138,\n  43187,\n  43250,\n  43255,\n  43259,\n  43259,\n  43274,\n  43301,\n  43312,\n  43334,\n  43360,\n  43388,\n  43396,\n  43442,\n  43471,\n  43471,\n  43520,\n  43560,\n  43584,\n  43586,\n  43588,\n  43595,\n  43616,\n  43638,\n  43642,\n  43642,\n  43648,\n  43695,\n  43697,\n  43697,\n  43701,\n  43702,\n  43705,\n  43709,\n  43712,\n  43712,\n  43714,\n  43714,\n  43739,\n  43741,\n  43777,\n  43782,\n  43785,\n  43790,\n  43793,\n  43798,\n  43808,\n  43814,\n  43816,\n  43822,\n  43968,\n  44002,\n  44032,\n  44032,\n  55203,\n  55203,\n  55216,\n  55238,\n  55243,\n  55291,\n  63744,\n  64045,\n  64048,\n  64109,\n  64112,\n  64217,\n  64256,\n  64262,\n  64275,\n  64279,\n  64285,\n  64285,\n  64287,\n  64296,\n  64298,\n  64310,\n  64312,\n  64316,\n  64318,\n  64318,\n  64320,\n  64321,\n  64323,\n  64324,\n  64326,\n  64433,\n  64467,\n  64829,\n  64848,\n  64911,\n  64914,\n  64967,\n  65008,\n  65019,\n  65136,\n  65140,\n  65142,\n  65276,\n  65313,\n  65338,\n  65345,\n  65370,\n  65382,\n  65470,\n  65474,\n  65479,\n  65482,\n  65487,\n  65490,\n  65495,\n  65498,\n  65500,\n  65536,\n  65547,\n  65549,\n  65574,\n  65576,\n  65594,\n  65596,\n  65597,\n  65599,\n  65613,\n  65616,\n  65629,\n  65664,\n  65786,\n  65856,\n  65908,\n  66176,\n  66204,\n  66208,\n  66256,\n  66304,\n  66334,\n  66352,\n  66378,\n  66432,\n  66461,\n  66464,\n  66499,\n  66504,\n  66511,\n  66513,\n  66517,\n  66560,\n  66717,\n  67584,\n  67589,\n  67592,\n  67592,\n  67594,\n  67637,\n  67639,\n  67640,\n  67644,\n  67644,\n  67647,\n  67669,\n  67840,\n  67861,\n  67872,\n  67897,\n  68096,\n  68096,\n  68112,\n  68115,\n  68117,\n  68119,\n  68121,\n  68147,\n  68192,\n  68220,\n  68352,\n  68405,\n  68416,\n  68437,\n  68448,\n  68466,\n  68608,\n  68680,\n  69635,\n  69687,\n  69763,\n  69807,\n  73728,\n  74606,\n  74752,\n  74850,\n  77824,\n  78894,\n  92160,\n  92728,\n  110592,\n  110593,\n  119808,\n  119892,\n  119894,\n  119964,\n  119966,\n  119967,\n  119970,\n  119970,\n  119973,\n  119974,\n  119977,\n  119980,\n  119982,\n  119993,\n  119995,\n  119995,\n  119997,\n  120003,\n  120005,\n  120069,\n  120071,\n  120074,\n  120077,\n  120084,\n  120086,\n  120092,\n  120094,\n  120121,\n  120123,\n  120126,\n  120128,\n  120132,\n  120134,\n  120134,\n  120138,\n  120144,\n  120146,\n  120485,\n  120488,\n  120512,\n  120514,\n  120538,\n  120540,\n  120570,\n  120572,\n  120596,\n  120598,\n  120628,\n  120630,\n  120654,\n  120656,\n  120686,\n  120688,\n  120712,\n  120714,\n  120744,\n  120746,\n  120770,\n  120772,\n  120779,\n  131072,\n  131072,\n  173782,\n  173782,\n  173824,\n  173824,\n  177972,\n  177972,\n  177984,\n  177984,\n  178205,\n  178205,\n  194560,\n  195101,\n];\n\nconst identifierStartTable: any[] = [];\n\nfor (let i = 0; i < 128; i++) {\n  identifierStartTable[i] =\n    (i >= 48 && i <= 57) || // 0-9\n    i === 36 || // $\n    i === 126 || // ~\n    i === 124 || // |\n    (i >= 65 && i <= 90) || // A-Z\n    i === 95 || // _\n    i === 45 || // -\n    i === 42 || // *\n    i === 58 || // :\n    i === 91 || // templateStart [\n    i === 93 || // templateEnd ]\n    i === 63 || // ?\n    i === 37 || // %\n    i === 35 || // #\n    i === 61 || // =\n    (i >= 97 && i <= 122); // a-z\n}\n\nconst identifierPartTable = identifierStartTable;\n\nexport class Lexer {\n  input: any;\n  char: number;\n  from: number;\n\n  constructor(expression: any) {\n    this.input = expression;\n    this.char = 1;\n    this.from = 1;\n  }\n\n  peek(i?: number) {\n    return this.input.charAt(i || 0);\n  }\n\n  skip(i?: number) {\n    i = i || 1;\n    this.char += i;\n    this.input = this.input.slice(i);\n  }\n\n  tokenize() {\n    const list = [];\n    let token = this.next();\n    while (token) {\n      list.push(token);\n      token = this.next();\n    }\n    return list;\n  }\n\n  next() {\n    this.from = this.char;\n\n    // Move to the next non-space character.\n    if (/\\s/.test(this.peek())) {\n      while (/\\s/.test(this.peek())) {\n        this.from += 1;\n        this.skip();\n      }\n\n      if (this.peek() === '') {\n        // EOL\n        return null;\n      }\n    }\n\n    let match = this.scanStringLiteral();\n    if (match) {\n      return match;\n    }\n\n    match = this.scanPunctuator() || this.scanNumericLiteral() || this.scanIdentifier() || this.scanTemplateSequence();\n\n    if (match) {\n      this.skip(match.value.length);\n      return match;\n    }\n\n    // No token could be matched, give up.\n    return null;\n  }\n\n  scanTemplateSequence() {\n    if (this.peek() === '[' && this.peek(1) === '[') {\n      return {\n        type: 'templateStart',\n        value: '[[',\n        pos: this.char,\n      };\n    }\n\n    if (this.peek() === ']' && this.peek(1) === ']') {\n      return {\n        type: 'templateEnd',\n        value: '[[',\n        pos: this.char,\n      };\n    }\n\n    return null;\n  }\n\n  /*\n   * Extract a JavaScript identifier out of the next sequence of\n   * characters or return 'null' if its not possible. In addition,\n   * to Identifier this method can also produce BooleanLiteral\n   * (true/false) and NullLiteral (null).\n   */\n  scanIdentifier() {\n    let id = '';\n    let index = 0;\n    let type, char;\n\n    // Detects any character in the Unicode categories \"Uppercase\n    // letter (Lu)\", \"Lowercase letter (Ll)\", \"Titlecase letter\n    // (Lt)\", \"Modifier letter (Lm)\", \"Other letter (Lo)\", or\n    // \"Letter number (Nl)\".\n    //\n    // Both approach and unicodeLetterTable were borrowed from\n    // Google's Traceur.\n\n    function isUnicodeLetter(code: number) {\n      for (let i = 0; i < unicodeLetterTable.length; ) {\n        if (code < unicodeLetterTable[i++]) {\n          return false;\n        }\n\n        if (code <= unicodeLetterTable[i++]) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    function isHexDigit(str: string) {\n      return /^[0-9a-fA-F]$/.test(str);\n    }\n\n    const readUnicodeEscapeSequence = _.bind(function(this: any) {\n      /*jshint validthis:true */\n      index += 1;\n\n      if (this.peek(index) !== 'u') {\n        return null;\n      }\n\n      const ch1 = this.peek(index + 1);\n      const ch2 = this.peek(index + 2);\n      const ch3 = this.peek(index + 3);\n      const ch4 = this.peek(index + 4);\n      let code;\n\n      if (isHexDigit(ch1) && isHexDigit(ch2) && isHexDigit(ch3) && isHexDigit(ch4)) {\n        code = parseInt(ch1 + ch2 + ch3 + ch4, 16);\n\n        if (isUnicodeLetter(code)) {\n          index += 5;\n          return '\\\\u' + ch1 + ch2 + ch3 + ch4;\n        }\n\n        return null;\n      }\n\n      return null;\n    }, this);\n\n    const getIdentifierStart = _.bind(function(this: any) {\n      /*jshint validthis:true */\n      const chr = this.peek(index);\n      const code = chr.charCodeAt(0);\n\n      if (chr === '*') {\n        index += 1;\n        return chr;\n      }\n\n      if (code === 92) {\n        return readUnicodeEscapeSequence();\n      }\n\n      if (code < 128) {\n        if (identifierStartTable[code]) {\n          index += 1;\n          return chr;\n        }\n\n        return null;\n      }\n\n      if (isUnicodeLetter(code)) {\n        index += 1;\n        return chr;\n      }\n\n      return null;\n    }, this);\n\n    const getIdentifierPart = _.bind(function(this: any) {\n      /*jshint validthis:true */\n      const chr = this.peek(index);\n      const code = chr.charCodeAt(0);\n\n      if (code === 92) {\n        return readUnicodeEscapeSequence();\n      }\n\n      if (code < 128) {\n        if (identifierPartTable[code]) {\n          index += 1;\n          return chr;\n        }\n\n        return null;\n      }\n\n      if (isUnicodeLetter(code)) {\n        index += 1;\n        return chr;\n      }\n\n      return null;\n    }, this);\n\n    char = getIdentifierStart();\n    if (char === null) {\n      return null;\n    }\n\n    id = char;\n    for (;;) {\n      char = getIdentifierPart();\n\n      if (char === null) {\n        break;\n      }\n\n      id += char;\n    }\n\n    switch (id) {\n      case 'true': {\n        type = 'bool';\n        break;\n      }\n      case 'false': {\n        type = 'bool';\n        break;\n      }\n      default:\n        type = 'identifier';\n    }\n\n    return {\n      type: type,\n      value: id,\n      pos: this.char,\n    };\n  }\n\n  /*\n   * Extract a numeric literal out of the next sequence of\n   * characters or return 'null' if its not possible. This method\n   * supports all numeric literals described in section 7.8.3\n   * of the EcmaScript 5 specification.\n   *\n   * This method's implementation was heavily influenced by the\n   * scanNumericLiteral function in the Esprima parser's source code.\n   */\n  scanNumericLiteral(): any {\n    let index = 0;\n    let value = '';\n    const length = this.input.length;\n    let char = this.peek(index);\n    let bad;\n\n    function isDecimalDigit(str: string) {\n      return /^[0-9]$/.test(str);\n    }\n\n    function isOctalDigit(str: string) {\n      return /^[0-7]$/.test(str);\n    }\n\n    function isHexDigit(str: string) {\n      return /^[0-9a-fA-F]$/.test(str);\n    }\n\n    function isIdentifierStart(ch: string) {\n      return ch === '$' || ch === '_' || ch === '\\\\' || (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z');\n    }\n\n    // handle negative num literals\n    if (char === '-') {\n      value += char;\n      index += 1;\n      char = this.peek(index);\n    }\n\n    // Numbers must start either with a decimal digit or a point.\n    if (char !== '.' && !isDecimalDigit(char)) {\n      return null;\n    }\n\n    if (char !== '.') {\n      value += this.peek(index);\n      index += 1;\n      char = this.peek(index);\n\n      if (value === '0') {\n        // Base-16 numbers.\n        if (char === 'x' || char === 'X') {\n          index += 1;\n          value += char;\n\n          while (index < length) {\n            char = this.peek(index);\n            if (!isHexDigit(char)) {\n              break;\n            }\n            value += char;\n            index += 1;\n          }\n\n          if (value.length <= 2) {\n            // 0x\n            return {\n              type: 'number',\n              value: value,\n              isMalformed: true,\n              pos: this.char,\n            };\n          }\n\n          if (index < length) {\n            char = this.peek(index);\n            if (isIdentifierStart(char)) {\n              return null;\n            }\n          }\n\n          return {\n            type: 'number',\n            value: value,\n            base: 16,\n            isMalformed: false,\n            pos: this.char,\n          };\n        }\n\n        // Base-8 numbers.\n        if (isOctalDigit(char)) {\n          index += 1;\n          value += char;\n          bad = false;\n\n          while (index < length) {\n            char = this.peek(index);\n\n            // Numbers like '019' (note the 9) are not valid octals\n            // but we still parse them and mark as malformed.\n\n            if (isDecimalDigit(char)) {\n              bad = true;\n            }\n            if (!isOctalDigit(char)) {\n              // if the char is a non punctuator then its not a valid number\n              if (!this.isPunctuator(char)) {\n                return null;\n              }\n              break;\n            }\n            value += char;\n            index += 1;\n          }\n\n          if (index < length) {\n            char = this.peek(index);\n            if (isIdentifierStart(char)) {\n              return null;\n            }\n          }\n\n          return {\n            type: 'number',\n            value: value,\n            base: 8,\n            isMalformed: bad,\n          };\n        }\n\n        // Decimal numbers that start with '0' such as '09' are illegal\n        // but we still parse them and return as malformed.\n\n        if (isDecimalDigit(char)) {\n          index += 1;\n          value += char;\n        }\n      }\n\n      while (index < length) {\n        char = this.peek(index);\n        if (!isDecimalDigit(char)) {\n          break;\n        }\n        value += char;\n        index += 1;\n      }\n    }\n\n    // Decimal digits.\n\n    if (char === '.') {\n      value += char;\n      index += 1;\n\n      while (index < length) {\n        char = this.peek(index);\n        if (!isDecimalDigit(char)) {\n          break;\n        }\n        value += char;\n        index += 1;\n      }\n    }\n\n    // Exponent part.\n\n    if (char === 'e' || char === 'E') {\n      value += char;\n      index += 1;\n      char = this.peek(index);\n\n      if (char === '+' || char === '-') {\n        value += this.peek(index);\n        index += 1;\n      }\n\n      char = this.peek(index);\n      if (isDecimalDigit(char)) {\n        value += char;\n        index += 1;\n\n        while (index < length) {\n          char = this.peek(index);\n          if (!isDecimalDigit(char)) {\n            break;\n          }\n          value += char;\n          index += 1;\n        }\n      } else {\n        return null;\n      }\n    }\n\n    if (index < length) {\n      char = this.peek(index);\n      if (!this.isPunctuator(char)) {\n        return null;\n      }\n    }\n\n    return {\n      type: 'number',\n      value: value,\n      base: 10,\n      pos: this.char,\n      isMalformed: !isFinite(+value),\n    };\n  }\n\n  isPunctuator(ch1: string) {\n    switch (ch1) {\n      case '.':\n      case '(':\n      case ')':\n      case ',':\n      case '{':\n      case '}':\n        return true;\n    }\n\n    return false;\n  }\n\n  scanPunctuator() {\n    const ch1 = this.peek();\n\n    if (this.isPunctuator(ch1)) {\n      return {\n        type: ch1,\n        value: ch1,\n        pos: this.char,\n      };\n    }\n\n    return null;\n  }\n\n  /*\n   * Extract a string out of the next sequence of characters and/or\n   * lines or return 'null' if its not possible. Since strings can\n   * span across multiple lines this method has to move the char\n   * pointer.\n   *\n   * This method recognizes pseudo-multiline JavaScript strings:\n   *\n   *   var str = \"hello\\\n   *   world\";\n   */\n  scanStringLiteral() {\n    /*jshint loopfunc:true */\n    const quote = this.peek();\n\n    // String must start with a quote.\n    if (quote !== '\"' && quote !== \"'\") {\n      return null;\n    }\n\n    let value = '';\n\n    this.skip();\n\n    while (this.peek() !== quote) {\n      if (this.peek() === '') {\n        // End Of Line\n        return {\n          type: 'string',\n          value: value,\n          isUnclosed: true,\n          quote: quote,\n          pos: this.char,\n        };\n      }\n\n      const char = this.peek();\n      const jump = 1; // A length of a jump, after we're done\n      // parsing this character.\n\n      value += char;\n      this.skip(jump);\n    }\n\n    this.skip();\n    return {\n      type: 'string',\n      value: value,\n      isUnclosed: false,\n      quote: quote,\n      pos: this.char,\n    };\n  }\n}\n","import { Lexer } from './lexer';\n\nexport class Parser {\n  expression: any;\n  lexer: Lexer;\n  tokens: any;\n  index: number;\n\n  constructor(expression: any) {\n    this.expression = expression;\n    this.lexer = new Lexer(expression);\n    this.tokens = this.lexer.tokenize();\n    this.index = 0;\n  }\n\n  getAst() {\n    return this.start();\n  }\n\n  start() {\n    try {\n      return this.functionCall() || this.metricExpression();\n    } catch (e) {\n      return {\n        type: 'error',\n        message: e.message,\n        pos: e.pos,\n      };\n    }\n  }\n\n  curlyBraceSegment() {\n    if (this.match('identifier', '{') || this.match('{')) {\n      let curlySegment = '';\n\n      while (!this.match('') && !this.match('}')) {\n        curlySegment += this.consumeToken().value;\n      }\n\n      if (!this.match('}')) {\n        this.errorMark(\"Expected closing '}'\");\n      }\n\n      curlySegment += this.consumeToken().value;\n\n      // if curly segment is directly followed by identifier\n      // include it in the segment\n      if (this.match('identifier')) {\n        curlySegment += this.consumeToken().value;\n      }\n\n      return {\n        type: 'segment',\n        value: curlySegment,\n      };\n    } else {\n      return null;\n    }\n  }\n\n  metricSegment() {\n    const curly = this.curlyBraceSegment();\n    if (curly) {\n      return curly;\n    }\n\n    if (this.match('identifier') || this.match('number')) {\n      // hack to handle float numbers in metric segments\n      const parts = this.consumeToken().value.split('.');\n      if (parts.length === 2) {\n        this.tokens.splice(this.index, 0, { type: '.' });\n        this.tokens.splice(this.index + 1, 0, {\n          type: 'number',\n          value: parts[1],\n        });\n      }\n\n      return {\n        type: 'segment',\n        value: parts[0],\n      };\n    }\n\n    if (!this.match('templateStart')) {\n      this.errorMark('Expected metric identifier');\n    }\n\n    this.consumeToken();\n\n    if (!this.match('identifier')) {\n      this.errorMark('Expected identifier after templateStart');\n    }\n\n    const node = {\n      type: 'template',\n      value: this.consumeToken().value,\n    };\n\n    if (!this.match('templateEnd')) {\n      this.errorMark('Expected templateEnd');\n    }\n\n    this.consumeToken();\n    return node;\n  }\n\n  metricExpression() {\n    if (!this.match('templateStart') && !this.match('identifier') && !this.match('number') && !this.match('{')) {\n      return null;\n    }\n\n    const node: any = {\n      type: 'metric',\n      segments: [],\n    };\n\n    node.segments.push(this.metricSegment());\n\n    while (this.match('.')) {\n      this.consumeToken();\n\n      const segment = this.metricSegment();\n      if (!segment) {\n        this.errorMark('Expected metric identifier');\n      }\n\n      node.segments.push(segment);\n    }\n\n    return node;\n  }\n\n  functionCall() {\n    if (!this.match('identifier', '(')) {\n      return null;\n    }\n\n    const node: any = {\n      type: 'function',\n      name: this.consumeToken().value,\n    };\n\n    // consume left parenthesis\n    this.consumeToken();\n\n    node.params = this.functionParameters();\n\n    if (!this.match(')')) {\n      this.errorMark('Expected closing parenthesis');\n    }\n\n    this.consumeToken();\n\n    return node;\n  }\n\n  boolExpression() {\n    if (!this.match('bool')) {\n      return null;\n    }\n\n    return {\n      type: 'bool',\n      value: this.consumeToken().value === 'true',\n    };\n  }\n\n  functionParameters(): any {\n    if (this.match(')') || this.match('')) {\n      return [];\n    }\n\n    const param =\n      this.functionCall() ||\n      this.numericLiteral() ||\n      this.seriesRefExpression() ||\n      this.boolExpression() ||\n      this.metricExpression() ||\n      this.stringLiteral();\n\n    if (!this.match(',')) {\n      return [param];\n    }\n\n    this.consumeToken();\n    return [param].concat(this.functionParameters());\n  }\n\n  seriesRefExpression() {\n    if (!this.match('identifier')) {\n      return null;\n    }\n\n    const value = this.tokens[this.index].value;\n    if (!value.match(/\\#[A-Z]/)) {\n      return null;\n    }\n\n    const token = this.consumeToken();\n\n    return {\n      type: 'series-ref',\n      value: token.value,\n    };\n  }\n\n  numericLiteral() {\n    if (!this.match('number')) {\n      return null;\n    }\n\n    return {\n      type: 'number',\n      value: parseFloat(this.consumeToken().value),\n    };\n  }\n\n  stringLiteral() {\n    if (!this.match('string')) {\n      return null;\n    }\n\n    const token = this.consumeToken();\n    if (token.isUnclosed) {\n      throw { message: 'Unclosed string parameter', pos: token.pos };\n    }\n\n    return {\n      type: 'string',\n      value: token.value,\n    };\n  }\n\n  errorMark(text: string) {\n    const currentToken = this.tokens[this.index];\n    const type = currentToken ? currentToken.type : 'end of string';\n    throw {\n      message: text + ' instead found ' + type,\n      pos: currentToken ? currentToken.pos : this.lexer.char,\n    };\n  }\n\n  // returns token value and incre\n  consumeToken() {\n    this.index++;\n    return this.tokens[this.index - 1];\n  }\n\n  matchToken(type: any, index: number) {\n    const token = this.tokens[this.index + index];\n    return (token === undefined && type === '') || (token && token.type === type);\n  }\n\n  match(token1: any, token2?: any) {\n    return this.matchToken(token1, 0) && (!token2 || this.matchToken(token2, 1));\n  }\n}\n","import _ from 'lodash';\nimport { Parser } from './parser';\nimport { TemplateSrv } from 'app/features/templating/template_srv';\nimport { ScopedVars } from '@grafana/data';\n\nexport default class GraphiteQuery {\n  datasource: any;\n  target: any;\n  functions: any[];\n  segments: any[];\n  tags: any[];\n  error: any;\n  seriesByTagUsed: boolean;\n  checkOtherSegmentsIndex: number;\n  removeTagValue: string;\n  templateSrv: any;\n  scopedVars: any;\n\n  /** @ngInject */\n  constructor(datasource: any, target: any, templateSrv?: TemplateSrv, scopedVars?: ScopedVars) {\n    this.datasource = datasource;\n    this.target = target;\n    this.templateSrv = templateSrv;\n    this.scopedVars = scopedVars;\n    this.parseTarget();\n\n    this.removeTagValue = '-- remove tag --';\n  }\n\n  parseTarget() {\n    this.functions = [];\n    this.segments = [];\n    this.tags = [];\n    this.seriesByTagUsed = false;\n    this.error = null;\n\n    if (this.target.textEditor) {\n      return;\n    }\n\n    const parser = new Parser(this.target.target);\n    const astNode = parser.getAst();\n    if (astNode === null) {\n      this.checkOtherSegmentsIndex = 0;\n      return;\n    }\n\n    if (astNode.type === 'error') {\n      this.error = astNode.message + ' at position: ' + astNode.pos;\n      this.target.textEditor = true;\n      return;\n    }\n\n    try {\n      this.parseTargetRecursive(astNode, null);\n    } catch (err) {\n      console.log('error parsing target:', err.message);\n      this.error = err.message;\n      this.target.textEditor = true;\n    }\n\n    this.checkOtherSegmentsIndex = this.segments.length - 1;\n  }\n\n  getSegmentPathUpTo(index: number) {\n    const arr = this.segments.slice(0, index);\n\n    return _.reduce(\n      arr,\n      (result, segment) => {\n        return result ? result + '.' + segment.value : segment.value;\n      },\n      ''\n    );\n  }\n\n  parseTargetRecursive(astNode: any, func: any): any {\n    if (astNode === null) {\n      return null;\n    }\n\n    switch (astNode.type) {\n      case 'function':\n        const innerFunc = this.datasource.createFuncInstance(astNode.name, {\n          withDefaultParams: false,\n        });\n        _.each(astNode.params, param => {\n          this.parseTargetRecursive(param, innerFunc);\n        });\n\n        innerFunc.updateText();\n        this.functions.push(innerFunc);\n\n        // extract tags from seriesByTag function and hide function\n        if (innerFunc.def.name === 'seriesByTag' && !this.seriesByTagUsed) {\n          this.seriesByTagUsed = true;\n          innerFunc.hidden = true;\n          this.tags = this.splitSeriesByTagParams(innerFunc);\n        }\n\n        break;\n      case 'series-ref':\n        if (this.segments.length > 0 || this.getSeriesByTagFuncIndex() >= 0) {\n          this.addFunctionParameter(func, astNode.value);\n        } else {\n          this.segments.push(astNode);\n        }\n        break;\n      case 'bool':\n      case 'string':\n      case 'number':\n        this.addFunctionParameter(func, astNode.value);\n        break;\n      case 'metric':\n        if (this.segments.length || this.tags.length) {\n          this.addFunctionParameter(func, _.join(_.map(astNode.segments, 'value'), '.'));\n        } else {\n          this.segments = astNode.segments;\n        }\n        break;\n    }\n  }\n\n  updateSegmentValue(segment: any, index: number) {\n    this.segments[index].value = segment.value;\n  }\n\n  addSelectMetricSegment() {\n    this.segments.push({ value: 'select metric' });\n  }\n\n  addFunction(newFunc: any) {\n    this.functions.push(newFunc);\n  }\n\n  addFunctionParameter(func: any, value: string) {\n    if (func.params.length >= func.def.params.length && !_.get(_.last(func.def.params), 'multiple', false)) {\n      throw { message: 'too many parameters for function ' + func.def.name };\n    }\n    func.params.push(value);\n  }\n\n  removeFunction(func: any) {\n    this.functions = _.without(this.functions, func);\n  }\n\n  moveFunction(func: any, offset: number) {\n    const index = this.functions.indexOf(func);\n    // @ts-ignore\n    _.move(this.functions, index, index + offset);\n  }\n\n  updateModelTarget(targets: any) {\n    const wrapFunction = (target: string, func: any) => {\n      return func.render(target, (value: string) => {\n        return this.templateSrv.replace(value, this.scopedVars);\n      });\n    };\n\n    if (!this.target.textEditor) {\n      const metricPath = this.getSegmentPathUpTo(this.segments.length).replace(/\\.select metric$/, '');\n      this.target.target = _.reduce(this.functions, wrapFunction, metricPath);\n    }\n\n    this.updateRenderedTarget(this.target, targets);\n\n    // loop through other queries and update targetFull as needed\n    for (const target of targets || []) {\n      if (target.refId !== this.target.refId) {\n        this.updateRenderedTarget(target, targets);\n      }\n    }\n  }\n\n  updateRenderedTarget(target: { refId: string | number; target: any; targetFull: any }, targets: any) {\n    // render nested query\n    const targetsByRefId = _.keyBy(targets, 'refId');\n\n    // no references to self\n    delete targetsByRefId[target.refId];\n\n    const nestedSeriesRefRegex = /\\#([A-Z])/g;\n    let targetWithNestedQueries = target.target;\n\n    // Use ref count to track circular references\n    function countTargetRefs(targetsByRefId: any, refId: string) {\n      let refCount = 0;\n      _.each(targetsByRefId, (t, id) => {\n        if (id !== refId) {\n          const match = nestedSeriesRefRegex.exec(t.target);\n          const count = match && match.length ? match.length - 1 : 0;\n          refCount += count;\n        }\n      });\n      targetsByRefId[refId].refCount = refCount;\n    }\n    _.each(targetsByRefId, (t, id) => {\n      countTargetRefs(targetsByRefId, id);\n    });\n\n    // Keep interpolating until there are no query references\n    // The reason for the loop is that the referenced query might contain another reference to another query\n    while (targetWithNestedQueries.match(nestedSeriesRefRegex)) {\n      const updated = targetWithNestedQueries.replace(nestedSeriesRefRegex, (match: string, g1: string) => {\n        const t = targetsByRefId[g1];\n        if (!t) {\n          return match;\n        }\n\n        // no circular references\n        if (t.refCount === 0) {\n          delete targetsByRefId[g1];\n        }\n        t.refCount--;\n\n        return t.target;\n      });\n\n      if (updated === targetWithNestedQueries) {\n        break;\n      }\n\n      targetWithNestedQueries = updated;\n    }\n\n    delete target.targetFull;\n    if (target.target !== targetWithNestedQueries) {\n      target.targetFull = targetWithNestedQueries;\n    }\n  }\n\n  splitSeriesByTagParams(func: { params: any }) {\n    const tagPattern = /([^\\!=~]+)(\\!?=~?)(.*)/;\n    return _.flatten(\n      _.map(func.params, (param: string) => {\n        const matches = tagPattern.exec(param);\n        if (matches) {\n          const tag = matches.slice(1);\n          if (tag.length === 3) {\n            return {\n              key: tag[0],\n              operator: tag[1],\n              value: tag[2],\n            };\n          }\n        }\n        return [];\n      })\n    );\n  }\n\n  getSeriesByTagFuncIndex() {\n    return _.findIndex(this.functions, func => func.def.name === 'seriesByTag');\n  }\n\n  getSeriesByTagFunc() {\n    const seriesByTagFuncIndex = this.getSeriesByTagFuncIndex();\n    if (seriesByTagFuncIndex >= 0) {\n      return this.functions[seriesByTagFuncIndex];\n    } else {\n      return undefined;\n    }\n  }\n\n  addTag(tag: { key: any; operator: string; value: string }) {\n    const newTagParam = renderTagString(tag);\n    this.getSeriesByTagFunc().params.push(newTagParam);\n    this.tags.push(tag);\n  }\n\n  removeTag(index: number) {\n    this.getSeriesByTagFunc().params.splice(index, 1);\n    this.tags.splice(index, 1);\n  }\n\n  updateTag(tag: { key: string }, tagIndex: number) {\n    this.error = null;\n\n    if (tag.key === this.removeTagValue) {\n      this.removeTag(tagIndex);\n      return;\n    }\n\n    const newTagParam = renderTagString(tag);\n    this.getSeriesByTagFunc().params[tagIndex] = newTagParam;\n    this.tags[tagIndex] = tag;\n  }\n\n  renderTagExpressions(excludeIndex = -1) {\n    return _.compact(\n      _.map(this.tags, (tagExpr, index) => {\n        // Don't render tag that we want to lookup\n        if (index !== excludeIndex) {\n          return tagExpr.key + tagExpr.operator + tagExpr.value;\n        }\n      })\n    );\n  }\n}\n\nfunction renderTagString(tag: { key: any; operator?: any; value?: any }) {\n  return tag.key + tag.operator + tag.value;\n}\n","import './add_graphite_func';\nimport './func_editor';\n\nimport _ from 'lodash';\nimport GraphiteQuery from './graphite_query';\nimport { QueryCtrl } from 'app/plugins/sdk';\nimport appEvents from 'app/core/app_events';\nimport { auto } from 'angular';\nimport { TemplateSrv } from 'app/features/templating/template_srv';\nimport { AppEvents } from '@grafana/data';\n\nconst GRAPHITE_TAG_OPERATORS = ['=', '!=', '=~', '!=~'];\nconst TAG_PREFIX = 'tag: ';\n\nexport class GraphiteQueryCtrl extends QueryCtrl {\n  static templateUrl = 'partials/query.editor.html';\n\n  queryModel: GraphiteQuery;\n  segments: any[];\n  addTagSegments: any[];\n  removeTagValue: string;\n  supportsTags: boolean;\n  paused: boolean;\n\n  /** @ngInject */\n  constructor(\n    $scope: any,\n    $injector: auto.IInjectorService,\n    private uiSegmentSrv: any,\n    private templateSrv: TemplateSrv,\n    $timeout: any\n  ) {\n    super($scope, $injector);\n    this.supportsTags = this.datasource.supportsTags;\n    this.paused = false;\n    this.target.target = this.target.target || '';\n\n    this.datasource.waitForFuncDefsLoaded().then(() => {\n      this.queryModel = new GraphiteQuery(this.datasource, this.target, templateSrv);\n      this.buildSegments();\n    });\n\n    this.removeTagValue = '-- remove tag --';\n  }\n\n  parseTarget() {\n    this.queryModel.parseTarget();\n    this.buildSegments();\n  }\n\n  toggleEditorMode() {\n    this.target.textEditor = !this.target.textEditor;\n    this.parseTarget();\n  }\n\n  buildSegments() {\n    this.segments = _.map(this.queryModel.segments, segment => {\n      return this.uiSegmentSrv.newSegment(segment);\n    });\n\n    const checkOtherSegmentsIndex = this.queryModel.checkOtherSegmentsIndex || 0;\n    this.checkOtherSegments(checkOtherSegmentsIndex);\n\n    if (this.queryModel.seriesByTagUsed) {\n      this.fixTagSegments();\n    }\n  }\n\n  addSelectMetricSegment() {\n    this.queryModel.addSelectMetricSegment();\n    this.segments.push(this.uiSegmentSrv.newSelectMetric());\n  }\n\n  checkOtherSegments(fromIndex: number) {\n    if (this.queryModel.segments.length === 1 && this.queryModel.segments[0].type === 'series-ref') {\n      return;\n    }\n\n    if (fromIndex === 0) {\n      this.addSelectMetricSegment();\n      return;\n    }\n\n    const path = this.queryModel.getSegmentPathUpTo(fromIndex + 1);\n    if (path === '') {\n      return Promise.resolve();\n    }\n\n    return this.datasource\n      .metricFindQuery(path)\n      .then((segments: any) => {\n        if (segments.length === 0) {\n          if (path !== '') {\n            this.queryModel.segments = this.queryModel.segments.splice(0, fromIndex);\n            this.segments = this.segments.splice(0, fromIndex);\n            this.addSelectMetricSegment();\n          }\n        } else if (segments[0].expandable) {\n          if (this.segments.length === fromIndex) {\n            this.addSelectMetricSegment();\n          } else {\n            return this.checkOtherSegments(fromIndex + 1);\n          }\n        }\n      })\n      .catch((err: any) => {\n        appEvents.emit(AppEvents.alertError, ['Error', err]);\n      });\n  }\n\n  setSegmentFocus(segmentIndex: any) {\n    _.each(this.segments, (segment, index) => {\n      segment.focus = segmentIndex === index;\n    });\n  }\n\n  getAltSegments(index: number, prefix: string) {\n    let query = prefix && prefix.length > 0 ? '*' + prefix + '*' : '*';\n    if (index > 0) {\n      query = this.queryModel.getSegmentPathUpTo(index) + '.' + query;\n    }\n    const options = {\n      range: this.panelCtrl.range,\n      requestId: 'get-alt-segments',\n    };\n\n    return this.datasource\n      .metricFindQuery(query, options)\n      .then((segments: any[]) => {\n        const altSegments = _.map(segments, segment => {\n          return this.uiSegmentSrv.newSegment({\n            value: segment.text,\n            expandable: segment.expandable,\n          });\n        });\n\n        if (index > 0 && altSegments.length === 0) {\n          return altSegments;\n        }\n\n        // add query references\n        if (index === 0) {\n          _.eachRight(this.panelCtrl.panel.targets, target => {\n            if (target.refId === this.queryModel.target.refId) {\n              return;\n            }\n\n            altSegments.unshift(\n              this.uiSegmentSrv.newSegment({\n                type: 'series-ref',\n                value: '#' + target.refId,\n                expandable: false,\n              })\n            );\n          });\n        }\n\n        // add template variables\n        _.eachRight(this.templateSrv.variables, variable => {\n          altSegments.unshift(\n            this.uiSegmentSrv.newSegment({\n              type: 'template',\n              value: '$' + variable.name,\n              expandable: true,\n            })\n          );\n        });\n\n        // add wildcard option\n        altSegments.unshift(this.uiSegmentSrv.newSegment('*'));\n\n        if (this.supportsTags && index === 0) {\n          this.removeTaggedEntry(altSegments);\n          return this.addAltTagSegments(prefix, altSegments);\n        } else {\n          return altSegments;\n        }\n      })\n      .catch(\n        (err: any): any[] => {\n          return [];\n        }\n      );\n  }\n\n  addAltTagSegments(prefix: string, altSegments: any[]) {\n    return this.getTagsAsSegments(prefix).then((tagSegments: any[]) => {\n      tagSegments = _.map(tagSegments, segment => {\n        segment.value = TAG_PREFIX + segment.value;\n        return segment;\n      });\n      return altSegments.concat(...tagSegments);\n    });\n  }\n\n  removeTaggedEntry(altSegments: any[]) {\n    altSegments = _.remove(altSegments, s => s.value === '_tagged');\n  }\n\n  segmentValueChanged(segment: { type: string; value: string; expandable: any }, segmentIndex: number) {\n    this.error = null;\n    this.queryModel.updateSegmentValue(segment, segmentIndex);\n\n    if (this.queryModel.functions.length > 0 && this.queryModel.functions[0].def.fake) {\n      this.queryModel.functions = [];\n    }\n\n    if (segment.type === 'tag') {\n      const tag = removeTagPrefix(segment.value);\n      this.pause();\n      this.addSeriesByTagFunc(tag);\n      return;\n    }\n\n    if (segment.expandable) {\n      return this.checkOtherSegments(segmentIndex + 1).then(() => {\n        this.setSegmentFocus(segmentIndex + 1);\n        this.targetChanged();\n      });\n    } else {\n      this.spliceSegments(segmentIndex + 1);\n    }\n\n    this.setSegmentFocus(segmentIndex + 1);\n    this.targetChanged();\n  }\n\n  spliceSegments(index: any) {\n    this.segments = this.segments.splice(0, index);\n    this.queryModel.segments = this.queryModel.segments.splice(0, index);\n  }\n\n  emptySegments() {\n    this.queryModel.segments = [];\n    this.segments = [];\n  }\n\n  targetTextChanged() {\n    this.updateModelTarget();\n    this.refresh();\n  }\n\n  updateModelTarget() {\n    this.queryModel.updateModelTarget(this.panelCtrl.panel.targets);\n  }\n\n  targetChanged() {\n    if (this.queryModel.error) {\n      return;\n    }\n\n    const oldTarget = this.queryModel.target.target;\n    this.updateModelTarget();\n\n    if (this.queryModel.target !== oldTarget && !this.paused) {\n      this.panelCtrl.refresh();\n    }\n  }\n\n  addFunction(funcDef: any) {\n    const newFunc = this.datasource.createFuncInstance(funcDef, {\n      withDefaultParams: true,\n    });\n    newFunc.added = true;\n    this.queryModel.addFunction(newFunc);\n    this.smartlyHandleNewAliasByNode(newFunc);\n\n    if (this.segments.length === 1 && this.segments[0].fake) {\n      this.emptySegments();\n    }\n\n    if (!newFunc.params.length && newFunc.added) {\n      this.targetChanged();\n    }\n\n    if (newFunc.def.name === 'seriesByTag') {\n      this.parseTarget();\n    }\n  }\n\n  removeFunction(func: any) {\n    this.queryModel.removeFunction(func);\n    this.targetChanged();\n  }\n\n  moveFunction(func: any, offset: any) {\n    this.queryModel.moveFunction(func, offset);\n    this.targetChanged();\n  }\n\n  addSeriesByTagFunc(tag: string) {\n    const newFunc = this.datasource.createFuncInstance('seriesByTag', {\n      withDefaultParams: false,\n    });\n    const tagParam = `${tag}=`;\n    newFunc.params = [tagParam];\n    this.queryModel.addFunction(newFunc);\n    newFunc.added = true;\n\n    this.emptySegments();\n    this.targetChanged();\n    this.parseTarget();\n  }\n\n  smartlyHandleNewAliasByNode(func: { def: { name: string }; params: number[]; added: boolean }) {\n    if (func.def.name !== 'aliasByNode') {\n      return;\n    }\n\n    for (let i = 0; i < this.segments.length; i++) {\n      if (this.segments[i].value.indexOf('*') >= 0) {\n        func.params[0] = i;\n        func.added = false;\n        this.targetChanged();\n        return;\n      }\n    }\n  }\n\n  getAllTags() {\n    return this.datasource.getTags().then((values: any[]) => {\n      const altTags = _.map(values, 'text');\n      altTags.splice(0, 0, this.removeTagValue);\n      return mapToDropdownOptions(altTags);\n    });\n  }\n\n  getTags(index: number, tagPrefix: any) {\n    const tagExpressions = this.queryModel.renderTagExpressions(index);\n    return this.datasource.getTagsAutoComplete(tagExpressions, tagPrefix).then((values: any) => {\n      const altTags = _.map(values, 'text');\n      altTags.splice(0, 0, this.removeTagValue);\n      return mapToDropdownOptions(altTags);\n    });\n  }\n\n  getTagsAsSegments(tagPrefix: string) {\n    const tagExpressions = this.queryModel.renderTagExpressions();\n    return this.datasource.getTagsAutoComplete(tagExpressions, tagPrefix).then((values: any) => {\n      return _.map(values, val => {\n        return this.uiSegmentSrv.newSegment({\n          value: val.text,\n          type: 'tag',\n          expandable: false,\n        });\n      });\n    });\n  }\n\n  getTagOperators() {\n    return mapToDropdownOptions(GRAPHITE_TAG_OPERATORS);\n  }\n\n  getAllTagValues(tag: { key: any }) {\n    const tagKey = tag.key;\n    return this.datasource.getTagValues(tagKey).then((values: any[]) => {\n      const altValues = _.map(values, 'text');\n      return mapToDropdownOptions(altValues);\n    });\n  }\n\n  getTagValues(tag: { key: any }, index: number, valuePrefix: any) {\n    const tagExpressions = this.queryModel.renderTagExpressions(index);\n    const tagKey = tag.key;\n    return this.datasource.getTagValuesAutoComplete(tagExpressions, tagKey, valuePrefix).then((values: any[]) => {\n      const altValues = _.map(values, 'text');\n      // Add template variables as additional values\n      _.eachRight(this.templateSrv.variables, variable => {\n        altValues.push('${' + variable.name + ':regex}');\n      });\n      return mapToDropdownOptions(altValues);\n    });\n  }\n\n  tagChanged(tag: any, tagIndex: any) {\n    this.queryModel.updateTag(tag, tagIndex);\n    this.targetChanged();\n  }\n\n  addNewTag(segment: { value: any }) {\n    const newTagKey = segment.value;\n    const newTag = { key: newTagKey, operator: '=', value: '' };\n    this.queryModel.addTag(newTag);\n    this.targetChanged();\n    this.fixTagSegments();\n  }\n\n  removeTag(index: any) {\n    this.queryModel.removeTag(index);\n    this.targetChanged();\n  }\n\n  fixTagSegments() {\n    // Adding tag with the same name as just removed works incorrectly if single segment is used (instead of array)\n    this.addTagSegments = [this.uiSegmentSrv.newPlusButton()];\n  }\n\n  showDelimiter(index: number) {\n    return index !== this.queryModel.tags.length - 1;\n  }\n\n  pause() {\n    this.paused = true;\n  }\n\n  unpause() {\n    this.paused = false;\n    this.panelCtrl.refresh();\n  }\n\n  getCollapsedText() {\n    return this.target.target;\n  }\n}\n\nfunction mapToDropdownOptions(results: any[]) {\n  return _.map(results, value => {\n    return { text: value, value: value };\n  });\n}\n\nfunction removeTagPrefix(value: string): string {\n  return value.replace(TAG_PREFIX, '');\n}\n","import DatasourceSrv from 'app/features/plugins/datasource_srv';\nimport { GraphiteType } from './types';\n\nexport class GraphiteConfigCtrl {\n  static templateUrl = 'public/app/plugins/datasource/graphite/partials/config.html';\n  datasourceSrv: any;\n  current: any;\n  graphiteTypes: any;\n\n  /** @ngInject */\n  constructor($scope: any, datasourceSrv: DatasourceSrv) {\n    this.datasourceSrv = datasourceSrv;\n    this.current.jsonData = this.current.jsonData || {};\n    this.current.jsonData.graphiteVersion = this.current.jsonData.graphiteVersion || '0.9';\n    this.current.jsonData.graphiteType = this.current.jsonData.graphiteType || GraphiteType.Default;\n    this.autoDetectGraphiteVersion();\n    this.graphiteTypes = Object.keys(GraphiteType).map((key: string) => ({\n      name: key,\n      value: (GraphiteType as any)[key],\n    }));\n  }\n\n  autoDetectGraphiteVersion() {\n    if (!this.current.id) {\n      return;\n    }\n\n    this.datasourceSrv\n      .loadDatasource(this.current.name)\n      .then((ds: any) => {\n        return ds.getVersion();\n      })\n      .then((version: any) => {\n        if (!version) {\n          return;\n        }\n\n        this.graphiteVersions.push({ name: version, value: version });\n        this.current.jsonData.graphiteVersion = version;\n      });\n  }\n\n  graphiteVersions = [\n    { name: '0.9.x', value: '0.9' },\n    { name: '1.0.x', value: '1.0' },\n    { name: '1.1.x', value: '1.1' },\n  ];\n}\n","import { GraphiteDatasource } from './datasource';\nimport { GraphiteQueryCtrl } from './query_ctrl';\nimport { GraphiteConfigCtrl } from './config_ctrl';\n\nclass AnnotationsQueryCtrl {\n  static templateUrl = 'partials/annotations.editor.html';\n}\n\nexport {\n  GraphiteDatasource as Datasource,\n  GraphiteQueryCtrl as QueryCtrl,\n  GraphiteConfigCtrl as ConfigCtrl,\n  AnnotationsQueryCtrl,\n};\n"],"sourceRoot":""}