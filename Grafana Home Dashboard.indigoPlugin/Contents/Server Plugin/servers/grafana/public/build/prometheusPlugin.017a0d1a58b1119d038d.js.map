{"version":3,"sources":["webpack:///./public/app/plugins/datasource/prometheus/metric_find_query.ts","webpack:///./public/app/plugins/datasource/prometheus/result_transformer.ts","webpack:///./public/app/plugins/datasource/prometheus/language_provider.ts","webpack:///./public/app/plugins/datasource/prometheus/query_hints.ts","webpack:///./public/app/plugins/datasource/prometheus/datasource.ts","webpack:///./public/app/plugins/datasource/prometheus/components/PromQueryField.tsx","webpack:///./public/app/plugins/datasource/prometheus/components/PromLink.tsx","webpack:///./public/app/plugins/datasource/prometheus/components/PromQueryEditor.tsx","webpack:///./public/app/plugins/datasource/prometheus/components/PromCheatSheet.tsx","webpack:///./public/app/plugins/datasource/prometheus/components/PromExploreExtraField.tsx","webpack:///./public/app/plugins/datasource/prometheus/components/PromExploreQueryEditor.tsx","webpack:///./public/app/plugins/datasource/prometheus/configuration/PromSettings.tsx","webpack:///./public/app/plugins/datasource/prometheus/module.ts","webpack:///./public/app/plugins/datasource/prometheus/configuration/ConfigEditor.tsx","webpack:///./public/app/core/utils/CancelablePromise.ts"],"names":["PrometheusMetricFindQuery","datasource","query","this","range","getTimeSrv","timeRange","match","labelNamesQuery","labelValuesQuery","metricNamesQuery","metricNameQuery","queryResultQuery","metricNameAndLabelsQuery","metadataRequest","then","result","_","map","data","value","text","label","metric","url","start","getPrometheusTime","from","end","to","params","URLSearchParams","toString","_labels","filter","uniq","expandable","metricFilterPattern","chain","metricName","RegExp","test","matchedMetricName","instantQuery","expr","performInstantQuery","metricData","__name__","v","k","join","self","getOriginalMetricName","ResultTransformer","templateSrv","response","options","prometheusResult","format","transformMetricDataToTable","responseListLength","refId","meta","valueWithRefId","seriesList","push","transformMetricData","sort","sortSeriesByLabel","transformToHistogramOverTime","resultType","transformInstantMetricData","dps","createLabelInfo","name","labels","title","stepMs","parseFloat","step","baseTimestamp","undefined","values","Error","dpValue","isNaN","timestamp","t","endTimestamp","datapoints","target","tags","md","resultCount","i","j","table","TableModel","metricLabels","length","each","series","hasOwnProperty","sortedLabels","keys","columns","type","FieldType","time","labelIndex","filterable","valueText","reordered","rows","legendFormat","renderTemplate","replace","labelsWithoutName","labelPart","formatLabels","labelData","Object","entries","aliasPattern","aliasData","g1","topSeries","bottomSeries","bottomPoint","s1","s2","le1","le2","parseHistogramLabel","err","console","log","le","Infinity","Number","DEFAULT_KEYS","wrapLabel","setFunctionKind","suggestion","kind","PREFIX_DELIMITER_REGEX","PromQlLanguageProvider","initialValues","labelsCache","LRU","request","defaultValue","res","json","body","error","lookupsDisabled","metrics","lookupMetricsThreshold","fixSummariesMetadata","metricsMetadata","processHistogramMetrics","processHistogramLabels","histogramMetrics","slice","provideCompletionItems","prefix","labelKey","wrapperClasses","context","history","empty","document","selectedLines","getTextsAtRange","selection","currentLine","size","first","getText","nextCharacter","anchor","offset","tokenRecognized","prefixUnrecognized","noSuffix","safePrefix","operatorsPattern","isNextOperand","includes","getRangeCompletionItems","getLabelCompletionItems","getAggregationCompletionItems","getEmptyCompletionItems","getBeginningCompletionItems","getTermCompletionItems","suggestions","historyItems","h","take","item","cutoffTs","Date","now","historyForItem","ts","count","recent","hint","lastQueried","dateTime","fromNow","documentation","addHistoryMetadata","prefixMatch","skipSort","items","FUNCTIONS","m","metadata","help","toUpperCase","addMetricsMetadata","queryText","getBlocks","reduce","block","blockText","anchorBlock","key","queryOffset","openParensAggregationIndex","lastIndexOf","openParensSelectorIndex","closeParensSelectorIndex","indexOf","closeParensAggregationIndex","selectorString","selector","parseSelector","getLabelValues","labelValues","line","cursorOffset","suffix","substr","isValueStart","isValueEnd","isPreValue","hasValuePrefix","parsedSelector","containsMetric","existingKeys","labelKeys","warn","possibleKeys","difference","newItems","newSuggestion","fetchLabelValues","fetchSeriesLabels","withName","tRange","getTimeRange","set","roundToMinutes","append","cacheKey","get","processLabels","fetchDefaultLabels","once","Promise","all","acc","assign","s","split","pop","trimLeft","RATE_RANGES","seconds","Math","floor","PromqlSyntax","LanguageProvider","getQueryHints","hints","trim","fix","action","nameMatch","counterNameMetric","languageProvider","certain","find","toLowerCase","metricRegex","simpleMetric","verb","ruleMappings","mapping","mappingForQuery","ruleName","search","preventSubmit","PrometheusDatasource","instanceSettings","init","loadRules","processResult","transformerOptions","preferredVisualisationType","instant","resultTransformer","transform","prepareTargets","queries","activeTargets","targets","hide","requestId","panelId","app","CoreApp","Explore","showingTable","instantTarget","cloneDeep","maxDataPoints","createQuery","showingGraph","handleErrors","message","statusText","safeStringifyValue","status","createAnnotationQueryOptions","annotation","interval","editorSrc","basicAuth","withCredentials","jsonData","timeInterval","queryTimeout","httpMethod","directUrl","PrometheusLanguageProvider","disableMetricsLookup","customQueryParameters","httpOptions","headers","dashboardId","defaults","method","encodeURIComponent","transformRequest","$","param","Authorization","getBackendSrv","datasourceRequest","_request","silent","variable","multi","includeAll","prometheusRegularEscape","prometheusSpecialRegexEscape","escapedValues","val","variableExists","exploreQuery","panelsQuery","of","state","LoadingState","Done","runningQueriesCount","subQueries","index","performTimeSeriesQuery","pipe","tap","cancelled","Loading","merge","observables","forkJoin","results","current","hinting","ceil","kbn","interval_to_seconds","minInterval","scopedVars","intervalFactor","adjustedInterval","adjustInterval","getRangeScopedVars","__interval","__interval_ms","getAdhocFilters","operator","addLabelToQuery","interpolateQueryExpr","adjusted","utcOffsetSec","alignedEnd","alignedStart","alignRange","utcOffset","_addTracingHeaders","safeInterval","max","catch","metricsNameCache","expire","resolve","interval_to_ms","interpolated","metricFindQuery","process","msRange","diff","sRange","round","__range_ms","__range_s","__range","tagKeys","titleFormat","textFormat","queryOptions","queryModel","eventList","splitKeys","forEach","timestampValue","useValueForTime","activeValuesTimestamps","latestEvent","timeEnd","getTime","expandedQueries","groups","extractRuleMappingFromGroups","expression","expandRecordingRules","date","roundUp","dateMath","parse","valueOf","DataSourceApi","group","rules","rule","HISTOGRAM_GROUP","willApplySuggestion","typeaheadContext","typeaheadText","nextChar","DOMUtil","getNextCharacter","PromQueryField","props","refreshHint","isDataFrame","toLegacyResponseData","setState","refreshMetrics","syntaxLoaded","Prism","languages","syntax","languageProviderInitializationPromise","makePromiseCancelable","promise","remaining","task","onUpdateLanguage","isCanceled","onChangeMetrics","selectedOptions","selectedOption","children","onChangeQuery","override","onChange","onRunQuery","onClickHintFix","modifyQuery","metricsByPrefix","ruleRegex","ruleNames","rulesOption","metricsOptions","groupBy","metricsForPrefix","option","sortBy","groupMetricsByPrefix","histogramOptions","hm","isLeaf","onTypeahead","typeahead","plugins","BracesPlugin","SlatePrism","onlyIn","node","getSyntax","cancel","prevProps","metricsLookupDisabled","hasSyntax","ExtraFieldElement","cleanText","chooserText","buttonDisabled","className","disabled","additionalPlugins","onWillApplySuggestion","onBlur","placeholder","portalOrigin","onClick","React","PureComponent","PromLink","href","panelData","getExternalLink","datasourceName","getDatasourceSrv","rangeDiff","endTime","utc","args","rel","Component","Switch","LegacyForms","FORMAT_OPTIONS","INTERVAL_FACTOR_OPTIONS","PromQueryEditor","onFieldChange","onFormatChange","formatOption","onInstantChange","e","checked","onIntervalChange","currentTarget","onIntervalFactorChange","intervalFactorOption","onLegendChange","Boolean","width","tooltip","isSearchable","CHEAT_SHEET_ITEMS","PromExploreExtraField","onChangeFunc","onKeyDownFunc","hasTooltip","tooltipContent","aria-label","onKeyDown","memo","onChangeQueryStep","Select","Input","FormField","PromSettings","onOptionsChange","labelWidth","inputEl","spellCheck","onChangeHandler","validationEvents","promSettingsValidationEvents","o","labelClass","onUpdateDatasourceJsonDataOptionChecked","EventsWithValidation","regexValidation","getValueFromEventItem","eventItem","PrometheusAnnotationsQueryCtrl","stepDefaultValuePlaceholder","templateUrl","plugin","DataSourcePlugin","setQueryEditor","setConfigEditor","defaultUrl","dataSourceConfig","showAccessOptions","setExploreMetricsQueryField","PromExploreQueryEditor","setAnnotationQueryCtrl","setExploreStartPage","onClickExample","hasCanceled_","reject"],"mappings":"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","file":"prometheusPlugin.017a0d1a58b1119d038d.js","sourcesContent":["import _ from 'lodash';\nimport { TimeRange } from '@grafana/data';\nimport { PrometheusDatasource, PromDataQueryResponse } from './datasource';\nimport { PromQueryRequest } from './types';\nimport { getTimeSrv } from 'app/features/dashboard/services/TimeSrv';\n\nexport default class PrometheusMetricFindQuery {\n  range: TimeRange;\n\n  constructor(private datasource: PrometheusDatasource, private query: string) {\n    this.datasource = datasource;\n    this.query = query;\n    this.range = getTimeSrv().timeRange();\n  }\n\n  process() {\n    const labelNamesRegex = /^label_names\\(\\)\\s*$/;\n    const labelValuesRegex = /^label_values\\((?:(.+),\\s*)?([a-zA-Z_][a-zA-Z0-9_]*)\\)\\s*$/;\n    const metricNamesRegex = /^metrics\\((.+)\\)\\s*$/;\n    const queryResultRegex = /^query_result\\((.+)\\)\\s*$/;\n    const labelNamesQuery = this.query.match(labelNamesRegex);\n    if (labelNamesQuery) {\n      return this.labelNamesQuery();\n    }\n\n    const labelValuesQuery = this.query.match(labelValuesRegex);\n    if (labelValuesQuery) {\n      if (labelValuesQuery[1]) {\n        return this.labelValuesQuery(labelValuesQuery[2], labelValuesQuery[1]);\n      } else {\n        return this.labelValuesQuery(labelValuesQuery[2], null);\n      }\n    }\n\n    const metricNamesQuery = this.query.match(metricNamesRegex);\n    if (metricNamesQuery) {\n      return this.metricNameQuery(metricNamesQuery[1]);\n    }\n\n    const queryResultQuery = this.query.match(queryResultRegex);\n    if (queryResultQuery) {\n      return this.queryResultQuery(queryResultQuery[1]);\n    }\n\n    // if query contains full metric name, return metric name and label list\n    return this.metricNameAndLabelsQuery(this.query);\n  }\n\n  labelNamesQuery() {\n    const url = '/api/v1/labels';\n    return this.datasource.metadataRequest(url).then((result: any) => {\n      return _.map(result.data.data, value => {\n        return { text: value };\n      });\n    });\n  }\n\n  labelValuesQuery(label: string, metric?: string) {\n    let url: string;\n\n    if (!metric) {\n      // return label values globally\n      url = '/api/v1/label/' + label + '/values';\n\n      return this.datasource.metadataRequest(url).then((result: any) => {\n        return _.map(result.data.data, value => {\n          return { text: value };\n        });\n      });\n    } else {\n      const start = this.datasource.getPrometheusTime(this.range.from, false);\n      const end = this.datasource.getPrometheusTime(this.range.to, true);\n      const params = new URLSearchParams({\n        'match[]': metric,\n        start: start.toString(),\n        end: end.toString(),\n      });\n      url = `/api/v1/series?${params.toString()}`;\n\n      return this.datasource.metadataRequest(url).then((result: any) => {\n        const _labels = _.map(result.data.data, metric => {\n          return metric[label] || '';\n        }).filter(label => {\n          return label !== '';\n        });\n\n        return _.uniq(_labels).map(metric => {\n          return {\n            text: metric,\n            expandable: true,\n          };\n        });\n      });\n    }\n  }\n\n  metricNameQuery(metricFilterPattern: string) {\n    const url = '/api/v1/label/__name__/values';\n\n    return this.datasource.metadataRequest(url).then((result: any) => {\n      return _.chain(result.data.data)\n        .filter(metricName => {\n          const r = new RegExp(metricFilterPattern);\n          return r.test(metricName);\n        })\n        .map(matchedMetricName => {\n          return {\n            text: matchedMetricName,\n            expandable: true,\n          };\n        })\n        .value();\n    });\n  }\n\n  queryResultQuery(query: string) {\n    const end = this.datasource.getPrometheusTime(this.range.to, true);\n    const instantQuery: PromQueryRequest = { expr: query } as PromQueryRequest;\n    return this.datasource.performInstantQuery(instantQuery, end).then((result: PromDataQueryResponse) => {\n      return _.map(result.data.data.result, metricData => {\n        let text = metricData.metric.__name__ || '';\n        delete metricData.metric.__name__;\n        text +=\n          '{' +\n          _.map(metricData.metric, (v, k) => {\n            return k + '=\"' + v + '\"';\n          }).join(',') +\n          '}';\n        text += ' ' + metricData.value[1] + ' ' + metricData.value[0] * 1000;\n\n        return {\n          text: text,\n          expandable: true,\n        };\n      });\n    });\n  }\n\n  metricNameAndLabelsQuery(query: string) {\n    const start = this.datasource.getPrometheusTime(this.range.from, false);\n    const end = this.datasource.getPrometheusTime(this.range.to, true);\n    const params = new URLSearchParams({\n      'match[]': query,\n      start: start.toString(),\n      end: end.toString(),\n    });\n    const url = `/api/v1/series?${params.toString()}`;\n\n    const self = this;\n    return this.datasource.metadataRequest(url).then((result: PromDataQueryResponse) => {\n      return _.map(result.data.data, (metric: { [key: string]: string }) => {\n        return {\n          text: self.datasource.getOriginalMetricName(metric),\n          expandable: true,\n        };\n      });\n    });\n  }\n}\n","import _ from 'lodash';\nimport TableModel from 'app/core/table_model';\nimport { TimeSeries, FieldType, Labels, formatLabels, QueryResultMeta } from '@grafana/data';\nimport { TemplateSrv } from 'app/features/templating/template_srv';\n\nexport class ResultTransformer {\n  constructor(private templateSrv: TemplateSrv) {}\n\n  transform(response: any, options: any): Array<TableModel | TimeSeries> {\n    const prometheusResult = response.data.data.result;\n\n    if (options.format === 'table') {\n      return [\n        this.transformMetricDataToTable(\n          prometheusResult,\n          options.responseListLength,\n          options.refId,\n          options.meta,\n          options.valueWithRefId\n        ),\n      ];\n    } else if (prometheusResult && options.format === 'heatmap') {\n      let seriesList = [];\n      for (const metricData of prometheusResult) {\n        seriesList.push(this.transformMetricData(metricData, options, options.start, options.end));\n      }\n      seriesList.sort(sortSeriesByLabel);\n      seriesList = this.transformToHistogramOverTime(seriesList);\n      return seriesList;\n    } else if (prometheusResult) {\n      const seriesList = [];\n      for (const metricData of prometheusResult) {\n        if (response.data.data.resultType === 'matrix') {\n          seriesList.push(this.transformMetricData(metricData, options, options.start, options.end));\n        } else if (response.data.data.resultType === 'vector') {\n          seriesList.push(this.transformInstantMetricData(metricData, options));\n        }\n      }\n      return seriesList;\n    }\n    return [];\n  }\n\n  transformMetricData(metricData: any, options: any, start: number, end: number) {\n    const dps = [];\n    const { name, labels, title } = this.createLabelInfo(metricData.metric, options);\n\n    const stepMs = parseFloat(options.step) * 1000;\n    let baseTimestamp = start * 1000;\n\n    if (metricData.values === undefined) {\n      throw new Error('Prometheus heatmap error: data should be a time series');\n    }\n\n    for (const value of metricData.values) {\n      let dpValue = parseFloat(value[1]);\n      if (_.isNaN(dpValue)) {\n        dpValue = null;\n      }\n\n      const timestamp = parseFloat(value[0]) * 1000;\n      for (let t = baseTimestamp; t < timestamp; t += stepMs) {\n        dps.push([null, t]);\n      }\n      baseTimestamp = timestamp + stepMs;\n      dps.push([dpValue, timestamp]);\n    }\n\n    const endTimestamp = end * 1000;\n    for (let t = baseTimestamp; t <= endTimestamp; t += stepMs) {\n      dps.push([null, t]);\n    }\n\n    return {\n      datapoints: dps,\n      query: options.query,\n      refId: options.refId,\n      target: name,\n      tags: labels,\n      title,\n      meta: options.meta,\n    };\n  }\n\n  transformMetricDataToTable(\n    md: any,\n    resultCount: number,\n    refId: string,\n    meta: QueryResultMeta,\n    valueWithRefId?: boolean\n  ): TableModel {\n    const table = new TableModel();\n    table.refId = refId;\n    table.meta = meta;\n\n    let i: number, j: number;\n    const metricLabels: { [key: string]: number } = {};\n\n    if (!md || md.length === 0) {\n      return table;\n    }\n\n    // Collect all labels across all metrics\n    _.each(md, series => {\n      for (const label in series.metric) {\n        if (!metricLabels.hasOwnProperty(label)) {\n          metricLabels[label] = 1;\n        }\n      }\n    });\n\n    // Sort metric labels, create columns for them and record their index\n    const sortedLabels = _.keys(metricLabels).sort();\n    table.columns.push({ text: 'Time', type: FieldType.time });\n    _.each(sortedLabels, (label, labelIndex) => {\n      metricLabels[label] = labelIndex + 1;\n      table.columns.push({ text: label, filterable: true });\n    });\n    const valueText = resultCount > 1 || valueWithRefId ? `Value #${refId}` : 'Value';\n    table.columns.push({ text: valueText });\n\n    // Populate rows, set value to empty string when label not present.\n    _.each(md, series => {\n      if (series.value) {\n        series.values = [series.value];\n      }\n      if (series.values) {\n        for (i = 0; i < series.values.length; i++) {\n          const values = series.values[i];\n          const reordered: any = [values[0] * 1000];\n          if (series.metric) {\n            for (j = 0; j < sortedLabels.length; j++) {\n              const label = sortedLabels[j];\n              if (series.metric.hasOwnProperty(label)) {\n                reordered.push(series.metric[label]);\n              } else {\n                reordered.push('');\n              }\n            }\n          }\n          reordered.push(parseFloat(values[1]));\n          table.rows.push(reordered);\n        }\n      }\n    });\n\n    return table;\n  }\n\n  transformInstantMetricData(md: any, options: any) {\n    const dps = [];\n    const { name, labels } = this.createLabelInfo(md.metric, options);\n    dps.push([parseFloat(md.value[1]), md.value[0] * 1000]);\n    return { target: name, title: name, datapoints: dps, tags: labels, refId: options.refId, meta: options.meta };\n  }\n\n  createLabelInfo(labels: { [key: string]: string }, options: any): { name?: string; labels: Labels; title?: string } {\n    if (options?.legendFormat) {\n      const title = this.renderTemplate(this.templateSrv.replace(options.legendFormat), labels);\n      return { name: title, title, labels };\n    }\n\n    let { __name__, ...labelsWithoutName } = labels;\n\n    let title = __name__ || '';\n\n    const labelPart = formatLabels(labelsWithoutName);\n\n    if (!title && !labelPart) {\n      title = options.query;\n    }\n\n    title = `${__name__ ?? ''}${labelPart}`;\n\n    return { name: title, title, labels: labelsWithoutName };\n  }\n\n  getOriginalMetricName(labelData: { [key: string]: string }) {\n    const metricName = labelData.__name__ || '';\n    delete labelData.__name__;\n    const labelPart = Object.entries(labelData)\n      .map(label => `${label[0]}=\"${label[1]}\"`)\n      .join(',');\n    return `${metricName}{${labelPart}}`;\n  }\n\n  renderTemplate(aliasPattern: string, aliasData: { [key: string]: string }) {\n    const aliasRegex = /\\{\\{\\s*(.+?)\\s*\\}\\}/g;\n    return aliasPattern.replace(aliasRegex, (match, g1) => {\n      if (aliasData[g1]) {\n        return aliasData[g1];\n      }\n      return '';\n    });\n  }\n\n  transformToHistogramOverTime(seriesList: TimeSeries[]) {\n    /*      t1 = timestamp1, t2 = timestamp2 etc.\n            t1  t2  t3          t1  t2  t3\n    le10    10  10  0     =>    10  10  0\n    le20    20  10  30    =>    10  0   30\n    le30    30  10  35    =>    10  0   5\n    */\n    for (let i = seriesList.length - 1; i > 0; i--) {\n      const topSeries = seriesList[i].datapoints;\n      const bottomSeries = seriesList[i - 1].datapoints;\n      if (!topSeries || !bottomSeries) {\n        throw new Error('Prometheus heatmap transform error: data should be a time series');\n      }\n\n      for (let j = 0; j < topSeries.length; j++) {\n        const bottomPoint = bottomSeries[j] || [0];\n        topSeries[j][0] -= bottomPoint[0];\n      }\n    }\n\n    return seriesList;\n  }\n}\n\nfunction sortSeriesByLabel(s1: TimeSeries, s2: TimeSeries): number {\n  let le1, le2;\n\n  try {\n    // fail if not integer. might happen with bad queries\n    le1 = parseHistogramLabel(s1.target);\n    le2 = parseHistogramLabel(s2.target);\n  } catch (err) {\n    console.log(err);\n    return 0;\n  }\n\n  if (le1 > le2) {\n    return 1;\n  }\n\n  if (le1 < le2) {\n    return -1;\n  }\n\n  return 0;\n}\n\nfunction parseHistogramLabel(le: string): number {\n  if (le === '+Inf') {\n    return +Infinity;\n  }\n  return Number(le);\n}\n","import _ from 'lodash';\nimport LRU from 'lru-cache';\nimport { Value } from 'slate';\n\nimport { dateTime, LanguageProvider, HistoryItem } from '@grafana/data';\nimport { CompletionItem, TypeaheadInput, TypeaheadOutput, CompletionItemGroup } from '@grafana/ui';\n\nimport { parseSelector, processLabels, processHistogramLabels, fixSummariesMetadata } from './language_utils';\nimport PromqlSyntax, { FUNCTIONS, RATE_RANGES } from './promql';\n\nimport { PrometheusDatasource } from './datasource';\nimport { PromQuery, PromMetricsMetadata } from './types';\n\nconst DEFAULT_KEYS = ['job', 'instance'];\nconst EMPTY_SELECTOR = '{}';\nconst HISTORY_ITEM_COUNT = 5;\nconst HISTORY_COUNT_CUTOFF = 1000 * 60 * 60 * 24; // 24h\nexport const DEFAULT_LOOKUP_METRICS_THRESHOLD = 10000; // number of metrics defining an installation that's too big\n\nconst wrapLabel = (label: string): CompletionItem => ({ label });\n\nconst setFunctionKind = (suggestion: CompletionItem): CompletionItem => {\n  suggestion.kind = 'function';\n  return suggestion;\n};\n\nexport function addHistoryMetadata(item: CompletionItem, history: any[]): CompletionItem {\n  const cutoffTs = Date.now() - HISTORY_COUNT_CUTOFF;\n  const historyForItem = history.filter(h => h.ts > cutoffTs && h.query === item.label);\n  const count = historyForItem.length;\n  const recent = historyForItem[0];\n  let hint = `Queried ${count} times in the last 24h.`;\n\n  if (recent) {\n    const lastQueried = dateTime(recent.ts).fromNow();\n    hint = `${hint} Last queried ${lastQueried}.`;\n  }\n\n  return {\n    ...item,\n    documentation: hint,\n  };\n}\n\nfunction addMetricsMetadata(metric: string, metadata?: PromMetricsMetadata): CompletionItem {\n  const item: CompletionItem = { label: metric };\n  if (metadata && metadata[metric]) {\n    const { type, help } = metadata[metric][0];\n    item.documentation = `${type.toUpperCase()}: ${help}`;\n  }\n  return item;\n}\n\nconst PREFIX_DELIMITER_REGEX = /(=\"|!=\"|=~\"|!~\"|\\{|\\[|\\(|\\+|-|\\/|\\*|%|\\^|\\band\\b|\\bor\\b|\\bunless\\b|==|>=|!=|<=|>|<|=|~|,)/;\n\nexport default class PromQlLanguageProvider extends LanguageProvider {\n  histogramMetrics?: string[];\n  timeRange?: { start: number; end: number };\n  metrics?: string[];\n  metricsMetadata?: PromMetricsMetadata;\n  startTask: Promise<any>;\n  datasource: PrometheusDatasource;\n  lookupMetricsThreshold: number;\n  lookupsDisabled: boolean; // Dynamically set to true for big/slow instances\n\n  /**\n   *  Cache for labels of series. This is bit simplistic in the sense that it just counts responses each as a 1 and does\n   *  not account for different size of a response. If that is needed a `length` function can be added in the options.\n   *  10 as a max size is totally arbitrary right now.\n   */\n  private labelsCache = new LRU<string, Record<string, string[]>>(10);\n\n  constructor(datasource: PrometheusDatasource, initialValues?: Partial<PromQlLanguageProvider>) {\n    super();\n\n    this.datasource = datasource;\n    this.histogramMetrics = [];\n    this.timeRange = { start: 0, end: 0 };\n    this.metrics = [];\n    // Disable lookups until we know the instance is small enough\n    this.lookupMetricsThreshold = DEFAULT_LOOKUP_METRICS_THRESHOLD;\n    this.lookupsDisabled = true;\n\n    Object.assign(this, initialValues);\n  }\n\n  // Strip syntax chars so that typeahead suggestions can work on clean inputs\n  cleanText(s: string) {\n    const parts = s.split(PREFIX_DELIMITER_REGEX);\n    const last = parts.pop();\n    return last\n      .trimLeft()\n      .replace(/\"$/, '')\n      .replace(/^\"/, '');\n  }\n\n  get syntax() {\n    return PromqlSyntax;\n  }\n\n  request = async (url: string, defaultValue: any): Promise<any> => {\n    try {\n      const res = await this.datasource.metadataRequest(url);\n      const body = await (res.data || res.json());\n\n      return body.data;\n    } catch (error) {\n      console.error(error);\n    }\n\n    return defaultValue;\n  };\n\n  start = async (): Promise<any[]> => {\n    if (this.datasource.lookupsDisabled) {\n      return [];\n    }\n\n    this.metrics = await this.request('/api/v1/label/__name__/values', []);\n    this.lookupsDisabled = this.metrics.length > this.lookupMetricsThreshold;\n    this.metricsMetadata = fixSummariesMetadata(await this.request('/api/v1/metadata', {}));\n    this.processHistogramMetrics(this.metrics);\n\n    return [];\n  };\n\n  processHistogramMetrics = (data: string[]) => {\n    const { values } = processHistogramLabels(data);\n\n    if (values && values['__name__']) {\n      this.histogramMetrics = values['__name__'].slice().sort();\n    }\n  };\n\n  provideCompletionItems = async (\n    { prefix, text, value, labelKey, wrapperClasses }: TypeaheadInput,\n    context: { history: Array<HistoryItem<PromQuery>> } = { history: [] }\n  ): Promise<TypeaheadOutput> => {\n    // Local text properties\n    const empty = value.document.text.length === 0;\n    const selectedLines = value.document.getTextsAtRange(value.selection);\n    const currentLine = selectedLines.size === 1 ? selectedLines.first().getText() : null;\n\n    const nextCharacter = currentLine ? currentLine[value.selection.anchor.offset] : null;\n\n    // Syntax spans have 3 classes by default. More indicate a recognized token\n    const tokenRecognized = wrapperClasses.length > 3;\n    // Non-empty prefix, but not inside known token\n    const prefixUnrecognized = prefix && !tokenRecognized;\n\n    // Prevent suggestions in `function(|suffix)`\n    const noSuffix = !nextCharacter || nextCharacter === ')';\n\n    // Prefix is safe if it does not immediately follow a complete expression and has no text after it\n    const safePrefix = prefix && !text.match(/^[\\]})\\s]+$/) && noSuffix;\n\n    // About to type next operand if preceded by binary operator\n    const operatorsPattern = /[+\\-*/^%]/;\n    const isNextOperand = text.match(operatorsPattern);\n\n    // Determine candidates by CSS context\n    if (wrapperClasses.includes('context-range')) {\n      // Suggestions for metric[|]\n      return this.getRangeCompletionItems();\n    } else if (wrapperClasses.includes('context-labels')) {\n      // Suggestions for metric{|} and metric{foo=|}, as well as metric-independent label queries like {|}\n      return this.getLabelCompletionItems({ prefix, text, value, labelKey, wrapperClasses });\n    } else if (wrapperClasses.includes('context-aggregation')) {\n      // Suggestions for sum(metric) by (|)\n      return this.getAggregationCompletionItems(value);\n    } else if (empty) {\n      // Suggestions for empty query field\n      return this.getEmptyCompletionItems(context);\n    } else if (prefixUnrecognized && noSuffix && !isNextOperand) {\n      // Show term suggestions in a couple of scenarios\n      return this.getBeginningCompletionItems(context);\n    } else if (prefixUnrecognized && safePrefix) {\n      // Show term suggestions in a couple of scenarios\n      return this.getTermCompletionItems();\n    }\n\n    return {\n      suggestions: [],\n    };\n  };\n\n  getBeginningCompletionItems = (context: { history: Array<HistoryItem<PromQuery>> }): TypeaheadOutput => {\n    return {\n      suggestions: [...this.getEmptyCompletionItems(context).suggestions, ...this.getTermCompletionItems().suggestions],\n    };\n  };\n\n  getEmptyCompletionItems = (context: { history: Array<HistoryItem<PromQuery>> }): TypeaheadOutput => {\n    const { history } = context;\n    const suggestions = [];\n\n    if (history && history.length) {\n      const historyItems = _.chain(history)\n        .map(h => h.query.expr)\n        .filter()\n        .uniq()\n        .take(HISTORY_ITEM_COUNT)\n        .map(wrapLabel)\n        .map(item => addHistoryMetadata(item, history))\n        .value();\n\n      suggestions.push({\n        prefixMatch: true,\n        skipSort: true,\n        label: 'History',\n        items: historyItems,\n      });\n    }\n\n    return { suggestions };\n  };\n\n  getTermCompletionItems = (): TypeaheadOutput => {\n    const { metrics, metricsMetadata } = this;\n    const suggestions = [];\n\n    suggestions.push({\n      prefixMatch: true,\n      label: 'Functions',\n      items: FUNCTIONS.map(setFunctionKind),\n    });\n\n    if (metrics && metrics.length) {\n      suggestions.push({\n        label: 'Metrics',\n        items: metrics.map(m => addMetricsMetadata(m, metricsMetadata)),\n      });\n    }\n\n    return { suggestions };\n  };\n\n  getRangeCompletionItems(): TypeaheadOutput {\n    return {\n      context: 'context-range',\n      suggestions: [\n        {\n          label: 'Range vector',\n          items: [...RATE_RANGES],\n        },\n      ],\n    };\n  }\n\n  getAggregationCompletionItems = async (value: Value): Promise<TypeaheadOutput> => {\n    const suggestions: CompletionItemGroup[] = [];\n\n    // Stitch all query lines together to support multi-line queries\n    let queryOffset;\n    const queryText = value.document.getBlocks().reduce((text: string, block) => {\n      const blockText = block.getText();\n      if (value.anchorBlock.key === block.key) {\n        // Newline characters are not accounted for but this is irrelevant\n        // for the purpose of extracting the selector string\n        queryOffset = value.selection.anchor.offset + text.length;\n      }\n\n      return text + blockText;\n    }, '');\n\n    // Try search for selector part on the left-hand side, such as `sum (m) by (l)`\n    const openParensAggregationIndex = queryText.lastIndexOf('(', queryOffset);\n    let openParensSelectorIndex = queryText.lastIndexOf('(', openParensAggregationIndex - 1);\n    let closeParensSelectorIndex = queryText.indexOf(')', openParensSelectorIndex);\n\n    // Try search for selector part of an alternate aggregation clause, such as `sum by (l) (m)`\n    if (openParensSelectorIndex === -1) {\n      const closeParensAggregationIndex = queryText.indexOf(')', queryOffset);\n      closeParensSelectorIndex = queryText.indexOf(')', closeParensAggregationIndex + 1);\n      openParensSelectorIndex = queryText.lastIndexOf('(', closeParensSelectorIndex);\n    }\n\n    const result = {\n      suggestions,\n      context: 'context-aggregation',\n    };\n\n    // Suggestions are useless for alternative aggregation clauses without a selector in context\n    if (openParensSelectorIndex === -1) {\n      return result;\n    }\n\n    // Range vector syntax not accounted for by subsequent parse so discard it if present\n    const selectorString = queryText\n      .slice(openParensSelectorIndex + 1, closeParensSelectorIndex)\n      .replace(/\\[[^\\]]+\\]$/, '');\n\n    const selector = parseSelector(selectorString, selectorString.length - 2).selector;\n\n    const labelValues = await this.getLabelValues(selector);\n    if (labelValues) {\n      suggestions.push({ label: 'Labels', items: Object.keys(labelValues).map(wrapLabel) });\n    }\n    return result;\n  };\n\n  getLabelCompletionItems = async ({\n    text,\n    wrapperClasses,\n    labelKey,\n    value,\n  }: TypeaheadInput): Promise<TypeaheadOutput> => {\n    const suggestions: CompletionItemGroup[] = [];\n    const line = value.anchorBlock.getText();\n    const cursorOffset = value.selection.anchor.offset;\n    const suffix = line.substr(cursorOffset);\n    const prefix = line.substr(0, cursorOffset);\n    const isValueStart = text.match(/^(=|=~|!=|!~)/);\n    const isValueEnd = suffix.match(/^\"?[,}]/);\n    // detect cursor in front of value, e.g., {key=|\"}\n    const isPreValue = prefix.match(/(=|=~|!=|!~)$/) && suffix.match(/^\"/);\n\n    // Don't suggestq anything at the beginning or inside a value\n    const isValueEmpty = isValueStart && isValueEnd;\n    const hasValuePrefix = isValueEnd && !isValueStart;\n    if ((!isValueEmpty && !hasValuePrefix) || isPreValue) {\n      return { suggestions };\n    }\n\n    // Get normalized selector\n    let selector;\n    let parsedSelector;\n    try {\n      parsedSelector = parseSelector(line, cursorOffset);\n      selector = parsedSelector.selector;\n    } catch {\n      selector = EMPTY_SELECTOR;\n    }\n\n    const containsMetric = selector.includes('__name__=');\n    const existingKeys = parsedSelector ? parsedSelector.labelKeys : [];\n\n    let labelValues;\n    // Query labels for selector\n    if (selector) {\n      labelValues = await this.getLabelValues(selector, !containsMetric);\n    }\n\n    if (!labelValues) {\n      console.warn(`Server did not return any values for selector = ${selector}`);\n      return { suggestions };\n    }\n\n    let context: string;\n    if ((text && isValueStart) || wrapperClasses.includes('attr-value')) {\n      // Label values\n      if (labelKey && labelValues[labelKey]) {\n        context = 'context-label-values';\n        suggestions.push({\n          label: `Label values for \"${labelKey}\"`,\n          items: labelValues[labelKey].map(wrapLabel),\n        });\n      }\n    } else {\n      // Label keys\n      const labelKeys = labelValues ? Object.keys(labelValues) : containsMetric ? null : DEFAULT_KEYS;\n\n      if (labelKeys) {\n        const possibleKeys = _.difference(labelKeys, existingKeys);\n        if (possibleKeys.length) {\n          context = 'context-labels';\n          const newItems = possibleKeys.map(key => ({ label: key }));\n          const newSuggestion: CompletionItemGroup = { label: `Labels`, items: newItems };\n          suggestions.push(newSuggestion);\n        }\n      }\n    }\n\n    return { context, suggestions };\n  };\n\n  async getLabelValues(selector: string, withName?: boolean) {\n    if (this.lookupsDisabled) {\n      return undefined;\n    }\n    try {\n      if (selector === EMPTY_SELECTOR) {\n        return await this.fetchDefaultLabels();\n      } else {\n        return await this.fetchSeriesLabels(selector, withName);\n      }\n    } catch (error) {\n      // TODO: better error handling\n      console.error(error);\n      return undefined;\n    }\n  }\n\n  fetchLabelValues = async (key: string): Promise<Record<string, string[]>> => {\n    const data = await this.request(`/api/v1/label/${key}/values`, []);\n    return { [key]: data };\n  };\n\n  roundToMinutes(seconds: number): number {\n    return Math.floor(seconds / 60);\n  }\n\n  /**\n   * Fetch labels for a series. This is cached by it's args but also by the global timeRange currently selected as\n   * they can change over requested time.\n   * @param name\n   * @param withName\n   */\n  fetchSeriesLabels = async (name: string, withName?: boolean): Promise<Record<string, string[]>> => {\n    const tRange = this.datasource.getTimeRange();\n    const params = new URLSearchParams({\n      'match[]': name,\n      start: tRange['start'].toString(),\n      end: tRange['end'].toString(),\n    });\n    const url = `/api/v1/series?${params.toString()}`;\n    // Cache key is a bit different here. We add the `withName` param and also round up to a minute the intervals.\n    // The rounding may seem strange but makes relative intervals like now-1h less prone to need separate request every\n    // millisecond while still actually getting all the keys for the correct interval. This still can create problems\n    // when user does not the newest values for a minute if already cached.\n    params.set('start', this.roundToMinutes(tRange['start']).toString());\n    params.set('end', this.roundToMinutes(tRange['end']).toString());\n    params.append('withName', withName ? 'true' : 'false');\n    const cacheKey = `/api/v1/series?${params.toString()}`;\n    let value = this.labelsCache.get(cacheKey);\n    if (!value) {\n      const data = await this.request(url, []);\n      const { values } = processLabels(data, withName);\n      value = values;\n      this.labelsCache.set(cacheKey, value);\n    }\n    return value;\n  };\n\n  /**\n   * Fetch this only one as we assume this won't change over time. This is cached differently from fetchSeriesLabels\n   * because we can cache more aggressively here and also we do not want to invalidate this cache the same way as in\n   * fetchSeriesLabels.\n   */\n  fetchDefaultLabels = _.once(async () => {\n    const values = await Promise.all(DEFAULT_KEYS.map(key => this.fetchLabelValues(key)));\n    return values.reduce((acc, value) => ({ ...acc, ...value }), {});\n  });\n}\n","import _ from 'lodash';\nimport { QueryHint, QueryFix } from '@grafana/data';\nimport { PrometheusDatasource } from './datasource';\n\n/**\n * Number of time series results needed before starting to suggest sum aggregation hints\n */\nexport const SUM_HINT_THRESHOLD_COUNT = 20;\n\nexport function getQueryHints(query: string, series?: any[], datasource?: PrometheusDatasource): QueryHint[] | null {\n  const hints = [];\n\n  // ..._bucket metric needs a histogram_quantile()\n  const histogramMetric = query.trim().match(/^\\w+_bucket$/);\n  if (histogramMetric) {\n    const label = 'Time series has buckets, you probably wanted a histogram.';\n    hints.push({\n      type: 'HISTOGRAM_QUANTILE',\n      label,\n      fix: {\n        label: 'Fix by adding histogram_quantile().',\n        action: {\n          type: 'ADD_HISTOGRAM_QUANTILE',\n          query,\n        },\n      } as QueryFix,\n    });\n  }\n\n  // Check for need of rate()\n  if (query.indexOf('rate(') === -1 && query.indexOf('increase(') === -1) {\n    // Use metric metadata for exact types\n    const nameMatch = query.match(/\\b(\\w+_(total|sum|count))\\b/);\n    let counterNameMetric = nameMatch ? nameMatch[1] : '';\n    const metricsMetadata = datasource?.languageProvider?.metricsMetadata;\n    let certain = false;\n    if (_.size(metricsMetadata) > 0) {\n      counterNameMetric = Object.keys(metricsMetadata).find(metricName => {\n        // Only considering first type information, could be non-deterministic\n        const metadata = metricsMetadata[metricName][0];\n        if (metadata.type.toLowerCase() === 'counter') {\n          const metricRegex = new RegExp(`\\\\b${metricName}\\\\b`);\n          if (query.match(metricRegex)) {\n            certain = true;\n            return true;\n          }\n        }\n        return false;\n      });\n    }\n    if (counterNameMetric) {\n      const simpleMetric = query.trim().match(/^\\w+$/);\n      const verb = certain ? 'is' : 'looks like';\n      let label = `Metric ${counterNameMetric} ${verb} a counter.`;\n      let fix: QueryFix;\n      if (simpleMetric) {\n        fix = {\n          label: 'Fix by adding rate().',\n          action: {\n            type: 'ADD_RATE',\n            query,\n          },\n        } as QueryFix;\n      } else {\n        label = `${label} Try applying a rate() function.`;\n      }\n      hints.push({\n        type: 'APPLY_RATE',\n        label,\n        fix,\n      });\n    }\n  }\n\n  // Check for recording rules expansion\n  if (datasource && datasource.ruleMappings) {\n    const mapping = datasource.ruleMappings;\n    const mappingForQuery = Object.keys(mapping).reduce((acc, ruleName) => {\n      if (query.search(ruleName) > -1) {\n        return {\n          ...acc,\n          [ruleName]: mapping[ruleName],\n        };\n      }\n      return acc;\n    }, {});\n    if (_.size(mappingForQuery) > 0) {\n      const label = 'Query contains recording rules.';\n      hints.push({\n        type: 'EXPAND_RULES',\n        label,\n        fix: ({\n          label: 'Expand rules',\n          action: {\n            type: 'EXPAND_RULES',\n            query,\n            mapping: mappingForQuery,\n          },\n        } as any) as QueryFix,\n      });\n    }\n  }\n\n  if (series && series.length >= SUM_HINT_THRESHOLD_COUNT) {\n    const simpleMetric = query.trim().match(/^\\w+$/);\n    if (simpleMetric) {\n      hints.push({\n        type: 'ADD_SUM',\n        label: 'Many time series results returned.',\n        fix: {\n          label: 'Consider aggregating with sum().',\n          action: {\n            type: 'ADD_SUM',\n            query: query,\n            preventSubmit: true,\n          },\n        } as QueryFix,\n      });\n    }\n  }\n\n  return hints.length > 0 ? hints : null;\n}\n","// Libraries\nimport cloneDeep from 'lodash/cloneDeep';\nimport defaults from 'lodash/defaults';\nimport $ from 'jquery';\n// Services & Utils\nimport kbn from 'app/core/utils/kbn';\nimport {\n  AnnotationEvent,\n  CoreApp,\n  DataQueryError,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataQueryResponseData,\n  DataSourceApi,\n  DataSourceInstanceSettings,\n  dateMath,\n  DateTime,\n  LoadingState,\n  ScopedVars,\n  TimeRange,\n  TimeSeries,\n} from '@grafana/data';\nimport { forkJoin, from, merge, Observable, of } from 'rxjs';\nimport { filter, map, tap } from 'rxjs/operators';\n\nimport PrometheusMetricFindQuery from './metric_find_query';\nimport { ResultTransformer } from './result_transformer';\nimport PrometheusLanguageProvider from './language_provider';\nimport { getBackendSrv } from '@grafana/runtime';\nimport addLabelToQuery from './add_label_to_query';\nimport { getQueryHints } from './query_hints';\nimport { expandRecordingRules } from './language_utils';\n// Types\nimport { PromOptions, PromQuery, PromQueryRequest } from './types';\nimport { safeStringifyValue } from 'app/core/utils/explore';\nimport templateSrv from 'app/features/templating/template_srv';\nimport { getTimeSrv } from 'app/features/dashboard/services/TimeSrv';\nimport TableModel from 'app/core/table_model';\n\nexport const ANNOTATION_QUERY_STEP_DEFAULT = '60s';\n\ninterface RequestOptions {\n  method?: string;\n  url?: string;\n  headers?: Record<string, string>;\n  transformRequest?: (data: any) => string;\n  data?: any;\n  withCredentials?: boolean;\n  silent?: boolean;\n  requestId?: string;\n}\n\nexport interface PromDataQueryResponse {\n  data: {\n    status: string;\n    data: {\n      resultType: string;\n      results?: DataQueryResponseData[];\n      result?: DataQueryResponseData[];\n    };\n  };\n  cancelled?: boolean;\n}\n\nexport interface PromLabelQueryResponse {\n  data: {\n    status: string;\n    data: string[];\n  };\n  cancelled?: boolean;\n}\n\nexport class PrometheusDatasource extends DataSourceApi<PromQuery, PromOptions> {\n  type: string;\n  editorSrc: string;\n  ruleMappings: { [index: string]: string };\n  url: string;\n  directUrl: string;\n  basicAuth: any;\n  withCredentials: any;\n  metricsNameCache: any;\n  interval: string;\n  queryTimeout: string;\n  httpMethod: string;\n  languageProvider: PrometheusLanguageProvider;\n  lookupsDisabled: boolean;\n  resultTransformer: ResultTransformer;\n  customQueryParameters: any;\n\n  constructor(instanceSettings: DataSourceInstanceSettings<PromOptions>) {\n    super(instanceSettings);\n\n    this.type = 'prometheus';\n    this.editorSrc = 'app/features/prometheus/partials/query.editor.html';\n    this.url = instanceSettings.url;\n    this.basicAuth = instanceSettings.basicAuth;\n    this.withCredentials = instanceSettings.withCredentials;\n    this.interval = instanceSettings.jsonData.timeInterval || '15s';\n    this.queryTimeout = instanceSettings.jsonData.queryTimeout;\n    this.httpMethod = instanceSettings.jsonData.httpMethod || 'GET';\n    this.directUrl = instanceSettings.jsonData.directUrl;\n    this.resultTransformer = new ResultTransformer(templateSrv);\n    this.ruleMappings = {};\n    this.languageProvider = new PrometheusLanguageProvider(this);\n    this.lookupsDisabled = instanceSettings.jsonData.disableMetricsLookup;\n    this.customQueryParameters = new URLSearchParams(instanceSettings.jsonData.customQueryParameters);\n  }\n\n  init = () => {\n    this.loadRules();\n  };\n\n  getQueryDisplayText(query: PromQuery) {\n    return query.expr;\n  }\n\n  _addTracingHeaders(httpOptions: PromQueryRequest, options: DataQueryRequest<PromQuery>) {\n    httpOptions.headers = {};\n    const proxyMode = !this.url.match(/^http/);\n    if (proxyMode) {\n      httpOptions.headers['X-Dashboard-Id'] = options.dashboardId;\n      httpOptions.headers['X-Panel-Id'] = options.panelId;\n    }\n  }\n\n  _request(url: string, data: Record<string, string> = {}, options?: RequestOptions) {\n    options = defaults(options || {}, {\n      url: this.url + url,\n      method: this.httpMethod,\n      headers: {},\n    });\n\n    if (options.method === 'GET') {\n      if (data && Object.keys(data).length) {\n        options.url =\n          options.url +\n          '?' +\n          Object.entries(data)\n            .map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`)\n            .join('&');\n      }\n    } else {\n      options.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n      options.transformRequest = (data: any) => $.param(data);\n      options.data = data;\n    }\n\n    if (this.basicAuth || this.withCredentials) {\n      options.withCredentials = true;\n    }\n\n    if (this.basicAuth) {\n      options.headers.Authorization = this.basicAuth;\n    }\n\n    return getBackendSrv().datasourceRequest(options as Required<RequestOptions>);\n  }\n\n  // Use this for tab completion features, wont publish response to other components\n  metadataRequest(url: string) {\n    return this._request(url, null, { method: 'GET', silent: true });\n  }\n\n  interpolateQueryExpr(value: string | string[] = [], variable: any) {\n    // if no multi or include all do not regexEscape\n    if (!variable.multi && !variable.includeAll) {\n      return prometheusRegularEscape(value);\n    }\n\n    if (typeof value === 'string') {\n      return prometheusSpecialRegexEscape(value);\n    }\n\n    const escapedValues = value.map(val => prometheusSpecialRegexEscape(val));\n    return escapedValues.join('|');\n  }\n\n  targetContainsTemplate(target: PromQuery) {\n    return templateSrv.variableExists(target.expr);\n  }\n\n  processResult = (response: any, query: PromQueryRequest, target: PromQuery, responseListLength: number) => {\n    // Keeping original start/end for transformers\n    const transformerOptions = {\n      format: target.format,\n      step: query.step,\n      legendFormat: target.legendFormat,\n      start: query.start,\n      end: query.end,\n      query: query.expr,\n      responseListLength,\n      refId: target.refId,\n      valueWithRefId: target.valueWithRefId,\n      meta: {\n        /** Fix for showing of Prometheus results in Explore table. We want to show result of instant query in table and the rest of time series in graph */\n        preferredVisualisationType: query.instant ? 'table' : 'graph',\n      },\n    };\n    const series = this.resultTransformer.transform(response, transformerOptions);\n\n    return series;\n  };\n\n  prepareTargets = (options: DataQueryRequest<PromQuery>, start: number, end: number) => {\n    const queries: PromQueryRequest[] = [];\n    const activeTargets: PromQuery[] = [];\n\n    for (const target of options.targets) {\n      if (!target.expr || target.hide) {\n        continue;\n      }\n\n      target.requestId = options.panelId + target.refId;\n\n      if (options.app !== CoreApp.Explore) {\n        activeTargets.push(target);\n        queries.push(this.createQuery(target, options, start, end));\n        continue;\n      }\n\n      if (target.showingTable) {\n        // create instant target only if Table is showed in Explore\n        const instantTarget: any = cloneDeep(target);\n        instantTarget.format = 'table';\n        instantTarget.instant = true;\n        instantTarget.valueWithRefId = true;\n        delete instantTarget.maxDataPoints;\n        instantTarget.requestId += '_instant';\n\n        activeTargets.push(instantTarget);\n        queries.push(this.createQuery(instantTarget, options, start, end));\n      }\n\n      if (target.showingGraph) {\n        // create time series target only if Graph is showed in Explore\n        target.format = 'time_series';\n        target.instant = false;\n\n        activeTargets.push(target);\n        queries.push(this.createQuery(target, options, start, end));\n      }\n    }\n\n    return {\n      queries,\n      activeTargets,\n    };\n  };\n\n  query(options: DataQueryRequest<PromQuery>): Observable<DataQueryResponse> {\n    const start = this.getPrometheusTime(options.range.from, false);\n    const end = this.getPrometheusTime(options.range.to, true);\n    const { queries, activeTargets } = this.prepareTargets(options, start, end);\n\n    // No valid targets, return the empty result to save a round trip.\n    if (!queries || !queries.length) {\n      return of({\n        data: [],\n        state: LoadingState.Done,\n      });\n    }\n\n    if (options.app === CoreApp.Explore) {\n      return this.exploreQuery(queries, activeTargets, end);\n    }\n\n    return this.panelsQuery(queries, activeTargets, end, options.requestId);\n  }\n\n  private exploreQuery(queries: PromQueryRequest[], activeTargets: PromQuery[], end: number) {\n    let runningQueriesCount = queries.length;\n    const subQueries = queries.map((query, index) => {\n      const target = activeTargets[index];\n      let observable: Observable<any> = null;\n\n      if (query.instant) {\n        observable = from(this.performInstantQuery(query, end));\n      } else {\n        observable = from(this.performTimeSeriesQuery(query, query.start, query.end));\n      }\n\n      return observable.pipe(\n        // Decrease the counter here. We assume that each request returns only single value and then completes\n        // (should hold until there is some streaming requests involved).\n        tap(() => runningQueriesCount--),\n        filter((response: any) => (response.cancelled ? false : true)),\n        map((response: any) => {\n          const data = this.processResult(response, query, target, queries.length);\n          return {\n            data,\n            key: query.requestId,\n            state: runningQueriesCount === 0 ? LoadingState.Done : LoadingState.Loading,\n          } as DataQueryResponse;\n        })\n      );\n    });\n\n    return merge(...subQueries);\n  }\n\n  private panelsQuery(queries: PromQueryRequest[], activeTargets: PromQuery[], end: number, requestId: string) {\n    const observables: Array<Observable<Array<TableModel | TimeSeries>>> = queries.map((query, index) => {\n      const target = activeTargets[index];\n      let observable: Observable<any> = null;\n\n      if (query.instant) {\n        observable = from(this.performInstantQuery(query, end));\n      } else {\n        observable = from(this.performTimeSeriesQuery(query, query.start, query.end));\n      }\n\n      return observable.pipe(\n        filter((response: any) => (response.cancelled ? false : true)),\n        map((response: any) => {\n          const data = this.processResult(response, query, target, queries.length);\n          return data;\n        })\n      );\n    });\n\n    return forkJoin(observables).pipe(\n      map((results: Array<Array<TableModel | TimeSeries>>) => {\n        const data = results.reduce((result, current) => {\n          return [...result, ...current];\n        }, []);\n        return {\n          data,\n          key: requestId,\n          state: LoadingState.Done,\n        };\n      })\n    );\n  }\n\n  createQuery(target: PromQuery, options: DataQueryRequest<PromQuery>, start: number, end: number) {\n    const query: PromQueryRequest = {\n      hinting: target.hinting,\n      instant: target.instant,\n      step: 0,\n      expr: '',\n      requestId: target.requestId,\n      refId: target.refId,\n      start: 0,\n      end: 0,\n    };\n    const range = Math.ceil(end - start);\n\n    // options.interval is the dynamically calculated interval\n    let interval = kbn.interval_to_seconds(options.interval);\n    // Minimum interval (\"Min step\"), if specified for the query or datasource. or same as interval otherwise\n    const minInterval = kbn.interval_to_seconds(\n      templateSrv.replace(target.interval, options.scopedVars) || options.interval\n    );\n    const intervalFactor = target.intervalFactor || 1;\n    // Adjust the interval to take into account any specified minimum and interval factor plus Prometheus limits\n    const adjustedInterval = this.adjustInterval(interval, minInterval, range, intervalFactor);\n    let scopedVars = { ...options.scopedVars, ...this.getRangeScopedVars(options.range) };\n    // If the interval was adjusted, make a shallow copy of scopedVars with updated interval vars\n    if (interval !== adjustedInterval) {\n      interval = adjustedInterval;\n      scopedVars = Object.assign({}, options.scopedVars, {\n        __interval: { text: interval + 's', value: interval + 's' },\n        __interval_ms: { text: interval * 1000, value: interval * 1000 },\n        ...this.getRangeScopedVars(options.range),\n      });\n    }\n    query.step = interval;\n\n    let expr = target.expr;\n\n    // Apply adhoc filters\n    const adhocFilters = templateSrv.getAdhocFilters(this.name);\n    expr = adhocFilters.reduce((acc: string, filter: { key?: any; operator?: any; value?: any }) => {\n      const { key, operator } = filter;\n      let { value } = filter;\n      if (operator === '=~' || operator === '!~') {\n        value = prometheusRegularEscape(value);\n      }\n      return addLabelToQuery(acc, key, value, operator);\n    }, expr);\n\n    // Only replace vars in expression after having (possibly) updated interval vars\n    query.expr = templateSrv.replace(expr, scopedVars, this.interpolateQueryExpr);\n\n    // Align query interval with step to allow query caching and to ensure\n    // that about-same-time query results look the same.\n    const adjusted = alignRange(\n      start,\n      end,\n      query.step,\n      getTimeSrv()\n        .timeRange()\n        .to.utcOffset() * 60\n    );\n    query.start = adjusted.start;\n    query.end = adjusted.end;\n    this._addTracingHeaders(query, options);\n\n    return query;\n  }\n\n  adjustInterval(interval: number, minInterval: number, range: number, intervalFactor: number) {\n    // Prometheus will drop queries that might return more than 11000 data points.\n    // Calculate a safe interval as an additional minimum to take into account.\n    // Fractional safeIntervals are allowed, however serve little purpose if the interval is greater than 1\n    // If this is the case take the ceil of the value.\n    let safeInterval = range / 11000;\n    if (safeInterval > 1) {\n      safeInterval = Math.ceil(safeInterval);\n    }\n    return Math.max(interval * intervalFactor, minInterval, safeInterval);\n  }\n\n  performTimeSeriesQuery(query: PromQueryRequest, start: number, end: number) {\n    if (start > end) {\n      throw { message: 'Invalid time range' };\n    }\n\n    const url = '/api/v1/query_range';\n    const data: any = {\n      query: query.expr,\n      start,\n      end,\n      step: query.step,\n    };\n\n    if (this.queryTimeout) {\n      data['timeout'] = this.queryTimeout;\n    }\n\n    for (const [key, value] of this.customQueryParameters) {\n      if (data[key] == null) {\n        data[key] = value;\n      }\n    }\n\n    return this._request(url, data, { requestId: query.requestId, headers: query.headers }).catch((err: any) => {\n      if (err.cancelled) {\n        return err;\n      }\n\n      throw this.handleErrors(err, query);\n    });\n  }\n\n  performInstantQuery(query: PromQueryRequest, time: number) {\n    const url = '/api/v1/query';\n    const data: any = {\n      query: query.expr,\n      time,\n    };\n\n    if (this.queryTimeout) {\n      data['timeout'] = this.queryTimeout;\n    }\n\n    for (const [key, value] of this.customQueryParameters) {\n      if (data[key] == null) {\n        data[key] = value;\n      }\n    }\n\n    return this._request(url, data, { requestId: query.requestId, headers: query.headers }).catch((err: any) => {\n      if (err.cancelled) {\n        return err;\n      }\n\n      throw this.handleErrors(err, query);\n    });\n  }\n\n  handleErrors = (err: any, target: PromQuery) => {\n    const error: DataQueryError = {\n      message: (err && err.statusText) || 'Unknown error during query transaction. Please check JS console logs.',\n      refId: target.refId,\n    };\n\n    if (err.data) {\n      if (typeof err.data === 'string') {\n        error.message = err.data;\n      } else if (err.data.error) {\n        error.message = safeStringifyValue(err.data.error);\n      }\n    } else if (err.message) {\n      error.message = err.message;\n    } else if (typeof err === 'string') {\n      error.message = err;\n    }\n\n    error.status = err.status;\n    error.statusText = err.statusText;\n\n    return error;\n  };\n\n  async performSuggestQuery(query: string, cache = false) {\n    if (cache && this.metricsNameCache?.expire > Date.now()) {\n      return this.metricsNameCache.data.filter((metricName: any) => metricName.indexOf(query) !== 1);\n    }\n\n    const response: PromLabelQueryResponse = await this.metadataRequest('/api/v1/label/__name__/values');\n    this.metricsNameCache = {\n      data: response.data.data,\n      expire: Date.now() + 60 * 1000,\n    };\n\n    return response.data.data.filter(metricName => metricName.indexOf(query) !== 1);\n  }\n\n  metricFindQuery(query: string) {\n    if (!query) {\n      return Promise.resolve([]);\n    }\n\n    const scopedVars = {\n      __interval: { text: this.interval, value: this.interval },\n      __interval_ms: { text: kbn.interval_to_ms(this.interval), value: kbn.interval_to_ms(this.interval) },\n      ...this.getRangeScopedVars(getTimeSrv().timeRange()),\n    };\n    const interpolated = templateSrv.replace(query, scopedVars, this.interpolateQueryExpr);\n    const metricFindQuery = new PrometheusMetricFindQuery(this, interpolated);\n    return metricFindQuery.process();\n  }\n\n  getRangeScopedVars(range: TimeRange = getTimeSrv().timeRange()) {\n    const msRange = range.to.diff(range.from);\n    const sRange = Math.round(msRange / 1000);\n    return {\n      __range_ms: { text: msRange, value: msRange },\n      __range_s: { text: sRange, value: sRange },\n      __range: { text: sRange + 's', value: sRange + 's' },\n    };\n  }\n\n  createAnnotationQueryOptions = (options: any): DataQueryRequest<PromQuery> => {\n    const annotation = options.annotation;\n    const interval =\n      annotation && annotation.step && typeof annotation.step === 'string'\n        ? annotation.step\n        : ANNOTATION_QUERY_STEP_DEFAULT;\n    return {\n      ...options,\n      interval,\n    };\n  };\n\n  async annotationQuery(options: any): Promise<AnnotationEvent[]> {\n    const annotation = options.annotation;\n    const { expr = '', tagKeys = '', titleFormat = '', textFormat = '' } = annotation;\n\n    if (!expr) {\n      return Promise.resolve([]);\n    }\n\n    const start = this.getPrometheusTime(options.range.from, false);\n    const end = this.getPrometheusTime(options.range.to, true);\n    const queryOptions = this.createAnnotationQueryOptions(options);\n\n    // Unsetting min interval for accurate event resolution\n    const minStep = '1s';\n    const queryModel = {\n      expr,\n      interval: minStep,\n      refId: 'X',\n      requestId: `prom-query-${annotation.name}`,\n    };\n\n    const query = this.createQuery(queryModel, queryOptions, start, end);\n\n    const self = this;\n    const response: PromDataQueryResponse = await this.performTimeSeriesQuery(query, query.start, query.end);\n    const eventList: AnnotationEvent[] = [];\n    const splitKeys = tagKeys.split(',');\n\n    if (response.cancelled) {\n      return [];\n    }\n\n    const step = Math.floor(query.step) * 1000;\n\n    response?.data?.data?.result?.forEach(series => {\n      const tags = Object.entries(series.metric)\n        .filter(([k]) => splitKeys.includes(k))\n        .map(([_k, v]: [string, string]) => v);\n\n      series.values.forEach((value: any[]) => {\n        let timestampValue;\n        // rewrite timeseries to a common format\n        if (annotation.useValueForTime) {\n          timestampValue = Math.floor(parseFloat(value[1]));\n          value[1] = 1;\n        } else {\n          timestampValue = Math.floor(parseFloat(value[0])) * 1000;\n        }\n        value[0] = timestampValue;\n      });\n\n      const activeValues = series.values.filter((value: Record<number, string>) => parseFloat(value[1]) >= 1);\n      const activeValuesTimestamps = activeValues.map((value: number[]) => value[0]);\n\n      // Instead of creating singular annotation for each active event we group events into region if they are less\n      // then `step` apart.\n      let latestEvent: AnnotationEvent = null;\n      activeValuesTimestamps.forEach((timestamp: number) => {\n        // We already have event `open` and we have new event that is inside the `step` so we just update the end.\n        if (latestEvent && latestEvent.timeEnd + step >= timestamp) {\n          latestEvent.timeEnd = timestamp;\n          return;\n        }\n\n        // Event exists but new one is outside of the `step` so we \"finish\" the current region.\n        if (latestEvent) {\n          eventList.push(latestEvent);\n        }\n\n        // We start a new region.\n        latestEvent = {\n          time: timestamp,\n          timeEnd: timestamp,\n          annotation,\n          title: self.resultTransformer.renderTemplate(titleFormat, series.metric),\n          tags,\n          text: self.resultTransformer.renderTemplate(textFormat, series.metric),\n        };\n      });\n      if (latestEvent) {\n        // finish up last point if we have one\n        latestEvent.timeEnd = activeValuesTimestamps[activeValuesTimestamps.length - 1];\n        eventList.push(latestEvent);\n      }\n    });\n\n    return eventList;\n  }\n\n  async getTagKeys() {\n    const result = await this.metadataRequest('/api/v1/labels');\n    return result?.data?.data?.map((value: any) => ({ text: value })) ?? [];\n  }\n\n  async getTagValues(options: any = {}) {\n    const result = await this.metadataRequest(`/api/v1/label/${options.key}/values`);\n    return result?.data?.data?.map((value: any) => ({ text: value })) ?? [];\n  }\n\n  async testDatasource() {\n    const now = new Date().getTime();\n    const query = { expr: '1+1' } as PromQueryRequest;\n    const response = await this.performInstantQuery(query, now / 1000);\n    return response.data.status === 'success'\n      ? { status: 'success', message: 'Data source is working' }\n      : { status: 'error', message: response.error };\n  }\n\n  interpolateVariablesInQueries(queries: PromQuery[], scopedVars: ScopedVars): PromQuery[] {\n    let expandedQueries = queries;\n    if (queries && queries.length) {\n      expandedQueries = queries.map(query => {\n        const expandedQuery = {\n          ...query,\n          datasource: this.name,\n          expr: templateSrv.replace(query.expr, scopedVars, this.interpolateQueryExpr),\n        };\n        return expandedQuery;\n      });\n    }\n    return expandedQueries;\n  }\n\n  getQueryHints(query: PromQuery, result: any[]) {\n    return getQueryHints(query.expr ?? '', result, this);\n  }\n\n  async loadRules() {\n    try {\n      const res = await this.metadataRequest('/api/v1/rules');\n      const body = res.data || res.json();\n\n      const groups = body?.data?.groups;\n      if (groups) {\n        this.ruleMappings = extractRuleMappingFromGroups(groups);\n      }\n    } catch (e) {\n      console.log('Rules API is experimental. Ignore next error.');\n      console.error(e);\n    }\n  }\n\n  modifyQuery(query: PromQuery, action: any): PromQuery {\n    let expression = query.expr ?? '';\n    switch (action.type) {\n      case 'ADD_FILTER': {\n        expression = addLabelToQuery(expression, action.key, action.value);\n        break;\n      }\n      case 'ADD_HISTOGRAM_QUANTILE': {\n        expression = `histogram_quantile(0.95, sum(rate(${expression}[5m])) by (le))`;\n        break;\n      }\n      case 'ADD_RATE': {\n        expression = `rate(${expression}[5m])`;\n        break;\n      }\n      case 'ADD_SUM': {\n        expression = `sum(${expression.trim()}) by ($1)`;\n        break;\n      }\n      case 'EXPAND_RULES': {\n        if (action.mapping) {\n          expression = expandRecordingRules(expression, action.mapping);\n        }\n        break;\n      }\n      default:\n        break;\n    }\n    return { ...query, expr: expression };\n  }\n\n  getPrometheusTime(date: string | DateTime, roundUp: boolean) {\n    if (typeof date === 'string') {\n      date = dateMath.parse(date, roundUp);\n    }\n\n    return Math.ceil(date.valueOf() / 1000);\n  }\n\n  getTimeRange(): { start: number; end: number } {\n    const range = getTimeSrv().timeRange();\n    return {\n      start: this.getPrometheusTime(range.from, false),\n      end: this.getPrometheusTime(range.to, true),\n    };\n  }\n\n  getOriginalMetricName(labelData: { [key: string]: string }) {\n    return this.resultTransformer.getOriginalMetricName(labelData);\n  }\n}\n\n/**\n * Align query range to step.\n * Rounds start and end down to a multiple of step.\n * @param start Timestamp marking the beginning of the range.\n * @param end Timestamp marking the end of the range.\n * @param step Interval to align start and end with.\n * @param utcOffsetSec Number of seconds current timezone is offset from UTC\n */\nexport function alignRange(\n  start: number,\n  end: number,\n  step: number,\n  utcOffsetSec: number\n): { end: number; start: number } {\n  const alignedEnd = Math.floor((end + utcOffsetSec) / step) * step - utcOffsetSec;\n  const alignedStart = Math.floor((start + utcOffsetSec) / step) * step - utcOffsetSec;\n  return {\n    end: alignedEnd,\n    start: alignedStart,\n  };\n}\n\nexport function extractRuleMappingFromGroups(groups: any[]) {\n  return groups.reduce(\n    (mapping, group) =>\n      group.rules\n        .filter((rule: any) => rule.type === 'recording')\n        .reduce(\n          (acc: { [key: string]: string }, rule: any) => ({\n            ...acc,\n            [rule.name]: rule.query,\n          }),\n          mapping\n        ),\n    {}\n  );\n}\n\nexport function prometheusRegularEscape(value: any) {\n  return typeof value === 'string' ? value.replace(/'/g, \"\\\\\\\\'\") : value;\n}\n\nexport function prometheusSpecialRegexEscape(value: any) {\n  return typeof value === 'string'\n    ? prometheusRegularEscape(value.replace(/\\\\/g, '\\\\\\\\\\\\\\\\').replace(/[$^*{}\\[\\]+?.()|]/g, '\\\\\\\\$&'))\n    : value;\n}\n","import _ from 'lodash';\nimport React, { ReactNode } from 'react';\n\nimport { Plugin } from 'slate';\nimport {\n  ButtonCascader,\n  CascaderOption,\n  SlatePrism,\n  TypeaheadInput,\n  TypeaheadOutput,\n  QueryField,\n  BracesPlugin,\n} from '@grafana/ui';\n\nimport Prism from 'prismjs';\n\n// dom also includes Element polyfills\nimport { PromQuery, PromOptions, PromMetricsMetadata } from '../types';\nimport { CancelablePromise, makePromiseCancelable } from 'app/core/utils/CancelablePromise';\nimport { ExploreQueryFieldProps, QueryHint, isDataFrame, toLegacyResponseData, HistoryItem } from '@grafana/data';\nimport { DOMUtil, SuggestionsState } from '@grafana/ui';\nimport { PrometheusDatasource } from '../datasource';\n\nconst HISTOGRAM_GROUP = '__histograms__';\nconst PRISM_SYNTAX = 'promql';\nexport const RECORDING_RULES_GROUP = '__recording_rules__';\n\nfunction getChooserText(metricsLookupDisabled: boolean, hasSyntax: boolean, metrics: string[]) {\n  if (metricsLookupDisabled) {\n    return '(Disabled)';\n  }\n\n  if (!hasSyntax) {\n    return 'Loading metrics...';\n  }\n\n  if (metrics && metrics.length === 0) {\n    return '(No metrics found)';\n  }\n\n  return 'Metrics';\n}\n\nfunction addMetricsMetadata(metric: string, metadata?: PromMetricsMetadata): CascaderOption {\n  const option: CascaderOption = { label: metric, value: metric };\n  if (metadata && metadata[metric]) {\n    const { type = '', help } = metadata[metric][0];\n    option.title = [metric, type.toUpperCase(), help].join('\\n');\n  }\n  return option;\n}\n\nexport function groupMetricsByPrefix(metrics: string[], metadata?: PromMetricsMetadata): CascaderOption[] {\n  // Filter out recording rules and insert as first option\n  const ruleRegex = /:\\w+:/;\n  const ruleNames = metrics.filter(metric => ruleRegex.test(metric));\n  const rulesOption = {\n    label: 'Recording rules',\n    value: RECORDING_RULES_GROUP,\n    children: ruleNames\n      .slice()\n      .sort()\n      .map(name => ({ label: name, value: name })),\n  };\n\n  const options = ruleNames.length > 0 ? [rulesOption] : [];\n\n  const delimiter = '_';\n  const metricsOptions = _.chain(metrics)\n    .filter((metric: string) => !ruleRegex.test(metric))\n    .groupBy((metric: string) => metric.split(delimiter)[0])\n    .map(\n      (metricsForPrefix: string[], prefix: string): CascaderOption => {\n        const prefixIsMetric = metricsForPrefix.length === 1 && metricsForPrefix[0] === prefix;\n        const children = prefixIsMetric ? [] : metricsForPrefix.sort().map(m => addMetricsMetadata(m, metadata));\n        return {\n          children,\n          label: prefix,\n          value: prefix,\n        };\n      }\n    )\n    .sortBy('label')\n    .value();\n\n  return [...options, ...metricsOptions];\n}\n\nexport function willApplySuggestion(suggestion: string, { typeaheadContext, typeaheadText }: SuggestionsState): string {\n  // Modify suggestion based on context\n  switch (typeaheadContext) {\n    case 'context-labels': {\n      const nextChar = DOMUtil.getNextCharacter();\n      if (!nextChar || nextChar === '}' || nextChar === ',') {\n        suggestion += '=';\n      }\n      break;\n    }\n\n    case 'context-label-values': {\n      // Always add quotes and remove existing ones instead\n      if (!typeaheadText.match(/^(!?=~?\"|\")/)) {\n        suggestion = `\"${suggestion}`;\n      }\n      if (DOMUtil.getNextCharacter() !== '\"') {\n        suggestion = `${suggestion}\"`;\n      }\n      break;\n    }\n\n    default:\n  }\n  return suggestion;\n}\n\ninterface PromQueryFieldProps extends ExploreQueryFieldProps<PrometheusDatasource, PromQuery, PromOptions> {\n  history: Array<HistoryItem<PromQuery>>;\n  ExtraFieldElement?: ReactNode;\n}\n\ninterface PromQueryFieldState {\n  metricsOptions: any[];\n  syntaxLoaded: boolean;\n  hint: QueryHint | null;\n}\n\nclass PromQueryField extends React.PureComponent<PromQueryFieldProps, PromQueryFieldState> {\n  plugins: Plugin[];\n  languageProviderInitializationPromise: CancelablePromise<any>;\n\n  constructor(props: PromQueryFieldProps, context: React.Context<any>) {\n    super(props, context);\n\n    this.plugins = [\n      BracesPlugin(),\n      SlatePrism({\n        onlyIn: (node: any) => node.type === 'code_block',\n        getSyntax: (node: any) => 'promql',\n      }),\n    ];\n\n    this.state = {\n      metricsOptions: [],\n      syntaxLoaded: false,\n      hint: null,\n    };\n  }\n\n  componentDidMount() {\n    if (this.props.datasource.languageProvider) {\n      this.refreshMetrics();\n    }\n    this.refreshHint();\n  }\n\n  componentWillUnmount() {\n    if (this.languageProviderInitializationPromise) {\n      this.languageProviderInitializationPromise.cancel();\n    }\n  }\n\n  componentDidUpdate(prevProps: PromQueryFieldProps) {\n    const {\n      data,\n      datasource: { languageProvider },\n    } = this.props;\n\n    if (languageProvider !== prevProps.datasource.languageProvider) {\n      this.refreshMetrics();\n    }\n\n    if (data && prevProps.data && prevProps.data.series !== data.series) {\n      this.refreshHint();\n    }\n  }\n\n  refreshHint = () => {\n    const { datasource, query, data } = this.props;\n\n    if (!data || data.series.length === 0) {\n      this.setState({ hint: null });\n      return;\n    }\n\n    const result = isDataFrame(data.series[0]) ? data.series.map(toLegacyResponseData) : data.series;\n    const hints = datasource.getQueryHints(query, result);\n    const hint = hints && hints.length > 0 ? hints[0] : null;\n    this.setState({ hint });\n  };\n\n  refreshMetrics = () => {\n    const {\n      datasource: { languageProvider },\n    } = this.props;\n\n    this.setState({\n      syntaxLoaded: false,\n    });\n\n    Prism.languages[PRISM_SYNTAX] = languageProvider.syntax;\n    this.languageProviderInitializationPromise = makePromiseCancelable(languageProvider.start());\n    this.languageProviderInitializationPromise.promise\n      .then(remaining => {\n        remaining.map((task: Promise<any>) => task.then(this.onUpdateLanguage).catch(() => {}));\n      })\n      .then(() => this.onUpdateLanguage())\n      .catch(err => {\n        if (!err.isCanceled) {\n          throw err;\n        }\n      });\n  };\n\n  onChangeMetrics = (values: string[], selectedOptions: CascaderOption[]) => {\n    let query;\n    if (selectedOptions.length === 1) {\n      const selectedOption = selectedOptions[0];\n      if (!selectedOption.children || selectedOption.children.length === 0) {\n        query = selectedOption.value;\n      } else {\n        // Ignore click on group\n        return;\n      }\n    } else {\n      const prefix = selectedOptions[0].value;\n      const metric = selectedOptions[1].value;\n      if (prefix === HISTOGRAM_GROUP) {\n        query = `histogram_quantile(0.95, sum(rate(${metric}[5m])) by (le))`;\n      } else {\n        query = metric;\n      }\n    }\n    this.onChangeQuery(query, true);\n  };\n\n  onChangeQuery = (value: string, override?: boolean) => {\n    // Send text change to parent\n    const { query, onChange, onRunQuery } = this.props;\n    if (onChange) {\n      const nextQuery: PromQuery = { ...query, expr: value };\n      onChange(nextQuery);\n\n      if (override && onRunQuery) {\n        onRunQuery();\n      }\n    }\n  };\n\n  onClickHintFix = () => {\n    const { datasource, query, onChange, onRunQuery } = this.props;\n    const { hint } = this.state;\n\n    onChange(datasource.modifyQuery(query, hint.fix.action));\n    onRunQuery();\n  };\n\n  onUpdateLanguage = () => {\n    const {\n      datasource,\n      datasource: { languageProvider },\n    } = this.props;\n    const { histogramMetrics, metrics, metricsMetadata, lookupMetricsThreshold } = languageProvider;\n\n    if (!metrics) {\n      return;\n    }\n\n    // Build metrics tree\n    const metricsByPrefix = groupMetricsByPrefix(metrics, metricsMetadata);\n    const histogramOptions = histogramMetrics.map((hm: any) => ({ label: hm, value: hm }));\n    const metricsOptions =\n      histogramMetrics.length > 0\n        ? [\n            { label: 'Histograms', value: HISTOGRAM_GROUP, children: histogramOptions, isLeaf: false },\n            ...metricsByPrefix,\n          ]\n        : metricsByPrefix;\n\n    // Hint for big disabled lookups\n    let hint: QueryHint;\n    if (!datasource.lookupsDisabled && languageProvider.lookupsDisabled) {\n      hint = {\n        label: `Dynamic label lookup is disabled for datasources with more than ${lookupMetricsThreshold} metrics.`,\n        type: 'INFO',\n      };\n    }\n\n    this.setState({ hint, metricsOptions, syntaxLoaded: true });\n  };\n\n  onTypeahead = async (typeahead: TypeaheadInput): Promise<TypeaheadOutput> => {\n    const {\n      datasource: { languageProvider },\n    } = this.props;\n\n    if (!languageProvider) {\n      return { suggestions: [] };\n    }\n\n    const { history } = this.props;\n    const { prefix, text, value, wrapperClasses, labelKey } = typeahead;\n\n    const result = await languageProvider.provideCompletionItems(\n      { text, value, prefix, wrapperClasses, labelKey },\n      { history }\n    );\n\n    // console.log('handleTypeahead', wrapperClasses, text, prefix, labelKey, result.context);\n\n    return result;\n  };\n\n  render() {\n    const {\n      datasource,\n      datasource: { languageProvider },\n      query,\n      ExtraFieldElement,\n    } = this.props;\n    const { metricsOptions, syntaxLoaded, hint } = this.state;\n    const cleanText = languageProvider ? languageProvider.cleanText : undefined;\n    const chooserText = getChooserText(datasource.lookupsDisabled, syntaxLoaded, metricsOptions);\n    const buttonDisabled = !(syntaxLoaded && metricsOptions && metricsOptions.length > 0);\n\n    return (\n      <>\n        <div className=\"gf-form-inline gf-form-inline--nowrap flex-grow-1\">\n          <div className=\"gf-form flex-shrink-0\">\n            <ButtonCascader options={metricsOptions} disabled={buttonDisabled} onChange={this.onChangeMetrics}>\n              {chooserText}\n            </ButtonCascader>\n          </div>\n          <div className=\"gf-form gf-form--grow flex-shrink-1\">\n            <QueryField\n              additionalPlugins={this.plugins}\n              cleanText={cleanText}\n              query={query.expr}\n              onTypeahead={this.onTypeahead}\n              onWillApplySuggestion={willApplySuggestion}\n              onBlur={this.props.onBlur}\n              onChange={this.onChangeQuery}\n              onRunQuery={this.props.onRunQuery}\n              placeholder=\"Enter a PromQL query (run with Shift+Enter)\"\n              portalOrigin=\"prometheus\"\n              syntaxLoaded={syntaxLoaded}\n            />\n          </div>\n          {ExtraFieldElement}\n        </div>\n        {hint ? (\n          <div className=\"query-row-break\">\n            <div className=\"prom-query-field-info text-warning\">\n              {hint.label}{' '}\n              {hint.fix ? (\n                <a className=\"text-link muted\" onClick={this.onClickHintFix}>\n                  {hint.fix.label}\n                </a>\n              ) : null}\n            </div>\n          </div>\n        ) : null}\n      </>\n    );\n  }\n}\n\nexport default PromQueryField;\n","import _ from 'lodash';\nimport React, { Component } from 'react';\n\nimport { PrometheusDatasource } from '../datasource';\nimport { PromQuery } from '../types';\nimport { DataQueryRequest, PanelData } from '@grafana/data';\nimport { getDatasourceSrv } from 'app/features/plugins/datasource_srv';\n\ninterface Props {\n  datasource: PrometheusDatasource;\n  query: PromQuery;\n  panelData?: PanelData;\n}\n\ninterface State {\n  href: string;\n}\n\nexport default class PromLink extends Component<Props, State> {\n  state: State = { href: null };\n  async componentDidUpdate(prevProps: Props) {\n    const { panelData } = this.props;\n\n    if (panelData && panelData.request && prevProps.panelData !== panelData) {\n      const href = await this.getExternalLink(panelData);\n      this.setState({ href });\n    }\n  }\n\n  async getExternalLink(panelData: PanelData): Promise<string> {\n    const { query } = this.props;\n    const { request } = panelData;\n\n    if (!request) {\n      return '';\n    }\n\n    const target = request.targets.length > 0 ? request.targets[0] : ({ datasource: null } as any);\n    const datasourceName = target.datasource;\n    const datasource: PrometheusDatasource = datasourceName\n      ? (((await getDatasourceSrv().get(datasourceName)) as any) as PrometheusDatasource)\n      : (this.props.datasource as PrometheusDatasource);\n\n    const range = request.range;\n    const start = datasource.getPrometheusTime(range.from, false);\n    const end = datasource.getPrometheusTime(range.to, true);\n    const rangeDiff = Math.ceil(end - start);\n    const endTime = range.to.utc().format('YYYY-MM-DD HH:mm');\n\n    const options = {\n      interval: request.interval,\n    } as DataQueryRequest<PromQuery>;\n\n    const queryOptions = datasource.createQuery(query, options, start, end);\n    const expr = {\n      'g0.expr': queryOptions.expr,\n      'g0.range_input': rangeDiff + 's',\n      'g0.end_input': endTime,\n      'g0.step_input': queryOptions.step,\n      'g0.tab': 0,\n    };\n\n    const args = _.map(expr, (v: string, k: string) => {\n      return k + '=' + encodeURIComponent(v);\n    }).join('&');\n    return `${datasource.directUrl}/graph?${args}`;\n  }\n\n  render() {\n    const { href } = this.state;\n\n    return (\n      <a href={href} target=\"_blank\" rel=\"noopener\">\n        Prometheus\n      </a>\n    );\n  }\n}\n","import _ from 'lodash';\nimport React, { PureComponent } from 'react';\n\n// Types\nimport { InlineFormLabel, LegacyForms, Select } from '@grafana/ui';\nimport { SelectableValue, QueryEditorProps } from '@grafana/data';\n\nconst { Switch } = LegacyForms;\n\nimport { PrometheusDatasource } from '../datasource';\nimport { PromQuery, PromOptions } from '../types';\n\nimport PromQueryField from './PromQueryField';\nimport PromLink from './PromLink';\nexport type Props = QueryEditorProps<PrometheusDatasource, PromQuery, PromOptions>;\n\nconst FORMAT_OPTIONS: Array<SelectableValue<string>> = [\n  { label: 'Time series', value: 'time_series' },\n  { label: 'Table', value: 'table' },\n  { label: 'Heatmap', value: 'heatmap' },\n];\n\nconst INTERVAL_FACTOR_OPTIONS: Array<SelectableValue<number>> = _.map([1, 2, 3, 4, 5, 10], (value: number) => ({\n  value,\n  label: '1/' + value,\n}));\n\ninterface State {\n  legendFormat: string;\n  formatOption: SelectableValue<string>;\n  interval: string;\n  intervalFactorOption: SelectableValue<number>;\n  instant: boolean;\n}\n\nexport class PromQueryEditor extends PureComponent<Props, State> {\n  // Query target to be modified and used for queries\n  query: PromQuery;\n\n  constructor(props: Props) {\n    super(props);\n    // Use default query to prevent undefined input values\n    const defaultQuery: Partial<PromQuery> = { expr: '', legendFormat: '', interval: '' };\n    const query = Object.assign({}, defaultQuery, props.query);\n    this.query = query;\n    // Query target properties that are fully controlled inputs\n    this.state = {\n      // Fully controlled text inputs\n      interval: query.interval,\n      legendFormat: query.legendFormat,\n      // Select options\n      formatOption: FORMAT_OPTIONS.find(option => option.value === query.format) || FORMAT_OPTIONS[0],\n      intervalFactorOption:\n        INTERVAL_FACTOR_OPTIONS.find(option => option.value === query.intervalFactor) || INTERVAL_FACTOR_OPTIONS[0],\n      // Switch options\n      instant: Boolean(query.instant),\n    };\n  }\n\n  onFieldChange = (query: PromQuery, override?: any) => {\n    this.query.expr = query.expr;\n  };\n\n  onFormatChange = (option: SelectableValue<string>) => {\n    this.query.format = option.value;\n    this.setState({ formatOption: option }, this.onRunQuery);\n  };\n\n  onInstantChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const instant = e.target.checked;\n    this.query.instant = instant;\n    this.setState({ instant }, this.onRunQuery);\n  };\n\n  onIntervalChange = (e: React.SyntheticEvent<HTMLInputElement>) => {\n    const interval = e.currentTarget.value;\n    this.query.interval = interval;\n    this.setState({ interval });\n  };\n\n  onIntervalFactorChange = (option: SelectableValue<number>) => {\n    this.query.intervalFactor = option.value;\n    this.setState({ intervalFactorOption: option }, this.onRunQuery);\n  };\n\n  onLegendChange = (e: React.SyntheticEvent<HTMLInputElement>) => {\n    const legendFormat = e.currentTarget.value;\n    this.query.legendFormat = legendFormat;\n    this.setState({ legendFormat });\n  };\n\n  onRunQuery = () => {\n    const { query } = this;\n    this.props.onChange(query);\n    this.props.onRunQuery();\n  };\n\n  render() {\n    const { datasource, query, data } = this.props;\n    const { formatOption, instant, interval, intervalFactorOption, legendFormat } = this.state;\n\n    return (\n      <div>\n        <PromQueryField\n          datasource={datasource}\n          query={query}\n          onRunQuery={this.onRunQuery}\n          onChange={this.onFieldChange}\n          history={[]}\n          data={data}\n        />\n\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <InlineFormLabel\n              width={7}\n              tooltip=\"Controls the name of the time series, using name or pattern. For example\n        {{hostname}} will be replaced with label value for the label hostname.\"\n            >\n              Legend\n            </InlineFormLabel>\n            <input\n              type=\"text\"\n              className=\"gf-form-input\"\n              placeholder=\"legend format\"\n              value={legendFormat}\n              onChange={this.onLegendChange}\n              onBlur={this.onRunQuery}\n            />\n          </div>\n\n          <div className=\"gf-form\">\n            <InlineFormLabel\n              width={7}\n              tooltip={\n                <>\n                  An additional lower limit for the step parameter of the Prometheus query and for the{' '}\n                  <code>$__interval</code> variable. The limit is absolute and not modified by the \"Resolution\" setting.\n                </>\n              }\n            >\n              Min step\n            </InlineFormLabel>\n            <input\n              type=\"text\"\n              className=\"gf-form-input width-8\"\n              placeholder={interval}\n              onChange={this.onIntervalChange}\n              onBlur={this.onRunQuery}\n              value={interval}\n            />\n          </div>\n\n          <div className=\"gf-form\">\n            <div className=\"gf-form-label\">Resolution</div>\n            <Select\n              isSearchable={false}\n              options={INTERVAL_FACTOR_OPTIONS}\n              onChange={this.onIntervalFactorChange}\n              value={intervalFactorOption}\n            />\n          </div>\n\n          <div className=\"gf-form\">\n            <div className=\"gf-form-label width-7\">Format</div>\n            <Select\n              width={16}\n              isSearchable={false}\n              options={FORMAT_OPTIONS}\n              onChange={this.onFormatChange}\n              value={formatOption}\n            />\n            <Switch label=\"Instant\" checked={instant} onChange={this.onInstantChange} />\n\n            <InlineFormLabel width={10} tooltip=\"Link to Graph in Prometheus\">\n              <PromLink\n                datasource={datasource}\n                query={this.query} // Use modified query\n                panelData={data}\n              />\n            </InlineFormLabel>\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n","import React from 'react';\nimport { ExploreStartPageProps, DataQuery } from '@grafana/data';\n\nconst CHEAT_SHEET_ITEMS = [\n  {\n    title: 'Request Rate',\n    expression: 'rate(http_request_total[5m])',\n    label:\n      'Given an HTTP request counter, this query calculates the per-second average request rate over the last 5 minutes.',\n  },\n  {\n    title: '95th Percentile of Request Latencies',\n    expression: 'histogram_quantile(0.95, sum(rate(prometheus_http_request_duration_seconds_bucket[5m])) by (le))',\n    label: 'Calculates the 95th percentile of HTTP request rate over 5 minute windows.',\n  },\n  {\n    title: 'Alerts Firing',\n    expression: 'sort_desc(sum(sum_over_time(ALERTS{alertstate=\"firing\"}[24h])) by (alertname))',\n    label: 'Sums up the alerts that have been firing over the last 24 hours.',\n  },\n  {\n    title: 'Step',\n    label:\n      'Defines the graph resolution using a duration format (15s, 1m, 3h, ...). Small steps create high-resolution graphs but can be slow over larger time ranges. Using a longer step lowers the resolution and smooths the graph by producing fewer datapoints. If no step is given the resolution is calculated automatically.',\n  },\n];\n\nexport default (props: ExploreStartPageProps) => (\n  <div>\n    <h2>PromQL Cheat Sheet</h2>\n    {CHEAT_SHEET_ITEMS.map((item, index) => (\n      <div className=\"cheat-sheet-item\" key={index}>\n        <div className=\"cheat-sheet-item__title\">{item.title}</div>\n        {item.expression ? (\n          <div\n            className=\"cheat-sheet-item__example\"\n            onClick={e => props.onClickExample({ refId: 'A', expr: item.expression } as DataQuery)}\n          >\n            <code>{item.expression}</code>\n          </div>\n        ) : null}\n        <div className=\"cheat-sheet-item__label\">{item.label}</div>\n      </div>\n    ))}\n  </div>\n);\n","// Libraries\nimport React, { memo } from 'react';\n\n// Types\nimport { InlineFormLabel } from '@grafana/ui';\n\nexport interface PromExploreExtraFieldProps {\n  label: string;\n  onChangeFunc: (e: React.SyntheticEvent<HTMLInputElement>) => void;\n  onKeyDownFunc: (e: React.KeyboardEvent<HTMLInputElement>) => void;\n  value: string;\n  hasTooltip?: boolean;\n  tooltipContent?: string;\n}\n\nexport function PromExploreExtraField(props: PromExploreExtraFieldProps) {\n  const { label, onChangeFunc, onKeyDownFunc, value, hasTooltip, tooltipContent } = props;\n\n  return (\n    <div className=\"gf-form-inline explore-input--ml\" aria-label=\"Prometheus extra field\">\n      <div className=\"gf-form\">\n        <InlineFormLabel width={5} tooltip={hasTooltip ? tooltipContent : null}>\n          {label}\n        </InlineFormLabel>\n        <input\n          type={'text'}\n          className=\"gf-form-input width-4\"\n          placeholder={'auto'}\n          onChange={onChangeFunc}\n          onKeyDown={onKeyDownFunc}\n          value={value}\n        />\n      </div>\n    </div>\n  );\n}\n\nexport default memo(PromExploreExtraField);\n","import React, { memo } from 'react';\n\n// Types\nimport { ExploreQueryFieldProps } from '@grafana/data';\n\nimport { PrometheusDatasource } from '../datasource';\nimport { PromQuery, PromOptions } from '../types';\n\nimport PromQueryField from './PromQueryField';\nimport { PromExploreExtraField } from './PromExploreExtraField';\n\nexport type Props = ExploreQueryFieldProps<PrometheusDatasource, PromQuery, PromOptions>;\n\nexport function PromExploreQueryEditor(props: Props) {\n  const { query, data, datasource, history, onChange, onRunQuery } = props;\n\n  function onChangeQueryStep(value: string) {\n    const { query, onChange } = props;\n    const nextQuery = { ...query, interval: value };\n    onChange(nextQuery);\n  }\n\n  function onStepChange(e: React.SyntheticEvent<HTMLInputElement>) {\n    if (e.currentTarget.value !== query.interval) {\n      onChangeQueryStep(e.currentTarget.value);\n    }\n  }\n\n  function onReturnKeyDown(e: React.KeyboardEvent<HTMLInputElement>) {\n    if (e.key === 'Enter') {\n      onRunQuery();\n    }\n  }\n\n  return (\n    <PromQueryField\n      datasource={datasource}\n      query={query}\n      onRunQuery={onRunQuery}\n      onChange={onChange}\n      onBlur={() => {}}\n      history={history}\n      data={data}\n      ExtraFieldElement={\n        <PromExploreExtraField\n          label={'Step'}\n          onChangeFunc={onStepChange}\n          onKeyDownFunc={onReturnKeyDown}\n          value={query.interval || ''}\n          hasTooltip={true}\n          tooltipContent={\n            'Time units can be used here, for example: 5s, 1m, 3h, 1d, 1y (Default if no unit is specified: s)'\n          }\n        />\n      }\n    />\n  );\n}\n\nexport default memo(PromExploreQueryEditor);\n","import React, { SyntheticEvent } from 'react';\nimport { EventsWithValidation, InlineFormLabel, regexValidation, LegacyForms } from '@grafana/ui';\nconst { Select, Input, FormField, Switch } = LegacyForms;\nimport {\n  SelectableValue,\n  onUpdateDatasourceJsonDataOptionChecked,\n  DataSourcePluginOptionsEditorProps,\n} from '@grafana/data';\nimport { PromOptions } from '../types';\n\nconst httpOptions = [\n  { value: 'GET', label: 'GET' },\n  { value: 'POST', label: 'POST' },\n];\n\ntype Props = Pick<DataSourcePluginOptionsEditorProps<PromOptions>, 'options' | 'onOptionsChange'>;\n\nexport const PromSettings = (props: Props) => {\n  const { options, onOptionsChange } = props;\n\n  return (\n    <>\n      <div className=\"gf-form-group\">\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <FormField\n              label=\"Scrape interval\"\n              labelWidth={13}\n              inputEl={\n                <Input\n                  className=\"width-6\"\n                  value={options.jsonData.timeInterval}\n                  spellCheck={false}\n                  placeholder=\"15s\"\n                  onChange={onChangeHandler('timeInterval', options, onOptionsChange)}\n                  validationEvents={promSettingsValidationEvents}\n                />\n              }\n              tooltip=\"Set this to the typical scrape and evaluation interval configured in Prometheus. Defaults to 15s.\"\n            />\n          </div>\n        </div>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <FormField\n              label=\"Query timeout\"\n              labelWidth={13}\n              inputEl={\n                <Input\n                  className=\"width-6\"\n                  value={options.jsonData.queryTimeout}\n                  onChange={onChangeHandler('queryTimeout', options, onOptionsChange)}\n                  spellCheck={false}\n                  placeholder=\"60s\"\n                  validationEvents={promSettingsValidationEvents}\n                />\n              }\n              tooltip=\"Set the Prometheus query timeout.\"\n            />\n          </div>\n        </div>\n        <div className=\"gf-form\">\n          <InlineFormLabel\n            width={13}\n            tooltip=\"Specify the HTTP Method to query Prometheus. (POST is only available in Prometheus >= v2.1.0)\"\n          >\n            HTTP Method\n          </InlineFormLabel>\n          <Select\n            options={httpOptions}\n            value={httpOptions.find(o => o.value === options.jsonData.httpMethod)}\n            onChange={onChangeHandler('httpMethod', options, onOptionsChange)}\n            width={7}\n          />\n        </div>\n      </div>\n      <h3 className=\"page-heading\">Misc</h3>\n      <div className=\"gf-form-group\">\n        <div className=\"gf-form\">\n          <Switch\n            checked={options.jsonData.disableMetricsLookup}\n            label=\"Disable metrics lookup\"\n            labelClass=\"width-14\"\n            onChange={onUpdateDatasourceJsonDataOptionChecked(props, 'disableMetricsLookup')}\n            tooltip=\"Checking this option will disable the metrics chooser and metric/label support in the query field's autocomplete. This helps if you have performance issues with bigger Prometheus instances.\"\n          />\n        </div>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form max-width-30\">\n            <FormField\n              label=\"Custom query parameters\"\n              labelWidth={14}\n              tooltip=\"Add Custom parameters to Prometheus or Thanos queries.\"\n              inputEl={\n                <Input\n                  className=\"width-25\"\n                  value={options.jsonData.customQueryParameters}\n                  onChange={onChangeHandler('customQueryParameters', options, onOptionsChange)}\n                  spellCheck={false}\n                  placeholder=\"Example: max_source_resolution=5m&timeout=10\"\n                />\n              }\n            />\n          </div>\n        </div>\n      </div>\n    </>\n  );\n};\n\nexport const promSettingsValidationEvents = {\n  [EventsWithValidation.onBlur]: [\n    regexValidation(\n      /^$|^\\d+(ms|[Mwdhmsy])$/,\n      'Value is not valid, you can use number with time unit specifier: y, M, w, d, h, m, s'\n    ),\n  ],\n};\n\nexport const getValueFromEventItem = (eventItem: SyntheticEvent<HTMLInputElement> | SelectableValue<string>) => {\n  if (!eventItem) {\n    return '';\n  }\n\n  if (eventItem.hasOwnProperty('currentTarget')) {\n    return eventItem.currentTarget.value;\n  }\n\n  return (eventItem as SelectableValue<string>).value;\n};\n\nconst onChangeHandler = (\n  key: keyof PromOptions,\n  options: Props['options'],\n  onOptionsChange: Props['onOptionsChange']\n) => (eventItem: SyntheticEvent<HTMLInputElement> | SelectableValue<string>) => {\n  onOptionsChange({\n    ...options,\n    jsonData: {\n      ...options.jsonData,\n      [key]: getValueFromEventItem(eventItem),\n    },\n  });\n};\n","import { DataSourcePlugin } from '@grafana/data';\nimport { ANNOTATION_QUERY_STEP_DEFAULT, PrometheusDatasource } from './datasource';\n\nimport { PromQueryEditor } from './components/PromQueryEditor';\nimport PromCheatSheet from './components/PromCheatSheet';\nimport PromExploreQueryEditor from './components/PromExploreQueryEditor';\n\nimport { ConfigEditor } from './configuration/ConfigEditor';\n\nclass PrometheusAnnotationsQueryCtrl {\n  static templateUrl = 'partials/annotations.editor.html';\n  stepDefaultValuePlaceholder = ANNOTATION_QUERY_STEP_DEFAULT;\n}\n\nexport const plugin = new DataSourcePlugin(PrometheusDatasource)\n  .setQueryEditor(PromQueryEditor)\n  .setConfigEditor(ConfigEditor)\n  .setExploreMetricsQueryField(PromExploreQueryEditor)\n  .setAnnotationQueryCtrl(PrometheusAnnotationsQueryCtrl)\n  .setExploreStartPage(PromCheatSheet);\n","import React from 'react';\nimport { DataSourceHttpSettings } from '@grafana/ui';\nimport { DataSourcePluginOptionsEditorProps } from '@grafana/data';\nimport { PromSettings } from './PromSettings';\nimport { PromOptions } from '../types';\n\nexport type Props = DataSourcePluginOptionsEditorProps<PromOptions>;\nexport const ConfigEditor = (props: Props) => {\n  const { options, onOptionsChange } = props;\n  return (\n    <>\n      <DataSourceHttpSettings\n        defaultUrl=\"http://localhost:9090\"\n        dataSourceConfig={options}\n        showAccessOptions={true}\n        onChange={onOptionsChange}\n      />\n\n      <PromSettings options={options} onOptionsChange={onOptionsChange} />\n    </>\n  );\n};\n","// https://github.com/facebook/react/issues/5465\n\nexport interface CancelablePromise<T> {\n  promise: Promise<T>;\n  cancel: () => void;\n}\n\nexport const makePromiseCancelable = <T>(promise: Promise<T>): CancelablePromise<T> => {\n  let hasCanceled_ = false;\n\n  const wrappedPromise = new Promise<T>((resolve, reject) => {\n    promise.then(val => (hasCanceled_ ? reject({ isCanceled: true }) : resolve(val)));\n    promise.catch(error => (hasCanceled_ ? reject({ isCanceled: true }) : reject(error)));\n  });\n\n  return {\n    promise: wrappedPromise,\n    cancel() {\n      hasCanceled_ = true;\n    },\n  };\n};\n"],"sourceRoot":""}