{"version":3,"sources":["webpack:///./public/app/plugins/datasource/zipkin/utils/transforms.ts","webpack:///./public/app/plugins/datasource/zipkin/datasource.ts","webpack:///./public/app/plugins/datasource/zipkin/constants.ts","webpack:///./node_modules/react-use/esm/useEffectOnce.js","webpack:///./node_modules/react-use/esm/useMount.js","webpack:///./public/app/plugins/datasource/zipkin/QueryField.tsx","webpack:///./public/app/plugins/datasource/zipkin/module.ts","webpack:///./public/app/plugins/datasource/zipkin/ConfigEditor.tsx","webpack:///./node_modules/react-use/esm/useAsyncFn.js","webpack:///./node_modules/react-use/esm/useMountedState.js"],"names":["transformSpan","span","jaegerSpan","duration","flags","logs","annotations","map","transformAnnotation","operationName","name","processID","localEndpoint","serviceName","remoteEndpoint","startTime","timestamp","spanID","id","traceID","traceId","warnings","tags","Object","keys","key","type","value","references","parentId","refType","kind","annotation","fields","gatherProcesses","zSpans","processes","reduce","acc","push","endpointToProcess","keyBy","endpoint","valueToTag","ipv4","ipv6","port","filter","identity","ZipkinDatasource","instanceSettings","options","targets","query","this","request","pipe","responseToDataQueryResponse","of","emptyDataQueryResponse","url","params","silent","toPromise","res","data","metadataRequest","apiUrl","baseUrl","serializeParams","req","length","from","getBackendSrv","datasourceRequest","DataSourceApi","response","MutableDataFrame","FieldType","trace","values","spans","effect","fn","noTracesFoundOptions","label","isLeaf","noTracesOptions","plugin","DataSourcePlugin","setConfigEditor","onOptionsChange","defaultUrl","dataSourceConfig","showAccessOptions","onChange","setExploreQueryField","onRunQuery","datasource","serviceOptions","useAsyncFn","services","sort","service","appEvents","emit","AppEvents","alertError","servicesOptions","fetch","useMount","useServices","isMounted","useMountedState","useState","allOptions","setAllOptions","fetchSpans","state","spanOptions","fromPairs","undefined","fetchTraces","spanName","search","traces","newTraces","rootSpan","find","Math","floor","onLoadOptions","useCallback","selectedOptions","useLoadOptions","onSelectTrace","cascaderOptions","useMemo","children","traceName","useMapToCascaderOptions","className","loadData","style","width","e","currentTarget","deps","initialState","loading","lastCallId","_a","set","args","_i","arguments","callId","current","apply","then","error","mountedRef","get"],"mappings":"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","file":"zipkinPlugin.017a0d1a58b1119d038d.js","sourcesContent":["import { identity } from 'lodash';\nimport { keyBy } from 'lodash';\nimport { ZipkinAnnotation, ZipkinEndpoint, ZipkinSpan } from '../types';\nimport { KeyValuePair, Log, Process, SpanData, TraceData } from '@jaegertracing/jaeger-ui-components';\n\n/**\n * Transforms response to format similar to Jaegers as we use Jaeger ui on the frontend.\n */\nexport function transformResponse(zSpans: ZipkinSpan[]): TraceData & { spans: SpanData[] } {\n  return {\n    processes: gatherProcesses(zSpans),\n    traceID: zSpans[0].traceId,\n    spans: zSpans.map(transformSpan),\n    warnings: null,\n  };\n}\n\nfunction transformSpan(span: ZipkinSpan): SpanData {\n  const jaegerSpan: SpanData = {\n    duration: span.duration,\n    // TODO: not sure what this is\n    flags: 1,\n    logs: span.annotations?.map(transformAnnotation) ?? [],\n    operationName: span.name,\n    processID: span.localEndpoint?.serviceName || span.remoteEndpoint?.serviceName || 'unknown',\n    startTime: span.timestamp,\n    spanID: span.id,\n    traceID: span.traceId,\n    warnings: null as any,\n    tags: Object.keys(span.tags || {}).map(key => {\n      // If tag is error we remap it to simple boolean so that the Jaeger ui will show an error icon.\n      return {\n        key,\n        type: key === 'error' ? 'bool' : 'string',\n        value: key === 'error' ? true : span.tags![key],\n      };\n    }),\n    references: span.parentId\n      ? [\n          {\n            refType: 'CHILD_OF',\n            spanID: span.parentId,\n            traceID: span.traceId,\n          },\n        ]\n      : [],\n  };\n  if (span.kind) {\n    jaegerSpan.tags = [\n      {\n        key: 'kind',\n        type: 'string',\n        value: span.kind,\n      },\n      ...jaegerSpan.tags,\n    ];\n  }\n\n  return jaegerSpan;\n}\n\n/**\n * Maps annotations as a Jaeger log as that seems to be the closest thing.\n * See https://zipkin.io/zipkin-api/#/default/get_trace__traceId_\n */\nfunction transformAnnotation(annotation: ZipkinAnnotation): Log {\n  return {\n    timestamp: annotation.timestamp,\n    fields: [\n      {\n        key: 'annotation',\n        type: 'string',\n        value: annotation.value,\n      },\n    ],\n  };\n}\n\nfunction gatherProcesses(zSpans: ZipkinSpan[]): Record<string, Process> {\n  const processes = zSpans.reduce((acc, span) => {\n    if (span.localEndpoint) {\n      acc.push(endpointToProcess(span.localEndpoint));\n    }\n    if (span.remoteEndpoint) {\n      acc.push(endpointToProcess(span.remoteEndpoint));\n    }\n    return acc;\n  }, [] as Process[]);\n  return keyBy(processes, 'serviceName');\n}\n\nfunction endpointToProcess(endpoint: ZipkinEndpoint): Process {\n  return {\n    serviceName: endpoint.serviceName,\n    tags: [\n      valueToTag('ipv4', endpoint.ipv4, 'string'),\n      valueToTag('ipv6', endpoint.ipv6, 'string'),\n      valueToTag('port', endpoint.port, 'number'),\n    ].filter(identity) as KeyValuePair[],\n  };\n}\n\nfunction valueToTag(key: string, value: string | number | undefined, type: string): KeyValuePair | undefined {\n  if (!value) {\n    return undefined;\n  }\n  return {\n    key,\n    type,\n    value,\n  };\n}\n","import {\n  MutableDataFrame,\n  DataSourceApi,\n  DataSourceInstanceSettings,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataQuery,\n  FieldType,\n} from '@grafana/data';\nimport { from, Observable, of } from 'rxjs';\nimport { DatasourceRequestOptions } from '../../../core/services/backend_srv';\nimport { serializeParams } from '../../../core/utils/fetch';\nimport { getBackendSrv } from '@grafana/runtime';\nimport { map } from 'rxjs/operators';\nimport { apiPrefix } from './constants';\nimport { ZipkinSpan } from './types';\nimport { transformResponse } from './utils/transforms';\n\nexport type ZipkinQuery = {\n  // At the moment this should be simply the trace ID to get\n  query: string;\n} & DataQuery;\n\nexport class ZipkinDatasource extends DataSourceApi<ZipkinQuery> {\n  constructor(private instanceSettings: DataSourceInstanceSettings) {\n    super(instanceSettings);\n  }\n\n  query(options: DataQueryRequest<ZipkinQuery>): Observable<DataQueryResponse> {\n    const traceId = options.targets[0]?.query;\n    if (traceId) {\n      return this.request<ZipkinSpan[]>(`${apiPrefix}/trace/${traceId}`).pipe(map(responseToDataQueryResponse));\n    } else {\n      return of(emptyDataQueryResponse);\n    }\n  }\n\n  async metadataRequest(url: string, params?: Record<string, any>): Promise<any> {\n    const res = await this.request(url, params, { silent: true }).toPromise();\n    return res.data;\n  }\n\n  async testDatasource(): Promise<any> {\n    await this.metadataRequest(`${apiPrefix}/services`);\n    return true;\n  }\n\n  getQueryDisplayText(query: ZipkinQuery) {\n    return query.query;\n  }\n\n  private request<T = any>(apiUrl: string, data?: any, options?: DatasourceRequestOptions): Observable<{ data: T }> {\n    // Hack for proxying metadata requests\n    const baseUrl = `/api/datasources/proxy/${this.instanceSettings.id}`;\n    const params = data ? serializeParams(data) : '';\n    const url = `${baseUrl}${apiUrl}${params.length ? `?${params}` : ''}`;\n    const req = {\n      ...options,\n      url,\n    };\n\n    return from(getBackendSrv().datasourceRequest(req));\n  }\n}\n\nfunction responseToDataQueryResponse(response: { data: ZipkinSpan[] }): DataQueryResponse {\n  return {\n    data: [\n      new MutableDataFrame({\n        fields: [\n          {\n            name: 'trace',\n            type: FieldType.trace,\n            // There is probably better mapping than just putting everything in as a single value but that's how\n            // we do it with jaeger and is the simplest right now.\n            values: response?.data ? [transformResponse(response?.data)] : [],\n          },\n        ],\n      }),\n    ],\n  };\n}\n\nconst emptyDataQueryResponse = {\n  data: [\n    new MutableDataFrame({\n      fields: [\n        {\n          name: 'trace',\n          type: FieldType.trace,\n          values: [],\n        },\n      ],\n    }),\n  ],\n};\n","export const apiPrefix = '/api/v2';\n","import { useEffect } from 'react';\nvar useEffectOnce = function (effect) {\n    useEffect(effect, []);\n};\nexport default useEffectOnce;\n","import useEffectOnce from './useEffectOnce';\nvar useMount = function (fn) {\n    useEffectOnce(function () {\n        fn();\n    });\n};\nexport default useMount;\n","import React, { useCallback, useMemo, useState } from 'react';\nimport { ZipkinDatasource, ZipkinQuery } from './datasource';\nimport { AppEvents, ExploreQueryFieldProps } from '@grafana/data';\nimport { ButtonCascader, CascaderOption } from '@grafana/ui';\nimport { useAsyncFn, useMount, useMountedState } from 'react-use';\nimport { appEvents } from '../../../core/core';\nimport { apiPrefix } from './constants';\nimport { ZipkinSpan } from './types';\nimport { fromPairs } from 'lodash';\nimport { AsyncState } from 'react-use/lib/useAsyncFn';\n\ntype Props = ExploreQueryFieldProps<ZipkinDatasource, ZipkinQuery>;\n\nexport const QueryField = ({ query, onChange, onRunQuery, datasource }: Props) => {\n  const serviceOptions = useServices(datasource);\n  const { onLoadOptions, allOptions } = useLoadOptions(datasource);\n\n  const onSelectTrace = useCallback(\n    (values: string[], selectedOptions: CascaderOption[]) => {\n      if (selectedOptions.length === 3) {\n        const traceID = selectedOptions[2].value;\n        onChange({ ...query, query: traceID });\n        onRunQuery();\n      }\n    },\n    [onChange, onRunQuery, query]\n  );\n\n  let cascaderOptions = useMapToCascaderOptions(serviceOptions, allOptions);\n\n  return (\n    <>\n      <div className=\"gf-form-inline gf-form-inline--nowrap\">\n        <div className=\"gf-form flex-shrink-0\">\n          <ButtonCascader options={cascaderOptions} onChange={onSelectTrace} loadData={onLoadOptions}>\n            Traces\n          </ButtonCascader>\n        </div>\n        <div className=\"gf-form gf-form--grow flex-shrink-1\">\n          <div className={'slate-query-field__wrapper'}>\n            <div className=\"slate-query-field\">\n              <input\n                style={{ width: '100%' }}\n                value={query.query || ''}\n                onChange={e =>\n                  onChange({\n                    ...query,\n                    query: e.currentTarget.value,\n                  })\n                }\n              />\n            </div>\n          </div>\n        </div>\n      </div>\n    </>\n  );\n};\n\n// Exported for tests\nexport function useServices(datasource: ZipkinDatasource): AsyncState<CascaderOption[]> {\n  const url = `${apiPrefix}/services`;\n\n  const [servicesOptions, fetch] = useAsyncFn(async (): Promise<CascaderOption[]> => {\n    try {\n      const services: string[] | null = await datasource.metadataRequest(url);\n      if (services) {\n        return services.sort().map(service => ({\n          label: service,\n          value: service,\n          isLeaf: false,\n        }));\n      }\n      return [];\n    } catch (error) {\n      appEvents.emit(AppEvents.alertError, ['Failed to load services from Zipkin', error]);\n      throw error;\n    }\n  }, [datasource]);\n\n  useMount(() => {\n    // We should probably call this periodically to get new services after mount.\n    fetch();\n  });\n\n  return servicesOptions;\n}\n\ntype OptionsState = {\n  [serviceName: string]: {\n    [spanName: string]: {\n      [traceId: string]: string;\n    };\n  };\n};\n\n// Exported for tests\nexport function useLoadOptions(datasource: ZipkinDatasource) {\n  const isMounted = useMountedState();\n  const [allOptions, setAllOptions] = useState({} as OptionsState);\n\n  const [, fetchSpans] = useAsyncFn(\n    async function findSpans(service: string): Promise<void> {\n      const url = `${apiPrefix}/spans`;\n      try {\n        // The response of this should have been full ZipkinSpan objects based on API docs but is just list\n        // of span names.\n        // TODO: check if this is some issue of version used or something else\n        const response: string[] = await datasource.metadataRequest(url, { serviceName: service });\n        if (isMounted()) {\n          setAllOptions(state => {\n            const spanOptions = fromPairs(response.map((span: string) => [span, undefined]));\n            return {\n              ...state,\n              [service]: spanOptions as any,\n            };\n          });\n        }\n      } catch (error) {\n        appEvents.emit(AppEvents.alertError, ['Failed to load spans from Zipkin', error]);\n        throw error;\n      }\n    },\n    [datasource, allOptions]\n  );\n\n  const [, fetchTraces] = useAsyncFn(\n    async function findTraces(serviceName: string, spanName: string): Promise<void> {\n      const url = `${apiPrefix}/traces`;\n      const search = {\n        serviceName,\n        spanName,\n        // See other params and default here https://zipkin.io/zipkin-api/#/default/get_traces\n      };\n      try {\n        // This should return just root traces as there isn't any nesting\n        const traces: ZipkinSpan[][] = await datasource.metadataRequest(url, search);\n        if (isMounted()) {\n          const newTraces = traces.length\n            ? fromPairs(\n                traces.map(trace => {\n                  const rootSpan = trace.find(span => !span.parentId);\n\n                  return [`${rootSpan.name} [${Math.floor(rootSpan.duration / 1000)} ms]`, rootSpan.traceId];\n                })\n              )\n            : noTracesOptions;\n\n          setAllOptions(state => {\n            const spans = state[serviceName];\n            return {\n              ...state,\n              [serviceName]: {\n                ...spans,\n                [spanName]: newTraces,\n              },\n            };\n          });\n        }\n      } catch (error) {\n        appEvents.emit(AppEvents.alertError, ['Failed to load spans from Zipkin', error]);\n        throw error;\n      }\n    },\n    [datasource]\n  );\n\n  const onLoadOptions = useCallback(\n    (selectedOptions: CascaderOption[]) => {\n      const service = selectedOptions[0].value;\n      if (selectedOptions.length === 1) {\n        fetchSpans(service);\n      } else if (selectedOptions.length === 2) {\n        const spanName = selectedOptions[1].value;\n        fetchTraces(service, spanName);\n      }\n    },\n    [fetchSpans, fetchTraces]\n  );\n\n  return {\n    onLoadOptions,\n    allOptions,\n  };\n}\n\nfunction useMapToCascaderOptions(services: AsyncState<CascaderOption[]>, allOptions: OptionsState) {\n  return useMemo(() => {\n    let cascaderOptions: CascaderOption[];\n    if (services.value && services.value.length) {\n      cascaderOptions = services.value.map(services => {\n        return {\n          ...services,\n          children:\n            allOptions[services.value] &&\n            Object.keys(allOptions[services.value]).map(spanName => {\n              return {\n                label: spanName,\n                value: spanName,\n                isLeaf: false,\n                children:\n                  allOptions[services.value][spanName] &&\n                  Object.keys(allOptions[services.value][spanName]).map(traceName => {\n                    return {\n                      label: traceName,\n                      value: allOptions[services.value][spanName][traceName],\n                    };\n                  }),\n              };\n            }),\n        };\n      });\n    } else if (services.value && !services.value.length) {\n      cascaderOptions = noTracesFoundOptions;\n    }\n\n    return cascaderOptions;\n  }, [services, allOptions]);\n}\n\nconst NO_TRACES_KEY = '__NO_TRACES__';\nconst noTracesFoundOptions = [\n  {\n    label: 'No traces found',\n    value: 'no_traces',\n    isLeaf: true,\n\n    // Cannot be disabled because then cascader shows 'loading' for some reason.\n    // disabled: true,\n  },\n];\n\nconst noTracesOptions = {\n  '[No traces in time range]': NO_TRACES_KEY,\n};\n","import { DataSourcePlugin } from '@grafana/data';\nimport { ZipkinDatasource } from './datasource';\nimport { QueryField } from './QueryField';\nimport { ConfigEditor } from './ConfigEditor';\n\nexport const plugin = new DataSourcePlugin(ZipkinDatasource)\n  .setConfigEditor(ConfigEditor)\n  .setExploreQueryField(QueryField);\n","import React from 'react';\nimport { DataSourcePluginOptionsEditorProps } from '@grafana/data';\nimport { DataSourceHttpSettings } from '@grafana/ui';\n\nexport type Props = DataSourcePluginOptionsEditorProps;\n\nexport const ConfigEditor: React.FC<Props> = ({ options, onOptionsChange }) => {\n  return (\n    <DataSourceHttpSettings\n      defaultUrl={'http://localhost:9411'}\n      dataSourceConfig={options}\n      showAccessOptions={true}\n      onChange={onOptionsChange}\n    />\n  );\n};\n","/* eslint-disable */\nimport { useCallback, useState, useRef } from 'react';\nimport useMountedState from './useMountedState';\nexport default function useAsyncFn(fn, deps, initialState) {\n    if (deps === void 0) { deps = []; }\n    if (initialState === void 0) { initialState = { loading: false }; }\n    var lastCallId = useRef(0);\n    var _a = useState(initialState), state = _a[0], set = _a[1];\n    var isMounted = useMountedState();\n    var callback = useCallback(function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var callId = ++lastCallId.current;\n        set({ loading: true });\n        return fn.apply(void 0, args).then(function (value) {\n            isMounted() && callId === lastCallId.current && set({ value: value, loading: false });\n            return value;\n        }, function (error) {\n            isMounted() && callId === lastCallId.current && set({ error: error, loading: false });\n            return error;\n        });\n    }, deps);\n    return [state, callback];\n}\n","import { useCallback, useEffect, useRef } from 'react';\nexport default function useMountedState() {\n    var mountedRef = useRef(false);\n    var get = useCallback(function () { return mountedRef.current; }, []);\n    useEffect(function () {\n        mountedRef.current = true;\n        return function () {\n            mountedRef.current = false;\n        };\n    });\n    return get;\n}\n"],"sourceRoot":""}